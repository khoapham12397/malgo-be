
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = {
  username: string
  email: string
  create_time: Date
  admin_type: admin_type
  is_disabled: boolean
  auth0_id: string | null
}

/**
 * Model UserRating
 * 
 */
export type UserRating = {
  username: string
  rating: number
}

/**
 * Model FriendShip
 * 
 */
export type FriendShip = {
  id: string
  username1: string
  username2: string
  establishedAt: Date
}

/**
 * Model FriendRequest
 * 
 */
export type FriendRequest = {
  id: string
  senderId: string
  recieverId: string
  disable: boolean
}

/**
 * Model SharePTP
 * 
 */
export type SharePTP = {
  id: string
  resourceId: string
  resourceType: string
  senderId: string
  receiverId: string
  resourceLink: string | null
  look: boolean
  createdAt: Date
}

/**
 * Model Group
 * 
 */
export type Group = {
  id: string
  name: string
  creatorId: string
  generalChatSessionId: string | null
  createdAt: Date
}

/**
 * Model UserGroupRel
 * 
 */
export type UserGroupRel = {
  username: string
  groupId: string
  joinedAt: Date
}

/**
 * Model UserProfile
 * 
 */
export type UserProfile = {
  id: string
  real_name: string | null
  avatar: string | null
  blog: string | null
  github: string | null
  school: string | null
  major: string | null
  language: string | null
  accepted_number: number | null
  total_score: number | null
  total_practice_score: number | null
  submission_number: number | null
  rating: number | null
  username: string
}

/**
 * Model CodingProblemCategory
 * 
 */
export type CodingProblemCategory = {
  id: number
  name: string
}

/**
 * Model CodingProblemTag
 * 
 */
export type CodingProblemTag = {
  id: number
  name: string
}

/**
 * Model CodeforcesTag
 * 
 */
export type CodeforcesTag = {
  id: string
  name: string
  parentId: string | null
}

/**
 * Model CodefocesTagProblem
 * 
 */
export type CodefocesTagProblem = {
  problemId: string
  codeforcesTagId: string
}

/**
 * Model CodingProblem
 * 
 */
export type CodingProblem = {
  id: string
  code: string
  title: string
  categoryId: number
  link: string | null
  description: string | null
  timeLimit: number
  memoryLimit: number
  difficulty: number
  practicePoint: number
  totalPoint: number
  submissionNumber: number
  acceptedNumber: number
  contestId: string | null
  visibleFrom: Date | null
}

/**
 * Model AuthorCodingProblem
 * 
 */
export type AuthorCodingProblem = {
  username: string
  codingProblemId: string
}

/**
 * Model TagCodingProblem
 * 
 */
export type TagCodingProblem = {
  tagId: number
  codingProblemId: string
}

/**
 * Model Thread
 * 
 */
export type Thread = {
  id: string
  authorId: string
  parentId: string | null
  title: string
  summary: string
  published: boolean
  createdAt: Date
  lastUpdateAt: Date
  publishedAt: Date
  content: string
  totalComments: number
  totalRootComments: number
  likes: number
  views: number
  categoryId: number | null
}

/**
 * Model ThreadCategory
 * 
 */
export type ThreadCategory = {
  id: number
  parentId: string | null
  title: string
}

/**
 * Model ThreadTag
 * 
 */
export type ThreadTag = {
  id: string
  title: string
}

/**
 * Model ThreadTagRel
 * 
 */
export type ThreadTagRel = {
  threadId: string
  tagId: string
}

/**
 * Model UserLikeThread
 * 
 */
export type UserLikeThread = {
  username: string
  threadId: string
  disable: boolean
}

/**
 * Model UserLikeComment
 * 
 */
export type UserLikeComment = {
  username: string
  commentId: string
  disable: boolean
}

/**
 * Model Comment
 * 
 */
export type Comment = {
  id: string
  threadId: string
  parentId: string | null
  rootId: string
  totalChildren: number
  depth: number
  likes: number
  parentUsername: string | null
  creatorId: string
  published: boolean
  createdAt: Date
  content: string
}

/**
 * Model MathProblemCategory
 * 
 */
export type MathProblemCategory = {
  id: number
  name: string
}

/**
 * Model MathProblemTag
 * 
 */
export type MathProblemTag = {
  id: number
  name: string
  parentId: number | null
  nextSibling: number | null
  prevSibling: number | null
}

/**
 * Model MathProblem
 * 
 */
export type MathProblem = {
  id: string
  title: string
  categoryId: number
  link: string | null
  description: string | null
  hint: string | null
  difficulty: number
  practicePoint: number | null
  totalPoint: number | null
  prevProblems: string | null
  nextProblems: string | null
  numSolution: number
  numCheckedSolution: number
}

/**
 * Model MathProblemSet
 * 
 */
export type MathProblemSet = {
  id: string
  title: string
  creatorId: string
  numberProb: number
}

/**
 * Model MathSetProbRel
 * 
 */
export type MathSetProbRel = {
  problemId: string
  setId: string
  order: string
}

/**
 * Model AuthorMathProblem
 * 
 */
export type AuthorMathProblem = {
  username: string
  mathProblemId: string
}

/**
 * Model TagMathProblem
 * 
 */
export type TagMathProblem = {
  tagId: number
  mathProblemId: string
}

/**
 * Model GroupPost
 * 
 */
export type GroupPost = {
  id: string
  content: string
  authorId: string
  createdAt: Date
  groupId: string
  title: string
}

/**
 * Model ChatMessage
 * 
 */
export type ChatMessage = {
  id: string
  content: string
  authorId: string
  createdAt: Date
  referenceMessage: Prisma.JsonValue | null
  sessionId: string
}

/**
 * Model GroupPostMessage
 * 
 */
export type GroupPostMessage = {
  id: string
  content: string
  authorId: string
  createdAt: Date
  referenceMessage: Prisma.JsonValue | null
  postId: string
}

/**
 * Model ChatSession
 * 
 */
export type ChatSession = {
  id: string
  lastMessage: Prisma.JsonValue
  lastUpdate: Date
  groupId: string | null
  type: ChatSessionType
  usersInfo: Prisma.JsonValue | null
}

/**
 * Model ChatSessionUser
 * 
 */
export type ChatSessionUser = {
  sessionId: string
  username: string
  unseenCnt: number
  joinedAt: Date
}

/**
 * Model MathNote
 * 
 */
export type MathNote = {
  creatorId: string
  content: string
  mathProblemId: string
  createdAt: Date
  imageLink: string | null
}

/**
 * Model MathSolution
 * 
 */
export type MathSolution = {
  creatorId: string
  content: string
  mathProblemId: string
  createdAt: Date
  checked: boolean
  imageLink: string | null
}

/**
 * Model Contest
 * 
 */
export type Contest = {
  id: string
  title: string
  description: string
  realTimeRank: boolean
  password: string | null
  ruleType: ProblemRuleType
  startTime: Date
  duration: number
  endTime: Date
  createTime: Date
  lastUpdateTime: Date
  visible: boolean
}

/**
 * Model Submission
 * 
 */
export type Submission = {
  id: string
  contestId: string | null
  problemId: string
  createTime: Date
  username: string
  code: string
  result: JudgeStatus
  language: string
  shared: boolean
  status: Prisma.JsonValue | null
  statistic_info: Prisma.JsonValue
}

/**
 * Model ChildSubmission
 * 
 */
export type ChildSubmission = {
  id: string
  parentId: string
  status: Prisma.JsonValue
  token: string
  languageId: number
}

/**
 * Model Language
 * 
 */
export type Language = {
  id: number
  name: string
}

/**
 * Model Testcase
 * 
 */
export type Testcase = {
  id: string
  problemId: string
  subTestNumber: number
  description: Prisma.JsonValue
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const ChatSessionType: {
  p2p: 'p2p',
  group: 'group'
};

export type ChatSessionType = (typeof ChatSessionType)[keyof typeof ChatSessionType]


export const JudgeStatus: {
  COMPILE_ERROR: 'COMPILE_ERROR',
  WRONG_ANSWER: 'WRONG_ANSWER',
  ACCEPTED: 'ACCEPTED',
  CPU_TIME_LIMIT_EXCEEDED: 'CPU_TIME_LIMIT_EXCEEDED',
  REAL_TIME_LIMIT_EXCEEDED: 'REAL_TIME_LIMIT_EXCEEDED',
  MEMORY_LIMIT_EXCEEDED: 'MEMORY_LIMIT_EXCEEDED',
  RUNTIME_ERROR: 'RUNTIME_ERROR',
  SYSTEM_ERROR: 'SYSTEM_ERROR',
  PENDING: 'PENDING',
  JUDGING: 'JUDGING',
  PARTIALLY_ACCEPTED: 'PARTIALLY_ACCEPTED'
};

export type JudgeStatus = (typeof JudgeStatus)[keyof typeof JudgeStatus]


export const ProblemRuleType: {
  acm: 'acm',
  oi: 'oi'
};

export type ProblemRuleType = (typeof ProblemRuleType)[keyof typeof ProblemRuleType]


export const admin_type: {
  regular_user: 'regular_user',
  admin: 'admin',
  super_admin: 'super_admin'
};

export type admin_type = (typeof admin_type)[keyof typeof admin_type]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.userRating`: Exposes CRUD operations for the **UserRating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRatings
    * const userRatings = await prisma.userRating.findMany()
    * ```
    */
  get userRating(): Prisma.UserRatingDelegate<GlobalReject>;

  /**
   * `prisma.friendShip`: Exposes CRUD operations for the **FriendShip** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FriendShips
    * const friendShips = await prisma.friendShip.findMany()
    * ```
    */
  get friendShip(): Prisma.FriendShipDelegate<GlobalReject>;

  /**
   * `prisma.friendRequest`: Exposes CRUD operations for the **FriendRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FriendRequests
    * const friendRequests = await prisma.friendRequest.findMany()
    * ```
    */
  get friendRequest(): Prisma.FriendRequestDelegate<GlobalReject>;

  /**
   * `prisma.sharePTP`: Exposes CRUD operations for the **SharePTP** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SharePTPS
    * const sharePTPS = await prisma.sharePTP.findMany()
    * ```
    */
  get sharePTP(): Prisma.SharePTPDelegate<GlobalReject>;

  /**
   * `prisma.group`: Exposes CRUD operations for the **Group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.group.findMany()
    * ```
    */
  get group(): Prisma.GroupDelegate<GlobalReject>;

  /**
   * `prisma.userGroupRel`: Exposes CRUD operations for the **UserGroupRel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserGroupRels
    * const userGroupRels = await prisma.userGroupRel.findMany()
    * ```
    */
  get userGroupRel(): Prisma.UserGroupRelDelegate<GlobalReject>;

  /**
   * `prisma.userProfile`: Exposes CRUD operations for the **UserProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProfiles
    * const userProfiles = await prisma.userProfile.findMany()
    * ```
    */
  get userProfile(): Prisma.UserProfileDelegate<GlobalReject>;

  /**
   * `prisma.codingProblemCategory`: Exposes CRUD operations for the **CodingProblemCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CodingProblemCategories
    * const codingProblemCategories = await prisma.codingProblemCategory.findMany()
    * ```
    */
  get codingProblemCategory(): Prisma.CodingProblemCategoryDelegate<GlobalReject>;

  /**
   * `prisma.codingProblemTag`: Exposes CRUD operations for the **CodingProblemTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CodingProblemTags
    * const codingProblemTags = await prisma.codingProblemTag.findMany()
    * ```
    */
  get codingProblemTag(): Prisma.CodingProblemTagDelegate<GlobalReject>;

  /**
   * `prisma.codeforcesTag`: Exposes CRUD operations for the **CodeforcesTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CodeforcesTags
    * const codeforcesTags = await prisma.codeforcesTag.findMany()
    * ```
    */
  get codeforcesTag(): Prisma.CodeforcesTagDelegate<GlobalReject>;

  /**
   * `prisma.codefocesTagProblem`: Exposes CRUD operations for the **CodefocesTagProblem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CodefocesTagProblems
    * const codefocesTagProblems = await prisma.codefocesTagProblem.findMany()
    * ```
    */
  get codefocesTagProblem(): Prisma.CodefocesTagProblemDelegate<GlobalReject>;

  /**
   * `prisma.codingProblem`: Exposes CRUD operations for the **CodingProblem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CodingProblems
    * const codingProblems = await prisma.codingProblem.findMany()
    * ```
    */
  get codingProblem(): Prisma.CodingProblemDelegate<GlobalReject>;

  /**
   * `prisma.authorCodingProblem`: Exposes CRUD operations for the **AuthorCodingProblem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuthorCodingProblems
    * const authorCodingProblems = await prisma.authorCodingProblem.findMany()
    * ```
    */
  get authorCodingProblem(): Prisma.AuthorCodingProblemDelegate<GlobalReject>;

  /**
   * `prisma.tagCodingProblem`: Exposes CRUD operations for the **TagCodingProblem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TagCodingProblems
    * const tagCodingProblems = await prisma.tagCodingProblem.findMany()
    * ```
    */
  get tagCodingProblem(): Prisma.TagCodingProblemDelegate<GlobalReject>;

  /**
   * `prisma.thread`: Exposes CRUD operations for the **Thread** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Threads
    * const threads = await prisma.thread.findMany()
    * ```
    */
  get thread(): Prisma.ThreadDelegate<GlobalReject>;

  /**
   * `prisma.threadCategory`: Exposes CRUD operations for the **ThreadCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ThreadCategories
    * const threadCategories = await prisma.threadCategory.findMany()
    * ```
    */
  get threadCategory(): Prisma.ThreadCategoryDelegate<GlobalReject>;

  /**
   * `prisma.threadTag`: Exposes CRUD operations for the **ThreadTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ThreadTags
    * const threadTags = await prisma.threadTag.findMany()
    * ```
    */
  get threadTag(): Prisma.ThreadTagDelegate<GlobalReject>;

  /**
   * `prisma.threadTagRel`: Exposes CRUD operations for the **ThreadTagRel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ThreadTagRels
    * const threadTagRels = await prisma.threadTagRel.findMany()
    * ```
    */
  get threadTagRel(): Prisma.ThreadTagRelDelegate<GlobalReject>;

  /**
   * `prisma.userLikeThread`: Exposes CRUD operations for the **UserLikeThread** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserLikeThreads
    * const userLikeThreads = await prisma.userLikeThread.findMany()
    * ```
    */
  get userLikeThread(): Prisma.UserLikeThreadDelegate<GlobalReject>;

  /**
   * `prisma.userLikeComment`: Exposes CRUD operations for the **UserLikeComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserLikeComments
    * const userLikeComments = await prisma.userLikeComment.findMany()
    * ```
    */
  get userLikeComment(): Prisma.UserLikeCommentDelegate<GlobalReject>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<GlobalReject>;

  /**
   * `prisma.mathProblemCategory`: Exposes CRUD operations for the **MathProblemCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MathProblemCategories
    * const mathProblemCategories = await prisma.mathProblemCategory.findMany()
    * ```
    */
  get mathProblemCategory(): Prisma.MathProblemCategoryDelegate<GlobalReject>;

  /**
   * `prisma.mathProblemTag`: Exposes CRUD operations for the **MathProblemTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MathProblemTags
    * const mathProblemTags = await prisma.mathProblemTag.findMany()
    * ```
    */
  get mathProblemTag(): Prisma.MathProblemTagDelegate<GlobalReject>;

  /**
   * `prisma.mathProblem`: Exposes CRUD operations for the **MathProblem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MathProblems
    * const mathProblems = await prisma.mathProblem.findMany()
    * ```
    */
  get mathProblem(): Prisma.MathProblemDelegate<GlobalReject>;

  /**
   * `prisma.mathProblemSet`: Exposes CRUD operations for the **MathProblemSet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MathProblemSets
    * const mathProblemSets = await prisma.mathProblemSet.findMany()
    * ```
    */
  get mathProblemSet(): Prisma.MathProblemSetDelegate<GlobalReject>;

  /**
   * `prisma.mathSetProbRel`: Exposes CRUD operations for the **MathSetProbRel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MathSetProbRels
    * const mathSetProbRels = await prisma.mathSetProbRel.findMany()
    * ```
    */
  get mathSetProbRel(): Prisma.MathSetProbRelDelegate<GlobalReject>;

  /**
   * `prisma.authorMathProblem`: Exposes CRUD operations for the **AuthorMathProblem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuthorMathProblems
    * const authorMathProblems = await prisma.authorMathProblem.findMany()
    * ```
    */
  get authorMathProblem(): Prisma.AuthorMathProblemDelegate<GlobalReject>;

  /**
   * `prisma.tagMathProblem`: Exposes CRUD operations for the **TagMathProblem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TagMathProblems
    * const tagMathProblems = await prisma.tagMathProblem.findMany()
    * ```
    */
  get tagMathProblem(): Prisma.TagMathProblemDelegate<GlobalReject>;

  /**
   * `prisma.groupPost`: Exposes CRUD operations for the **GroupPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupPosts
    * const groupPosts = await prisma.groupPost.findMany()
    * ```
    */
  get groupPost(): Prisma.GroupPostDelegate<GlobalReject>;

  /**
   * `prisma.chatMessage`: Exposes CRUD operations for the **ChatMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatMessages
    * const chatMessages = await prisma.chatMessage.findMany()
    * ```
    */
  get chatMessage(): Prisma.ChatMessageDelegate<GlobalReject>;

  /**
   * `prisma.groupPostMessage`: Exposes CRUD operations for the **GroupPostMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupPostMessages
    * const groupPostMessages = await prisma.groupPostMessage.findMany()
    * ```
    */
  get groupPostMessage(): Prisma.GroupPostMessageDelegate<GlobalReject>;

  /**
   * `prisma.chatSession`: Exposes CRUD operations for the **ChatSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatSessions
    * const chatSessions = await prisma.chatSession.findMany()
    * ```
    */
  get chatSession(): Prisma.ChatSessionDelegate<GlobalReject>;

  /**
   * `prisma.chatSessionUser`: Exposes CRUD operations for the **ChatSessionUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatSessionUsers
    * const chatSessionUsers = await prisma.chatSessionUser.findMany()
    * ```
    */
  get chatSessionUser(): Prisma.ChatSessionUserDelegate<GlobalReject>;

  /**
   * `prisma.mathNote`: Exposes CRUD operations for the **MathNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MathNotes
    * const mathNotes = await prisma.mathNote.findMany()
    * ```
    */
  get mathNote(): Prisma.MathNoteDelegate<GlobalReject>;

  /**
   * `prisma.mathSolution`: Exposes CRUD operations for the **MathSolution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MathSolutions
    * const mathSolutions = await prisma.mathSolution.findMany()
    * ```
    */
  get mathSolution(): Prisma.MathSolutionDelegate<GlobalReject>;

  /**
   * `prisma.contest`: Exposes CRUD operations for the **Contest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contests
    * const contests = await prisma.contest.findMany()
    * ```
    */
  get contest(): Prisma.ContestDelegate<GlobalReject>;

  /**
   * `prisma.submission`: Exposes CRUD operations for the **Submission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Submissions
    * const submissions = await prisma.submission.findMany()
    * ```
    */
  get submission(): Prisma.SubmissionDelegate<GlobalReject>;

  /**
   * `prisma.childSubmission`: Exposes CRUD operations for the **ChildSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChildSubmissions
    * const childSubmissions = await prisma.childSubmission.findMany()
    * ```
    */
  get childSubmission(): Prisma.ChildSubmissionDelegate<GlobalReject>;

  /**
   * `prisma.language`: Exposes CRUD operations for the **Language** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Languages
    * const languages = await prisma.language.findMany()
    * ```
    */
  get language(): Prisma.LanguageDelegate<GlobalReject>;

  /**
   * `prisma.testcase`: Exposes CRUD operations for the **Testcase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Testcases
    * const testcases = await prisma.testcase.findMany()
    * ```
    */
  get testcase(): Prisma.TestcaseDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.12.0
   * Query Engine version: 659ef412370fa3b41cd7bf6e94587c1dfb7f67e7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserRating: 'UserRating',
    FriendShip: 'FriendShip',
    FriendRequest: 'FriendRequest',
    SharePTP: 'SharePTP',
    Group: 'Group',
    UserGroupRel: 'UserGroupRel',
    UserProfile: 'UserProfile',
    CodingProblemCategory: 'CodingProblemCategory',
    CodingProblemTag: 'CodingProblemTag',
    CodeforcesTag: 'CodeforcesTag',
    CodefocesTagProblem: 'CodefocesTagProblem',
    CodingProblem: 'CodingProblem',
    AuthorCodingProblem: 'AuthorCodingProblem',
    TagCodingProblem: 'TagCodingProblem',
    Thread: 'Thread',
    ThreadCategory: 'ThreadCategory',
    ThreadTag: 'ThreadTag',
    ThreadTagRel: 'ThreadTagRel',
    UserLikeThread: 'UserLikeThread',
    UserLikeComment: 'UserLikeComment',
    Comment: 'Comment',
    MathProblemCategory: 'MathProblemCategory',
    MathProblemTag: 'MathProblemTag',
    MathProblem: 'MathProblem',
    MathProblemSet: 'MathProblemSet',
    MathSetProbRel: 'MathSetProbRel',
    AuthorMathProblem: 'AuthorMathProblem',
    TagMathProblem: 'TagMathProblem',
    GroupPost: 'GroupPost',
    ChatMessage: 'ChatMessage',
    GroupPostMessage: 'GroupPostMessage',
    ChatSession: 'ChatSession',
    ChatSessionUser: 'ChatSessionUser',
    MathNote: 'MathNote',
    MathSolution: 'MathSolution',
    Contest: 'Contest',
    Submission: 'Submission',
    ChildSubmission: 'ChildSubmission',
    Language: 'Language',
    Testcase: 'Testcase'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    codingProblems: number
    authorMathProblems: number
    threads: number
    comments: number
    threadLiked: number
    commentLiked: number
    mathNotes: number
    mathSolutions: number
    mathProbSetList: number
    myFriendReqs: number
    otherFriendReqs: number
    createdGroup: number
    joinedGroups: number
    posts: number
    chatMessages: number
    chatSessions: number
    groupPostMessages: number
  }

  export type UserCountOutputTypeSelect = {
    codingProblems?: boolean
    authorMathProblems?: boolean
    threads?: boolean
    comments?: boolean
    threadLiked?: boolean
    commentLiked?: boolean
    mathNotes?: boolean
    mathSolutions?: boolean
    mathProbSetList?: boolean
    myFriendReqs?: boolean
    otherFriendReqs?: boolean
    createdGroup?: boolean
    joinedGroups?: boolean
    posts?: boolean
    chatMessages?: boolean
    chatSessions?: boolean
    groupPostMessages?: boolean
  }

  export type UserCountOutputTypeGetPayload<S extends boolean | null | undefined | UserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserCountOutputTypeArgs)
    ? UserCountOutputType 
    : S extends { select: any } & (UserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
      : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type GroupCountOutputType
   */


  export type GroupCountOutputType = {
    users: number
    posts: number
  }

  export type GroupCountOutputTypeSelect = {
    users?: boolean
    posts?: boolean
  }

  export type GroupCountOutputTypeGetPayload<S extends boolean | null | undefined | GroupCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? GroupCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (GroupCountOutputTypeArgs)
    ? GroupCountOutputType 
    : S extends { select: any } & (GroupCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof GroupCountOutputType ? GroupCountOutputType[P] : never
  } 
      : GroupCountOutputType




  // Custom InputTypes

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the GroupCountOutputType
     */
    select?: GroupCountOutputTypeSelect | null
  }



  /**
   * Count Type CodingProblemCategoryCountOutputType
   */


  export type CodingProblemCategoryCountOutputType = {
    codingProblems: number
  }

  export type CodingProblemCategoryCountOutputTypeSelect = {
    codingProblems?: boolean
  }

  export type CodingProblemCategoryCountOutputTypeGetPayload<S extends boolean | null | undefined | CodingProblemCategoryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CodingProblemCategoryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CodingProblemCategoryCountOutputTypeArgs)
    ? CodingProblemCategoryCountOutputType 
    : S extends { select: any } & (CodingProblemCategoryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CodingProblemCategoryCountOutputType ? CodingProblemCategoryCountOutputType[P] : never
  } 
      : CodingProblemCategoryCountOutputType




  // Custom InputTypes

  /**
   * CodingProblemCategoryCountOutputType without action
   */
  export type CodingProblemCategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CodingProblemCategoryCountOutputType
     */
    select?: CodingProblemCategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type CodingProblemTagCountOutputType
   */


  export type CodingProblemTagCountOutputType = {
    codingProblems: number
  }

  export type CodingProblemTagCountOutputTypeSelect = {
    codingProblems?: boolean
  }

  export type CodingProblemTagCountOutputTypeGetPayload<S extends boolean | null | undefined | CodingProblemTagCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CodingProblemTagCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CodingProblemTagCountOutputTypeArgs)
    ? CodingProblemTagCountOutputType 
    : S extends { select: any } & (CodingProblemTagCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CodingProblemTagCountOutputType ? CodingProblemTagCountOutputType[P] : never
  } 
      : CodingProblemTagCountOutputType




  // Custom InputTypes

  /**
   * CodingProblemTagCountOutputType without action
   */
  export type CodingProblemTagCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CodingProblemTagCountOutputType
     */
    select?: CodingProblemTagCountOutputTypeSelect | null
  }



  /**
   * Count Type CodeforcesTagCountOutputType
   */


  export type CodeforcesTagCountOutputType = {
    problems: number
  }

  export type CodeforcesTagCountOutputTypeSelect = {
    problems?: boolean
  }

  export type CodeforcesTagCountOutputTypeGetPayload<S extends boolean | null | undefined | CodeforcesTagCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CodeforcesTagCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CodeforcesTagCountOutputTypeArgs)
    ? CodeforcesTagCountOutputType 
    : S extends { select: any } & (CodeforcesTagCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CodeforcesTagCountOutputType ? CodeforcesTagCountOutputType[P] : never
  } 
      : CodeforcesTagCountOutputType




  // Custom InputTypes

  /**
   * CodeforcesTagCountOutputType without action
   */
  export type CodeforcesTagCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CodeforcesTagCountOutputType
     */
    select?: CodeforcesTagCountOutputTypeSelect | null
  }



  /**
   * Count Type CodingProblemCountOutputType
   */


  export type CodingProblemCountOutputType = {
    authors: number
    tags: number
    codeforcesTag: number
    testCases: number
  }

  export type CodingProblemCountOutputTypeSelect = {
    authors?: boolean
    tags?: boolean
    codeforcesTag?: boolean
    testCases?: boolean
  }

  export type CodingProblemCountOutputTypeGetPayload<S extends boolean | null | undefined | CodingProblemCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CodingProblemCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CodingProblemCountOutputTypeArgs)
    ? CodingProblemCountOutputType 
    : S extends { select: any } & (CodingProblemCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CodingProblemCountOutputType ? CodingProblemCountOutputType[P] : never
  } 
      : CodingProblemCountOutputType




  // Custom InputTypes

  /**
   * CodingProblemCountOutputType without action
   */
  export type CodingProblemCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CodingProblemCountOutputType
     */
    select?: CodingProblemCountOutputTypeSelect | null
  }



  /**
   * Count Type ThreadCountOutputType
   */


  export type ThreadCountOutputType = {
    comments: number
    tags: number
    userLikes: number
  }

  export type ThreadCountOutputTypeSelect = {
    comments?: boolean
    tags?: boolean
    userLikes?: boolean
  }

  export type ThreadCountOutputTypeGetPayload<S extends boolean | null | undefined | ThreadCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ThreadCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ThreadCountOutputTypeArgs)
    ? ThreadCountOutputType 
    : S extends { select: any } & (ThreadCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ThreadCountOutputType ? ThreadCountOutputType[P] : never
  } 
      : ThreadCountOutputType




  // Custom InputTypes

  /**
   * ThreadCountOutputType without action
   */
  export type ThreadCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ThreadCountOutputType
     */
    select?: ThreadCountOutputTypeSelect | null
  }



  /**
   * Count Type ThreadCategoryCountOutputType
   */


  export type ThreadCategoryCountOutputType = {
    threads: number
  }

  export type ThreadCategoryCountOutputTypeSelect = {
    threads?: boolean
  }

  export type ThreadCategoryCountOutputTypeGetPayload<S extends boolean | null | undefined | ThreadCategoryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ThreadCategoryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ThreadCategoryCountOutputTypeArgs)
    ? ThreadCategoryCountOutputType 
    : S extends { select: any } & (ThreadCategoryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ThreadCategoryCountOutputType ? ThreadCategoryCountOutputType[P] : never
  } 
      : ThreadCategoryCountOutputType




  // Custom InputTypes

  /**
   * ThreadCategoryCountOutputType without action
   */
  export type ThreadCategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ThreadCategoryCountOutputType
     */
    select?: ThreadCategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type ThreadTagCountOutputType
   */


  export type ThreadTagCountOutputType = {
    threads: number
  }

  export type ThreadTagCountOutputTypeSelect = {
    threads?: boolean
  }

  export type ThreadTagCountOutputTypeGetPayload<S extends boolean | null | undefined | ThreadTagCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ThreadTagCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ThreadTagCountOutputTypeArgs)
    ? ThreadTagCountOutputType 
    : S extends { select: any } & (ThreadTagCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ThreadTagCountOutputType ? ThreadTagCountOutputType[P] : never
  } 
      : ThreadTagCountOutputType




  // Custom InputTypes

  /**
   * ThreadTagCountOutputType without action
   */
  export type ThreadTagCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ThreadTagCountOutputType
     */
    select?: ThreadTagCountOutputTypeSelect | null
  }



  /**
   * Count Type CommentCountOutputType
   */


  export type CommentCountOutputType = {
    usersLiked: number
  }

  export type CommentCountOutputTypeSelect = {
    usersLiked?: boolean
  }

  export type CommentCountOutputTypeGetPayload<S extends boolean | null | undefined | CommentCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CommentCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CommentCountOutputTypeArgs)
    ? CommentCountOutputType 
    : S extends { select: any } & (CommentCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CommentCountOutputType ? CommentCountOutputType[P] : never
  } 
      : CommentCountOutputType




  // Custom InputTypes

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect | null
  }



  /**
   * Count Type MathProblemCategoryCountOutputType
   */


  export type MathProblemCategoryCountOutputType = {
    mathProblems: number
  }

  export type MathProblemCategoryCountOutputTypeSelect = {
    mathProblems?: boolean
  }

  export type MathProblemCategoryCountOutputTypeGetPayload<S extends boolean | null | undefined | MathProblemCategoryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MathProblemCategoryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (MathProblemCategoryCountOutputTypeArgs)
    ? MathProblemCategoryCountOutputType 
    : S extends { select: any } & (MathProblemCategoryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MathProblemCategoryCountOutputType ? MathProblemCategoryCountOutputType[P] : never
  } 
      : MathProblemCategoryCountOutputType




  // Custom InputTypes

  /**
   * MathProblemCategoryCountOutputType without action
   */
  export type MathProblemCategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MathProblemCategoryCountOutputType
     */
    select?: MathProblemCategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type MathProblemTagCountOutputType
   */


  export type MathProblemTagCountOutputType = {
    mathProblems: number
  }

  export type MathProblemTagCountOutputTypeSelect = {
    mathProblems?: boolean
  }

  export type MathProblemTagCountOutputTypeGetPayload<S extends boolean | null | undefined | MathProblemTagCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MathProblemTagCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (MathProblemTagCountOutputTypeArgs)
    ? MathProblemTagCountOutputType 
    : S extends { select: any } & (MathProblemTagCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MathProblemTagCountOutputType ? MathProblemTagCountOutputType[P] : never
  } 
      : MathProblemTagCountOutputType




  // Custom InputTypes

  /**
   * MathProblemTagCountOutputType without action
   */
  export type MathProblemTagCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MathProblemTagCountOutputType
     */
    select?: MathProblemTagCountOutputTypeSelect | null
  }



  /**
   * Count Type MathProblemCountOutputType
   */


  export type MathProblemCountOutputType = {
    authors: number
    tags: number
    mathNotes: number
    mathSolutions: number
    problemSet: number
  }

  export type MathProblemCountOutputTypeSelect = {
    authors?: boolean
    tags?: boolean
    mathNotes?: boolean
    mathSolutions?: boolean
    problemSet?: boolean
  }

  export type MathProblemCountOutputTypeGetPayload<S extends boolean | null | undefined | MathProblemCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MathProblemCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (MathProblemCountOutputTypeArgs)
    ? MathProblemCountOutputType 
    : S extends { select: any } & (MathProblemCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MathProblemCountOutputType ? MathProblemCountOutputType[P] : never
  } 
      : MathProblemCountOutputType




  // Custom InputTypes

  /**
   * MathProblemCountOutputType without action
   */
  export type MathProblemCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MathProblemCountOutputType
     */
    select?: MathProblemCountOutputTypeSelect | null
  }



  /**
   * Count Type MathProblemSetCountOutputType
   */


  export type MathProblemSetCountOutputType = {
    problems: number
  }

  export type MathProblemSetCountOutputTypeSelect = {
    problems?: boolean
  }

  export type MathProblemSetCountOutputTypeGetPayload<S extends boolean | null | undefined | MathProblemSetCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MathProblemSetCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (MathProblemSetCountOutputTypeArgs)
    ? MathProblemSetCountOutputType 
    : S extends { select: any } & (MathProblemSetCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MathProblemSetCountOutputType ? MathProblemSetCountOutputType[P] : never
  } 
      : MathProblemSetCountOutputType




  // Custom InputTypes

  /**
   * MathProblemSetCountOutputType without action
   */
  export type MathProblemSetCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MathProblemSetCountOutputType
     */
    select?: MathProblemSetCountOutputTypeSelect | null
  }



  /**
   * Count Type GroupPostCountOutputType
   */


  export type GroupPostCountOutputType = {
    messages: number
  }

  export type GroupPostCountOutputTypeSelect = {
    messages?: boolean
  }

  export type GroupPostCountOutputTypeGetPayload<S extends boolean | null | undefined | GroupPostCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? GroupPostCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (GroupPostCountOutputTypeArgs)
    ? GroupPostCountOutputType 
    : S extends { select: any } & (GroupPostCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof GroupPostCountOutputType ? GroupPostCountOutputType[P] : never
  } 
      : GroupPostCountOutputType




  // Custom InputTypes

  /**
   * GroupPostCountOutputType without action
   */
  export type GroupPostCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the GroupPostCountOutputType
     */
    select?: GroupPostCountOutputTypeSelect | null
  }



  /**
   * Count Type ChatSessionCountOutputType
   */


  export type ChatSessionCountOutputType = {
    chatMessages: number
    users: number
  }

  export type ChatSessionCountOutputTypeSelect = {
    chatMessages?: boolean
    users?: boolean
  }

  export type ChatSessionCountOutputTypeGetPayload<S extends boolean | null | undefined | ChatSessionCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ChatSessionCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ChatSessionCountOutputTypeArgs)
    ? ChatSessionCountOutputType 
    : S extends { select: any } & (ChatSessionCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ChatSessionCountOutputType ? ChatSessionCountOutputType[P] : never
  } 
      : ChatSessionCountOutputType




  // Custom InputTypes

  /**
   * ChatSessionCountOutputType without action
   */
  export type ChatSessionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ChatSessionCountOutputType
     */
    select?: ChatSessionCountOutputTypeSelect | null
  }



  /**
   * Count Type ContestCountOutputType
   */


  export type ContestCountOutputType = {
    codingProblems: number
  }

  export type ContestCountOutputTypeSelect = {
    codingProblems?: boolean
  }

  export type ContestCountOutputTypeGetPayload<S extends boolean | null | undefined | ContestCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ContestCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ContestCountOutputTypeArgs)
    ? ContestCountOutputType 
    : S extends { select: any } & (ContestCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ContestCountOutputType ? ContestCountOutputType[P] : never
  } 
      : ContestCountOutputType




  // Custom InputTypes

  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ContestCountOutputType
     */
    select?: ContestCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    username: string | null
    email: string | null
    create_time: Date | null
    admin_type: admin_type | null
    is_disabled: boolean | null
    auth0_id: string | null
  }

  export type UserMaxAggregateOutputType = {
    username: string | null
    email: string | null
    create_time: Date | null
    admin_type: admin_type | null
    is_disabled: boolean | null
    auth0_id: string | null
  }

  export type UserCountAggregateOutputType = {
    username: number
    email: number
    create_time: number
    admin_type: number
    is_disabled: number
    auth0_id: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    username?: true
    email?: true
    create_time?: true
    admin_type?: true
    is_disabled?: true
    auth0_id?: true
  }

  export type UserMaxAggregateInputType = {
    username?: true
    email?: true
    create_time?: true
    admin_type?: true
    is_disabled?: true
    auth0_id?: true
  }

  export type UserCountAggregateInputType = {
    username?: true
    email?: true
    create_time?: true
    admin_type?: true
    is_disabled?: true
    auth0_id?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    username: string
    email: string
    create_time: Date
    admin_type: admin_type
    is_disabled: boolean
    auth0_id: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    username?: boolean
    email?: boolean
    create_time?: boolean
    admin_type?: boolean
    is_disabled?: boolean
    auth0_id?: boolean
    codingProblems?: boolean | User$codingProblemsArgs
    authorMathProblems?: boolean | User$authorMathProblemsArgs
    threads?: boolean | User$threadsArgs
    comments?: boolean | User$commentsArgs
    threadLiked?: boolean | User$threadLikedArgs
    commentLiked?: boolean | User$commentLikedArgs
    UserProfile?: boolean | UserProfileArgs
    mathNotes?: boolean | User$mathNotesArgs
    mathSolutions?: boolean | User$mathSolutionsArgs
    mathProbSetList?: boolean | User$mathProbSetListArgs
    myFriendReqs?: boolean | User$myFriendReqsArgs
    otherFriendReqs?: boolean | User$otherFriendReqsArgs
    createdGroup?: boolean | User$createdGroupArgs
    joinedGroups?: boolean | User$joinedGroupsArgs
    posts?: boolean | User$postsArgs
    chatMessages?: boolean | User$chatMessagesArgs
    chatSessions?: boolean | User$chatSessionsArgs
    groupPostMessages?: boolean | User$groupPostMessagesArgs
    _count?: boolean | UserCountOutputTypeArgs
  }


  export type UserInclude = {
    codingProblems?: boolean | User$codingProblemsArgs
    authorMathProblems?: boolean | User$authorMathProblemsArgs
    threads?: boolean | User$threadsArgs
    comments?: boolean | User$commentsArgs
    threadLiked?: boolean | User$threadLikedArgs
    commentLiked?: boolean | User$commentLikedArgs
    UserProfile?: boolean | UserProfileArgs
    mathNotes?: boolean | User$mathNotesArgs
    mathSolutions?: boolean | User$mathSolutionsArgs
    mathProbSetList?: boolean | User$mathProbSetListArgs
    myFriendReqs?: boolean | User$myFriendReqsArgs
    otherFriendReqs?: boolean | User$otherFriendReqsArgs
    createdGroup?: boolean | User$createdGroupArgs
    joinedGroups?: boolean | User$joinedGroupsArgs
    posts?: boolean | User$postsArgs
    chatMessages?: boolean | User$chatMessagesArgs
    chatSessions?: boolean | User$chatSessionsArgs
    groupPostMessages?: boolean | User$groupPostMessagesArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'codingProblems' ? Array < AuthorCodingProblemGetPayload<S['include'][P]>>  :
        P extends 'authorMathProblems' ? Array < AuthorMathProblemGetPayload<S['include'][P]>>  :
        P extends 'threads' ? Array < ThreadGetPayload<S['include'][P]>>  :
        P extends 'comments' ? Array < CommentGetPayload<S['include'][P]>>  :
        P extends 'threadLiked' ? Array < UserLikeThreadGetPayload<S['include'][P]>>  :
        P extends 'commentLiked' ? Array < UserLikeCommentGetPayload<S['include'][P]>>  :
        P extends 'UserProfile' ? UserProfileGetPayload<S['include'][P]> | null :
        P extends 'mathNotes' ? Array < MathNoteGetPayload<S['include'][P]>>  :
        P extends 'mathSolutions' ? Array < MathSolutionGetPayload<S['include'][P]>>  :
        P extends 'mathProbSetList' ? Array < MathProblemSetGetPayload<S['include'][P]>>  :
        P extends 'myFriendReqs' ? Array < FriendRequestGetPayload<S['include'][P]>>  :
        P extends 'otherFriendReqs' ? Array < FriendRequestGetPayload<S['include'][P]>>  :
        P extends 'createdGroup' ? Array < GroupGetPayload<S['include'][P]>>  :
        P extends 'joinedGroups' ? Array < UserGroupRelGetPayload<S['include'][P]>>  :
        P extends 'posts' ? Array < GroupPostGetPayload<S['include'][P]>>  :
        P extends 'chatMessages' ? Array < ChatMessageGetPayload<S['include'][P]>>  :
        P extends 'chatSessions' ? Array < ChatSessionUserGetPayload<S['include'][P]>>  :
        P extends 'groupPostMessages' ? Array < GroupPostMessageGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'codingProblems' ? Array < AuthorCodingProblemGetPayload<S['select'][P]>>  :
        P extends 'authorMathProblems' ? Array < AuthorMathProblemGetPayload<S['select'][P]>>  :
        P extends 'threads' ? Array < ThreadGetPayload<S['select'][P]>>  :
        P extends 'comments' ? Array < CommentGetPayload<S['select'][P]>>  :
        P extends 'threadLiked' ? Array < UserLikeThreadGetPayload<S['select'][P]>>  :
        P extends 'commentLiked' ? Array < UserLikeCommentGetPayload<S['select'][P]>>  :
        P extends 'UserProfile' ? UserProfileGetPayload<S['select'][P]> | null :
        P extends 'mathNotes' ? Array < MathNoteGetPayload<S['select'][P]>>  :
        P extends 'mathSolutions' ? Array < MathSolutionGetPayload<S['select'][P]>>  :
        P extends 'mathProbSetList' ? Array < MathProblemSetGetPayload<S['select'][P]>>  :
        P extends 'myFriendReqs' ? Array < FriendRequestGetPayload<S['select'][P]>>  :
        P extends 'otherFriendReqs' ? Array < FriendRequestGetPayload<S['select'][P]>>  :
        P extends 'createdGroup' ? Array < GroupGetPayload<S['select'][P]>>  :
        P extends 'joinedGroups' ? Array < UserGroupRelGetPayload<S['select'][P]>>  :
        P extends 'posts' ? Array < GroupPostGetPayload<S['select'][P]>>  :
        P extends 'chatMessages' ? Array < ChatMessageGetPayload<S['select'][P]>>  :
        P extends 'chatSessions' ? Array < ChatSessionUserGetPayload<S['select'][P]>>  :
        P extends 'groupPostMessages' ? Array < GroupPostMessageGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `username`
     * const userWithUsernameOnly = await prisma.user.findMany({ select: { username: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    codingProblems<T extends User$codingProblemsArgs= {}>(args?: Subset<T, User$codingProblemsArgs>): Prisma.PrismaPromise<Array<AuthorCodingProblemGetPayload<T>>| Null>;

    authorMathProblems<T extends User$authorMathProblemsArgs= {}>(args?: Subset<T, User$authorMathProblemsArgs>): Prisma.PrismaPromise<Array<AuthorMathProblemGetPayload<T>>| Null>;

    threads<T extends User$threadsArgs= {}>(args?: Subset<T, User$threadsArgs>): Prisma.PrismaPromise<Array<ThreadGetPayload<T>>| Null>;

    comments<T extends User$commentsArgs= {}>(args?: Subset<T, User$commentsArgs>): Prisma.PrismaPromise<Array<CommentGetPayload<T>>| Null>;

    threadLiked<T extends User$threadLikedArgs= {}>(args?: Subset<T, User$threadLikedArgs>): Prisma.PrismaPromise<Array<UserLikeThreadGetPayload<T>>| Null>;

    commentLiked<T extends User$commentLikedArgs= {}>(args?: Subset<T, User$commentLikedArgs>): Prisma.PrismaPromise<Array<UserLikeCommentGetPayload<T>>| Null>;

    UserProfile<T extends UserProfileArgs= {}>(args?: Subset<T, UserProfileArgs>): Prisma__UserProfileClient<UserProfileGetPayload<T> | Null>;

    mathNotes<T extends User$mathNotesArgs= {}>(args?: Subset<T, User$mathNotesArgs>): Prisma.PrismaPromise<Array<MathNoteGetPayload<T>>| Null>;

    mathSolutions<T extends User$mathSolutionsArgs= {}>(args?: Subset<T, User$mathSolutionsArgs>): Prisma.PrismaPromise<Array<MathSolutionGetPayload<T>>| Null>;

    mathProbSetList<T extends User$mathProbSetListArgs= {}>(args?: Subset<T, User$mathProbSetListArgs>): Prisma.PrismaPromise<Array<MathProblemSetGetPayload<T>>| Null>;

    myFriendReqs<T extends User$myFriendReqsArgs= {}>(args?: Subset<T, User$myFriendReqsArgs>): Prisma.PrismaPromise<Array<FriendRequestGetPayload<T>>| Null>;

    otherFriendReqs<T extends User$otherFriendReqsArgs= {}>(args?: Subset<T, User$otherFriendReqsArgs>): Prisma.PrismaPromise<Array<FriendRequestGetPayload<T>>| Null>;

    createdGroup<T extends User$createdGroupArgs= {}>(args?: Subset<T, User$createdGroupArgs>): Prisma.PrismaPromise<Array<GroupGetPayload<T>>| Null>;

    joinedGroups<T extends User$joinedGroupsArgs= {}>(args?: Subset<T, User$joinedGroupsArgs>): Prisma.PrismaPromise<Array<UserGroupRelGetPayload<T>>| Null>;

    posts<T extends User$postsArgs= {}>(args?: Subset<T, User$postsArgs>): Prisma.PrismaPromise<Array<GroupPostGetPayload<T>>| Null>;

    chatMessages<T extends User$chatMessagesArgs= {}>(args?: Subset<T, User$chatMessagesArgs>): Prisma.PrismaPromise<Array<ChatMessageGetPayload<T>>| Null>;

    chatSessions<T extends User$chatSessionsArgs= {}>(args?: Subset<T, User$chatSessionsArgs>): Prisma.PrismaPromise<Array<ChatSessionUserGetPayload<T>>| Null>;

    groupPostMessages<T extends User$groupPostMessagesArgs= {}>(args?: Subset<T, User$groupPostMessagesArgs>): Prisma.PrismaPromise<Array<GroupPostMessageGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.codingProblems
   */
  export type User$codingProblemsArgs = {
    /**
     * Select specific fields to fetch from the AuthorCodingProblem
     */
    select?: AuthorCodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorCodingProblemInclude | null
    where?: AuthorCodingProblemWhereInput
    orderBy?: Enumerable<AuthorCodingProblemOrderByWithRelationInput>
    cursor?: AuthorCodingProblemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AuthorCodingProblemScalarFieldEnum>
  }


  /**
   * User.authorMathProblems
   */
  export type User$authorMathProblemsArgs = {
    /**
     * Select specific fields to fetch from the AuthorMathProblem
     */
    select?: AuthorMathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorMathProblemInclude | null
    where?: AuthorMathProblemWhereInput
    orderBy?: Enumerable<AuthorMathProblemOrderByWithRelationInput>
    cursor?: AuthorMathProblemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AuthorMathProblemScalarFieldEnum>
  }


  /**
   * User.threads
   */
  export type User$threadsArgs = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadInclude | null
    where?: ThreadWhereInput
    orderBy?: Enumerable<ThreadOrderByWithRelationInput>
    cursor?: ThreadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ThreadScalarFieldEnum>
  }


  /**
   * User.comments
   */
  export type User$commentsArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    where?: CommentWhereInput
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * User.threadLiked
   */
  export type User$threadLikedArgs = {
    /**
     * Select specific fields to fetch from the UserLikeThread
     */
    select?: UserLikeThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLikeThreadInclude | null
    where?: UserLikeThreadWhereInput
    orderBy?: Enumerable<UserLikeThreadOrderByWithRelationInput>
    cursor?: UserLikeThreadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserLikeThreadScalarFieldEnum>
  }


  /**
   * User.commentLiked
   */
  export type User$commentLikedArgs = {
    /**
     * Select specific fields to fetch from the UserLikeComment
     */
    select?: UserLikeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLikeCommentInclude | null
    where?: UserLikeCommentWhereInput
    orderBy?: Enumerable<UserLikeCommentOrderByWithRelationInput>
    cursor?: UserLikeCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserLikeCommentScalarFieldEnum>
  }


  /**
   * User.mathNotes
   */
  export type User$mathNotesArgs = {
    /**
     * Select specific fields to fetch from the MathNote
     */
    select?: MathNoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathNoteInclude | null
    where?: MathNoteWhereInput
    orderBy?: Enumerable<MathNoteOrderByWithRelationInput>
    cursor?: MathNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MathNoteScalarFieldEnum>
  }


  /**
   * User.mathSolutions
   */
  export type User$mathSolutionsArgs = {
    /**
     * Select specific fields to fetch from the MathSolution
     */
    select?: MathSolutionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathSolutionInclude | null
    where?: MathSolutionWhereInput
    orderBy?: Enumerable<MathSolutionOrderByWithRelationInput>
    cursor?: MathSolutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MathSolutionScalarFieldEnum>
  }


  /**
   * User.mathProbSetList
   */
  export type User$mathProbSetListArgs = {
    /**
     * Select specific fields to fetch from the MathProblemSet
     */
    select?: MathProblemSetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemSetInclude | null
    where?: MathProblemSetWhereInput
    orderBy?: Enumerable<MathProblemSetOrderByWithRelationInput>
    cursor?: MathProblemSetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MathProblemSetScalarFieldEnum>
  }


  /**
   * User.myFriendReqs
   */
  export type User$myFriendReqsArgs = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendRequestInclude | null
    where?: FriendRequestWhereInput
    orderBy?: Enumerable<FriendRequestOrderByWithRelationInput>
    cursor?: FriendRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FriendRequestScalarFieldEnum>
  }


  /**
   * User.otherFriendReqs
   */
  export type User$otherFriendReqsArgs = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendRequestInclude | null
    where?: FriendRequestWhereInput
    orderBy?: Enumerable<FriendRequestOrderByWithRelationInput>
    cursor?: FriendRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FriendRequestScalarFieldEnum>
  }


  /**
   * User.createdGroup
   */
  export type User$createdGroupArgs = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude | null
    where?: GroupWhereInput
    orderBy?: Enumerable<GroupOrderByWithRelationInput>
    cursor?: GroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<GroupScalarFieldEnum>
  }


  /**
   * User.joinedGroups
   */
  export type User$joinedGroupsArgs = {
    /**
     * Select specific fields to fetch from the UserGroupRel
     */
    select?: UserGroupRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserGroupRelInclude | null
    where?: UserGroupRelWhereInput
    orderBy?: Enumerable<UserGroupRelOrderByWithRelationInput>
    cursor?: UserGroupRelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserGroupRelScalarFieldEnum>
  }


  /**
   * User.posts
   */
  export type User$postsArgs = {
    /**
     * Select specific fields to fetch from the GroupPost
     */
    select?: GroupPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupPostInclude | null
    where?: GroupPostWhereInput
    orderBy?: Enumerable<GroupPostOrderByWithRelationInput>
    cursor?: GroupPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<GroupPostScalarFieldEnum>
  }


  /**
   * User.chatMessages
   */
  export type User$chatMessagesArgs = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatMessageInclude | null
    where?: ChatMessageWhereInput
    orderBy?: Enumerable<ChatMessageOrderByWithRelationInput>
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ChatMessageScalarFieldEnum>
  }


  /**
   * User.chatSessions
   */
  export type User$chatSessionsArgs = {
    /**
     * Select specific fields to fetch from the ChatSessionUser
     */
    select?: ChatSessionUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatSessionUserInclude | null
    where?: ChatSessionUserWhereInput
    orderBy?: Enumerable<ChatSessionUserOrderByWithRelationInput>
    cursor?: ChatSessionUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ChatSessionUserScalarFieldEnum>
  }


  /**
   * User.groupPostMessages
   */
  export type User$groupPostMessagesArgs = {
    /**
     * Select specific fields to fetch from the GroupPostMessage
     */
    select?: GroupPostMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupPostMessageInclude | null
    where?: GroupPostMessageWhereInput
    orderBy?: Enumerable<GroupPostMessageOrderByWithRelationInput>
    cursor?: GroupPostMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<GroupPostMessageScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
  }



  /**
   * Model UserRating
   */


  export type AggregateUserRating = {
    _count: UserRatingCountAggregateOutputType | null
    _avg: UserRatingAvgAggregateOutputType | null
    _sum: UserRatingSumAggregateOutputType | null
    _min: UserRatingMinAggregateOutputType | null
    _max: UserRatingMaxAggregateOutputType | null
  }

  export type UserRatingAvgAggregateOutputType = {
    rating: number | null
  }

  export type UserRatingSumAggregateOutputType = {
    rating: number | null
  }

  export type UserRatingMinAggregateOutputType = {
    username: string | null
    rating: number | null
  }

  export type UserRatingMaxAggregateOutputType = {
    username: string | null
    rating: number | null
  }

  export type UserRatingCountAggregateOutputType = {
    username: number
    rating: number
    _all: number
  }


  export type UserRatingAvgAggregateInputType = {
    rating?: true
  }

  export type UserRatingSumAggregateInputType = {
    rating?: true
  }

  export type UserRatingMinAggregateInputType = {
    username?: true
    rating?: true
  }

  export type UserRatingMaxAggregateInputType = {
    username?: true
    rating?: true
  }

  export type UserRatingCountAggregateInputType = {
    username?: true
    rating?: true
    _all?: true
  }

  export type UserRatingAggregateArgs = {
    /**
     * Filter which UserRating to aggregate.
     */
    where?: UserRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRatings to fetch.
     */
    orderBy?: Enumerable<UserRatingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRatings
    **/
    _count?: true | UserRatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRatingMaxAggregateInputType
  }

  export type GetUserRatingAggregateType<T extends UserRatingAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRating[P]>
      : GetScalarType<T[P], AggregateUserRating[P]>
  }




  export type UserRatingGroupByArgs = {
    where?: UserRatingWhereInput
    orderBy?: Enumerable<UserRatingOrderByWithAggregationInput>
    by: UserRatingScalarFieldEnum[]
    having?: UserRatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRatingCountAggregateInputType | true
    _avg?: UserRatingAvgAggregateInputType
    _sum?: UserRatingSumAggregateInputType
    _min?: UserRatingMinAggregateInputType
    _max?: UserRatingMaxAggregateInputType
  }


  export type UserRatingGroupByOutputType = {
    username: string
    rating: number
    _count: UserRatingCountAggregateOutputType | null
    _avg: UserRatingAvgAggregateOutputType | null
    _sum: UserRatingSumAggregateOutputType | null
    _min: UserRatingMinAggregateOutputType | null
    _max: UserRatingMaxAggregateOutputType | null
  }

  type GetUserRatingGroupByPayload<T extends UserRatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserRatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRatingGroupByOutputType[P]>
            : GetScalarType<T[P], UserRatingGroupByOutputType[P]>
        }
      >
    >


  export type UserRatingSelect = {
    username?: boolean
    rating?: boolean
  }


  export type UserRatingGetPayload<S extends boolean | null | undefined | UserRatingArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserRating :
    S extends undefined ? never :
    S extends { include: any } & (UserRatingArgs | UserRatingFindManyArgs)
    ? UserRating 
    : S extends { select: any } & (UserRatingArgs | UserRatingFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserRating ? UserRating[P] : never
  } 
      : UserRating


  type UserRatingCountArgs = 
    Omit<UserRatingFindManyArgs, 'select' | 'include'> & {
      select?: UserRatingCountAggregateInputType | true
    }

  export interface UserRatingDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UserRating that matches the filter.
     * @param {UserRatingFindUniqueArgs} args - Arguments to find a UserRating
     * @example
     * // Get one UserRating
     * const userRating = await prisma.userRating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserRatingFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserRatingFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserRating'> extends True ? Prisma__UserRatingClient<UserRatingGetPayload<T>> : Prisma__UserRatingClient<UserRatingGetPayload<T> | null, null>

    /**
     * Find one UserRating that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserRatingFindUniqueOrThrowArgs} args - Arguments to find a UserRating
     * @example
     * // Get one UserRating
     * const userRating = await prisma.userRating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserRatingFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserRatingFindUniqueOrThrowArgs>
    ): Prisma__UserRatingClient<UserRatingGetPayload<T>>

    /**
     * Find the first UserRating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRatingFindFirstArgs} args - Arguments to find a UserRating
     * @example
     * // Get one UserRating
     * const userRating = await prisma.userRating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserRatingFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserRatingFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserRating'> extends True ? Prisma__UserRatingClient<UserRatingGetPayload<T>> : Prisma__UserRatingClient<UserRatingGetPayload<T> | null, null>

    /**
     * Find the first UserRating that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRatingFindFirstOrThrowArgs} args - Arguments to find a UserRating
     * @example
     * // Get one UserRating
     * const userRating = await prisma.userRating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserRatingFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserRatingFindFirstOrThrowArgs>
    ): Prisma__UserRatingClient<UserRatingGetPayload<T>>

    /**
     * Find zero or more UserRatings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRatingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRatings
     * const userRatings = await prisma.userRating.findMany()
     * 
     * // Get first 10 UserRatings
     * const userRatings = await prisma.userRating.findMany({ take: 10 })
     * 
     * // Only select the `username`
     * const userRatingWithUsernameOnly = await prisma.userRating.findMany({ select: { username: true } })
     * 
    **/
    findMany<T extends UserRatingFindManyArgs>(
      args?: SelectSubset<T, UserRatingFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserRatingGetPayload<T>>>

    /**
     * Create a UserRating.
     * @param {UserRatingCreateArgs} args - Arguments to create a UserRating.
     * @example
     * // Create one UserRating
     * const UserRating = await prisma.userRating.create({
     *   data: {
     *     // ... data to create a UserRating
     *   }
     * })
     * 
    **/
    create<T extends UserRatingCreateArgs>(
      args: SelectSubset<T, UserRatingCreateArgs>
    ): Prisma__UserRatingClient<UserRatingGetPayload<T>>

    /**
     * Create many UserRatings.
     *     @param {UserRatingCreateManyArgs} args - Arguments to create many UserRatings.
     *     @example
     *     // Create many UserRatings
     *     const userRating = await prisma.userRating.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserRatingCreateManyArgs>(
      args?: SelectSubset<T, UserRatingCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserRating.
     * @param {UserRatingDeleteArgs} args - Arguments to delete one UserRating.
     * @example
     * // Delete one UserRating
     * const UserRating = await prisma.userRating.delete({
     *   where: {
     *     // ... filter to delete one UserRating
     *   }
     * })
     * 
    **/
    delete<T extends UserRatingDeleteArgs>(
      args: SelectSubset<T, UserRatingDeleteArgs>
    ): Prisma__UserRatingClient<UserRatingGetPayload<T>>

    /**
     * Update one UserRating.
     * @param {UserRatingUpdateArgs} args - Arguments to update one UserRating.
     * @example
     * // Update one UserRating
     * const userRating = await prisma.userRating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserRatingUpdateArgs>(
      args: SelectSubset<T, UserRatingUpdateArgs>
    ): Prisma__UserRatingClient<UserRatingGetPayload<T>>

    /**
     * Delete zero or more UserRatings.
     * @param {UserRatingDeleteManyArgs} args - Arguments to filter UserRatings to delete.
     * @example
     * // Delete a few UserRatings
     * const { count } = await prisma.userRating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserRatingDeleteManyArgs>(
      args?: SelectSubset<T, UserRatingDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRatings
     * const userRating = await prisma.userRating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserRatingUpdateManyArgs>(
      args: SelectSubset<T, UserRatingUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRating.
     * @param {UserRatingUpsertArgs} args - Arguments to update or create a UserRating.
     * @example
     * // Update or create a UserRating
     * const userRating = await prisma.userRating.upsert({
     *   create: {
     *     // ... data to create a UserRating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRating we want to update
     *   }
     * })
    **/
    upsert<T extends UserRatingUpsertArgs>(
      args: SelectSubset<T, UserRatingUpsertArgs>
    ): Prisma__UserRatingClient<UserRatingGetPayload<T>>

    /**
     * Count the number of UserRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRatingCountArgs} args - Arguments to filter UserRatings to count.
     * @example
     * // Count the number of UserRatings
     * const count = await prisma.userRating.count({
     *   where: {
     *     // ... the filter for the UserRatings we want to count
     *   }
     * })
    **/
    count<T extends UserRatingCountArgs>(
      args?: Subset<T, UserRatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRatingAggregateArgs>(args: Subset<T, UserRatingAggregateArgs>): Prisma.PrismaPromise<GetUserRatingAggregateType<T>>

    /**
     * Group by UserRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRatingGroupByArgs['orderBy'] }
        : { orderBy?: UserRatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserRatingClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserRating base type for findUnique actions
   */
  export type UserRatingFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect | null
    /**
     * Filter, which UserRating to fetch.
     */
    where: UserRatingWhereUniqueInput
  }

  /**
   * UserRating findUnique
   */
  export interface UserRatingFindUniqueArgs extends UserRatingFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserRating findUniqueOrThrow
   */
  export type UserRatingFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect | null
    /**
     * Filter, which UserRating to fetch.
     */
    where: UserRatingWhereUniqueInput
  }


  /**
   * UserRating base type for findFirst actions
   */
  export type UserRatingFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect | null
    /**
     * Filter, which UserRating to fetch.
     */
    where?: UserRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRatings to fetch.
     */
    orderBy?: Enumerable<UserRatingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRatings.
     */
    cursor?: UserRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRatings.
     */
    distinct?: Enumerable<UserRatingScalarFieldEnum>
  }

  /**
   * UserRating findFirst
   */
  export interface UserRatingFindFirstArgs extends UserRatingFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserRating findFirstOrThrow
   */
  export type UserRatingFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect | null
    /**
     * Filter, which UserRating to fetch.
     */
    where?: UserRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRatings to fetch.
     */
    orderBy?: Enumerable<UserRatingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRatings.
     */
    cursor?: UserRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRatings.
     */
    distinct?: Enumerable<UserRatingScalarFieldEnum>
  }


  /**
   * UserRating findMany
   */
  export type UserRatingFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect | null
    /**
     * Filter, which UserRatings to fetch.
     */
    where?: UserRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRatings to fetch.
     */
    orderBy?: Enumerable<UserRatingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRatings.
     */
    cursor?: UserRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRatings.
     */
    skip?: number
    distinct?: Enumerable<UserRatingScalarFieldEnum>
  }


  /**
   * UserRating create
   */
  export type UserRatingCreateArgs = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect | null
    /**
     * The data needed to create a UserRating.
     */
    data: XOR<UserRatingCreateInput, UserRatingUncheckedCreateInput>
  }


  /**
   * UserRating createMany
   */
  export type UserRatingCreateManyArgs = {
    /**
     * The data used to create many UserRatings.
     */
    data: Enumerable<UserRatingCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserRating update
   */
  export type UserRatingUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect | null
    /**
     * The data needed to update a UserRating.
     */
    data: XOR<UserRatingUpdateInput, UserRatingUncheckedUpdateInput>
    /**
     * Choose, which UserRating to update.
     */
    where: UserRatingWhereUniqueInput
  }


  /**
   * UserRating updateMany
   */
  export type UserRatingUpdateManyArgs = {
    /**
     * The data used to update UserRatings.
     */
    data: XOR<UserRatingUpdateManyMutationInput, UserRatingUncheckedUpdateManyInput>
    /**
     * Filter which UserRatings to update
     */
    where?: UserRatingWhereInput
  }


  /**
   * UserRating upsert
   */
  export type UserRatingUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect | null
    /**
     * The filter to search for the UserRating to update in case it exists.
     */
    where: UserRatingWhereUniqueInput
    /**
     * In case the UserRating found by the `where` argument doesn't exist, create a new UserRating with this data.
     */
    create: XOR<UserRatingCreateInput, UserRatingUncheckedCreateInput>
    /**
     * In case the UserRating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRatingUpdateInput, UserRatingUncheckedUpdateInput>
  }


  /**
   * UserRating delete
   */
  export type UserRatingDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect | null
    /**
     * Filter which UserRating to delete.
     */
    where: UserRatingWhereUniqueInput
  }


  /**
   * UserRating deleteMany
   */
  export type UserRatingDeleteManyArgs = {
    /**
     * Filter which UserRatings to delete
     */
    where?: UserRatingWhereInput
  }


  /**
   * UserRating without action
   */
  export type UserRatingArgs = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect | null
  }



  /**
   * Model FriendShip
   */


  export type AggregateFriendShip = {
    _count: FriendShipCountAggregateOutputType | null
    _min: FriendShipMinAggregateOutputType | null
    _max: FriendShipMaxAggregateOutputType | null
  }

  export type FriendShipMinAggregateOutputType = {
    id: string | null
    username1: string | null
    username2: string | null
    establishedAt: Date | null
  }

  export type FriendShipMaxAggregateOutputType = {
    id: string | null
    username1: string | null
    username2: string | null
    establishedAt: Date | null
  }

  export type FriendShipCountAggregateOutputType = {
    id: number
    username1: number
    username2: number
    establishedAt: number
    _all: number
  }


  export type FriendShipMinAggregateInputType = {
    id?: true
    username1?: true
    username2?: true
    establishedAt?: true
  }

  export type FriendShipMaxAggregateInputType = {
    id?: true
    username1?: true
    username2?: true
    establishedAt?: true
  }

  export type FriendShipCountAggregateInputType = {
    id?: true
    username1?: true
    username2?: true
    establishedAt?: true
    _all?: true
  }

  export type FriendShipAggregateArgs = {
    /**
     * Filter which FriendShip to aggregate.
     */
    where?: FriendShipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FriendShips to fetch.
     */
    orderBy?: Enumerable<FriendShipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FriendShipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FriendShips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FriendShips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FriendShips
    **/
    _count?: true | FriendShipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FriendShipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FriendShipMaxAggregateInputType
  }

  export type GetFriendShipAggregateType<T extends FriendShipAggregateArgs> = {
        [P in keyof T & keyof AggregateFriendShip]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFriendShip[P]>
      : GetScalarType<T[P], AggregateFriendShip[P]>
  }




  export type FriendShipGroupByArgs = {
    where?: FriendShipWhereInput
    orderBy?: Enumerable<FriendShipOrderByWithAggregationInput>
    by: FriendShipScalarFieldEnum[]
    having?: FriendShipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FriendShipCountAggregateInputType | true
    _min?: FriendShipMinAggregateInputType
    _max?: FriendShipMaxAggregateInputType
  }


  export type FriendShipGroupByOutputType = {
    id: string
    username1: string
    username2: string
    establishedAt: Date
    _count: FriendShipCountAggregateOutputType | null
    _min: FriendShipMinAggregateOutputType | null
    _max: FriendShipMaxAggregateOutputType | null
  }

  type GetFriendShipGroupByPayload<T extends FriendShipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FriendShipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FriendShipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FriendShipGroupByOutputType[P]>
            : GetScalarType<T[P], FriendShipGroupByOutputType[P]>
        }
      >
    >


  export type FriendShipSelect = {
    id?: boolean
    username1?: boolean
    username2?: boolean
    establishedAt?: boolean
  }


  export type FriendShipGetPayload<S extends boolean | null | undefined | FriendShipArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FriendShip :
    S extends undefined ? never :
    S extends { include: any } & (FriendShipArgs | FriendShipFindManyArgs)
    ? FriendShip 
    : S extends { select: any } & (FriendShipArgs | FriendShipFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FriendShip ? FriendShip[P] : never
  } 
      : FriendShip


  type FriendShipCountArgs = 
    Omit<FriendShipFindManyArgs, 'select' | 'include'> & {
      select?: FriendShipCountAggregateInputType | true
    }

  export interface FriendShipDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FriendShip that matches the filter.
     * @param {FriendShipFindUniqueArgs} args - Arguments to find a FriendShip
     * @example
     * // Get one FriendShip
     * const friendShip = await prisma.friendShip.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FriendShipFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FriendShipFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FriendShip'> extends True ? Prisma__FriendShipClient<FriendShipGetPayload<T>> : Prisma__FriendShipClient<FriendShipGetPayload<T> | null, null>

    /**
     * Find one FriendShip that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FriendShipFindUniqueOrThrowArgs} args - Arguments to find a FriendShip
     * @example
     * // Get one FriendShip
     * const friendShip = await prisma.friendShip.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FriendShipFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FriendShipFindUniqueOrThrowArgs>
    ): Prisma__FriendShipClient<FriendShipGetPayload<T>>

    /**
     * Find the first FriendShip that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendShipFindFirstArgs} args - Arguments to find a FriendShip
     * @example
     * // Get one FriendShip
     * const friendShip = await prisma.friendShip.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FriendShipFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FriendShipFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FriendShip'> extends True ? Prisma__FriendShipClient<FriendShipGetPayload<T>> : Prisma__FriendShipClient<FriendShipGetPayload<T> | null, null>

    /**
     * Find the first FriendShip that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendShipFindFirstOrThrowArgs} args - Arguments to find a FriendShip
     * @example
     * // Get one FriendShip
     * const friendShip = await prisma.friendShip.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FriendShipFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FriendShipFindFirstOrThrowArgs>
    ): Prisma__FriendShipClient<FriendShipGetPayload<T>>

    /**
     * Find zero or more FriendShips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendShipFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FriendShips
     * const friendShips = await prisma.friendShip.findMany()
     * 
     * // Get first 10 FriendShips
     * const friendShips = await prisma.friendShip.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const friendShipWithIdOnly = await prisma.friendShip.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FriendShipFindManyArgs>(
      args?: SelectSubset<T, FriendShipFindManyArgs>
    ): Prisma.PrismaPromise<Array<FriendShipGetPayload<T>>>

    /**
     * Create a FriendShip.
     * @param {FriendShipCreateArgs} args - Arguments to create a FriendShip.
     * @example
     * // Create one FriendShip
     * const FriendShip = await prisma.friendShip.create({
     *   data: {
     *     // ... data to create a FriendShip
     *   }
     * })
     * 
    **/
    create<T extends FriendShipCreateArgs>(
      args: SelectSubset<T, FriendShipCreateArgs>
    ): Prisma__FriendShipClient<FriendShipGetPayload<T>>

    /**
     * Create many FriendShips.
     *     @param {FriendShipCreateManyArgs} args - Arguments to create many FriendShips.
     *     @example
     *     // Create many FriendShips
     *     const friendShip = await prisma.friendShip.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FriendShipCreateManyArgs>(
      args?: SelectSubset<T, FriendShipCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FriendShip.
     * @param {FriendShipDeleteArgs} args - Arguments to delete one FriendShip.
     * @example
     * // Delete one FriendShip
     * const FriendShip = await prisma.friendShip.delete({
     *   where: {
     *     // ... filter to delete one FriendShip
     *   }
     * })
     * 
    **/
    delete<T extends FriendShipDeleteArgs>(
      args: SelectSubset<T, FriendShipDeleteArgs>
    ): Prisma__FriendShipClient<FriendShipGetPayload<T>>

    /**
     * Update one FriendShip.
     * @param {FriendShipUpdateArgs} args - Arguments to update one FriendShip.
     * @example
     * // Update one FriendShip
     * const friendShip = await prisma.friendShip.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FriendShipUpdateArgs>(
      args: SelectSubset<T, FriendShipUpdateArgs>
    ): Prisma__FriendShipClient<FriendShipGetPayload<T>>

    /**
     * Delete zero or more FriendShips.
     * @param {FriendShipDeleteManyArgs} args - Arguments to filter FriendShips to delete.
     * @example
     * // Delete a few FriendShips
     * const { count } = await prisma.friendShip.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FriendShipDeleteManyArgs>(
      args?: SelectSubset<T, FriendShipDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FriendShips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendShipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FriendShips
     * const friendShip = await prisma.friendShip.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FriendShipUpdateManyArgs>(
      args: SelectSubset<T, FriendShipUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FriendShip.
     * @param {FriendShipUpsertArgs} args - Arguments to update or create a FriendShip.
     * @example
     * // Update or create a FriendShip
     * const friendShip = await prisma.friendShip.upsert({
     *   create: {
     *     // ... data to create a FriendShip
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FriendShip we want to update
     *   }
     * })
    **/
    upsert<T extends FriendShipUpsertArgs>(
      args: SelectSubset<T, FriendShipUpsertArgs>
    ): Prisma__FriendShipClient<FriendShipGetPayload<T>>

    /**
     * Count the number of FriendShips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendShipCountArgs} args - Arguments to filter FriendShips to count.
     * @example
     * // Count the number of FriendShips
     * const count = await prisma.friendShip.count({
     *   where: {
     *     // ... the filter for the FriendShips we want to count
     *   }
     * })
    **/
    count<T extends FriendShipCountArgs>(
      args?: Subset<T, FriendShipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FriendShipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FriendShip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendShipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FriendShipAggregateArgs>(args: Subset<T, FriendShipAggregateArgs>): Prisma.PrismaPromise<GetFriendShipAggregateType<T>>

    /**
     * Group by FriendShip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendShipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FriendShipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FriendShipGroupByArgs['orderBy'] }
        : { orderBy?: FriendShipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FriendShipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFriendShipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FriendShip.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FriendShipClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FriendShip base type for findUnique actions
   */
  export type FriendShipFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FriendShip
     */
    select?: FriendShipSelect | null
    /**
     * Filter, which FriendShip to fetch.
     */
    where: FriendShipWhereUniqueInput
  }

  /**
   * FriendShip findUnique
   */
  export interface FriendShipFindUniqueArgs extends FriendShipFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FriendShip findUniqueOrThrow
   */
  export type FriendShipFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FriendShip
     */
    select?: FriendShipSelect | null
    /**
     * Filter, which FriendShip to fetch.
     */
    where: FriendShipWhereUniqueInput
  }


  /**
   * FriendShip base type for findFirst actions
   */
  export type FriendShipFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FriendShip
     */
    select?: FriendShipSelect | null
    /**
     * Filter, which FriendShip to fetch.
     */
    where?: FriendShipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FriendShips to fetch.
     */
    orderBy?: Enumerable<FriendShipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FriendShips.
     */
    cursor?: FriendShipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FriendShips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FriendShips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FriendShips.
     */
    distinct?: Enumerable<FriendShipScalarFieldEnum>
  }

  /**
   * FriendShip findFirst
   */
  export interface FriendShipFindFirstArgs extends FriendShipFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FriendShip findFirstOrThrow
   */
  export type FriendShipFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FriendShip
     */
    select?: FriendShipSelect | null
    /**
     * Filter, which FriendShip to fetch.
     */
    where?: FriendShipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FriendShips to fetch.
     */
    orderBy?: Enumerable<FriendShipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FriendShips.
     */
    cursor?: FriendShipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FriendShips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FriendShips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FriendShips.
     */
    distinct?: Enumerable<FriendShipScalarFieldEnum>
  }


  /**
   * FriendShip findMany
   */
  export type FriendShipFindManyArgs = {
    /**
     * Select specific fields to fetch from the FriendShip
     */
    select?: FriendShipSelect | null
    /**
     * Filter, which FriendShips to fetch.
     */
    where?: FriendShipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FriendShips to fetch.
     */
    orderBy?: Enumerable<FriendShipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FriendShips.
     */
    cursor?: FriendShipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FriendShips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FriendShips.
     */
    skip?: number
    distinct?: Enumerable<FriendShipScalarFieldEnum>
  }


  /**
   * FriendShip create
   */
  export type FriendShipCreateArgs = {
    /**
     * Select specific fields to fetch from the FriendShip
     */
    select?: FriendShipSelect | null
    /**
     * The data needed to create a FriendShip.
     */
    data: XOR<FriendShipCreateInput, FriendShipUncheckedCreateInput>
  }


  /**
   * FriendShip createMany
   */
  export type FriendShipCreateManyArgs = {
    /**
     * The data used to create many FriendShips.
     */
    data: Enumerable<FriendShipCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FriendShip update
   */
  export type FriendShipUpdateArgs = {
    /**
     * Select specific fields to fetch from the FriendShip
     */
    select?: FriendShipSelect | null
    /**
     * The data needed to update a FriendShip.
     */
    data: XOR<FriendShipUpdateInput, FriendShipUncheckedUpdateInput>
    /**
     * Choose, which FriendShip to update.
     */
    where: FriendShipWhereUniqueInput
  }


  /**
   * FriendShip updateMany
   */
  export type FriendShipUpdateManyArgs = {
    /**
     * The data used to update FriendShips.
     */
    data: XOR<FriendShipUpdateManyMutationInput, FriendShipUncheckedUpdateManyInput>
    /**
     * Filter which FriendShips to update
     */
    where?: FriendShipWhereInput
  }


  /**
   * FriendShip upsert
   */
  export type FriendShipUpsertArgs = {
    /**
     * Select specific fields to fetch from the FriendShip
     */
    select?: FriendShipSelect | null
    /**
     * The filter to search for the FriendShip to update in case it exists.
     */
    where: FriendShipWhereUniqueInput
    /**
     * In case the FriendShip found by the `where` argument doesn't exist, create a new FriendShip with this data.
     */
    create: XOR<FriendShipCreateInput, FriendShipUncheckedCreateInput>
    /**
     * In case the FriendShip was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FriendShipUpdateInput, FriendShipUncheckedUpdateInput>
  }


  /**
   * FriendShip delete
   */
  export type FriendShipDeleteArgs = {
    /**
     * Select specific fields to fetch from the FriendShip
     */
    select?: FriendShipSelect | null
    /**
     * Filter which FriendShip to delete.
     */
    where: FriendShipWhereUniqueInput
  }


  /**
   * FriendShip deleteMany
   */
  export type FriendShipDeleteManyArgs = {
    /**
     * Filter which FriendShips to delete
     */
    where?: FriendShipWhereInput
  }


  /**
   * FriendShip without action
   */
  export type FriendShipArgs = {
    /**
     * Select specific fields to fetch from the FriendShip
     */
    select?: FriendShipSelect | null
  }



  /**
   * Model FriendRequest
   */


  export type AggregateFriendRequest = {
    _count: FriendRequestCountAggregateOutputType | null
    _min: FriendRequestMinAggregateOutputType | null
    _max: FriendRequestMaxAggregateOutputType | null
  }

  export type FriendRequestMinAggregateOutputType = {
    id: string | null
    senderId: string | null
    recieverId: string | null
    disable: boolean | null
  }

  export type FriendRequestMaxAggregateOutputType = {
    id: string | null
    senderId: string | null
    recieverId: string | null
    disable: boolean | null
  }

  export type FriendRequestCountAggregateOutputType = {
    id: number
    senderId: number
    recieverId: number
    disable: number
    _all: number
  }


  export type FriendRequestMinAggregateInputType = {
    id?: true
    senderId?: true
    recieverId?: true
    disable?: true
  }

  export type FriendRequestMaxAggregateInputType = {
    id?: true
    senderId?: true
    recieverId?: true
    disable?: true
  }

  export type FriendRequestCountAggregateInputType = {
    id?: true
    senderId?: true
    recieverId?: true
    disable?: true
    _all?: true
  }

  export type FriendRequestAggregateArgs = {
    /**
     * Filter which FriendRequest to aggregate.
     */
    where?: FriendRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FriendRequests to fetch.
     */
    orderBy?: Enumerable<FriendRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FriendRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FriendRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FriendRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FriendRequests
    **/
    _count?: true | FriendRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FriendRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FriendRequestMaxAggregateInputType
  }

  export type GetFriendRequestAggregateType<T extends FriendRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateFriendRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFriendRequest[P]>
      : GetScalarType<T[P], AggregateFriendRequest[P]>
  }




  export type FriendRequestGroupByArgs = {
    where?: FriendRequestWhereInput
    orderBy?: Enumerable<FriendRequestOrderByWithAggregationInput>
    by: FriendRequestScalarFieldEnum[]
    having?: FriendRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FriendRequestCountAggregateInputType | true
    _min?: FriendRequestMinAggregateInputType
    _max?: FriendRequestMaxAggregateInputType
  }


  export type FriendRequestGroupByOutputType = {
    id: string
    senderId: string
    recieverId: string
    disable: boolean
    _count: FriendRequestCountAggregateOutputType | null
    _min: FriendRequestMinAggregateOutputType | null
    _max: FriendRequestMaxAggregateOutputType | null
  }

  type GetFriendRequestGroupByPayload<T extends FriendRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FriendRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FriendRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FriendRequestGroupByOutputType[P]>
            : GetScalarType<T[P], FriendRequestGroupByOutputType[P]>
        }
      >
    >


  export type FriendRequestSelect = {
    id?: boolean
    senderId?: boolean
    recieverId?: boolean
    disable?: boolean
    sender?: boolean | UserArgs
    reciever?: boolean | UserArgs
  }


  export type FriendRequestInclude = {
    sender?: boolean | UserArgs
    reciever?: boolean | UserArgs
  }

  export type FriendRequestGetPayload<S extends boolean | null | undefined | FriendRequestArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FriendRequest :
    S extends undefined ? never :
    S extends { include: any } & (FriendRequestArgs | FriendRequestFindManyArgs)
    ? FriendRequest  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'sender' ? UserGetPayload<S['include'][P]> :
        P extends 'reciever' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FriendRequestArgs | FriendRequestFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'sender' ? UserGetPayload<S['select'][P]> :
        P extends 'reciever' ? UserGetPayload<S['select'][P]> :  P extends keyof FriendRequest ? FriendRequest[P] : never
  } 
      : FriendRequest


  type FriendRequestCountArgs = 
    Omit<FriendRequestFindManyArgs, 'select' | 'include'> & {
      select?: FriendRequestCountAggregateInputType | true
    }

  export interface FriendRequestDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FriendRequest that matches the filter.
     * @param {FriendRequestFindUniqueArgs} args - Arguments to find a FriendRequest
     * @example
     * // Get one FriendRequest
     * const friendRequest = await prisma.friendRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FriendRequestFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FriendRequestFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FriendRequest'> extends True ? Prisma__FriendRequestClient<FriendRequestGetPayload<T>> : Prisma__FriendRequestClient<FriendRequestGetPayload<T> | null, null>

    /**
     * Find one FriendRequest that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FriendRequestFindUniqueOrThrowArgs} args - Arguments to find a FriendRequest
     * @example
     * // Get one FriendRequest
     * const friendRequest = await prisma.friendRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FriendRequestFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FriendRequestFindUniqueOrThrowArgs>
    ): Prisma__FriendRequestClient<FriendRequestGetPayload<T>>

    /**
     * Find the first FriendRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendRequestFindFirstArgs} args - Arguments to find a FriendRequest
     * @example
     * // Get one FriendRequest
     * const friendRequest = await prisma.friendRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FriendRequestFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FriendRequestFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FriendRequest'> extends True ? Prisma__FriendRequestClient<FriendRequestGetPayload<T>> : Prisma__FriendRequestClient<FriendRequestGetPayload<T> | null, null>

    /**
     * Find the first FriendRequest that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendRequestFindFirstOrThrowArgs} args - Arguments to find a FriendRequest
     * @example
     * // Get one FriendRequest
     * const friendRequest = await prisma.friendRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FriendRequestFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FriendRequestFindFirstOrThrowArgs>
    ): Prisma__FriendRequestClient<FriendRequestGetPayload<T>>

    /**
     * Find zero or more FriendRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendRequestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FriendRequests
     * const friendRequests = await prisma.friendRequest.findMany()
     * 
     * // Get first 10 FriendRequests
     * const friendRequests = await prisma.friendRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const friendRequestWithIdOnly = await prisma.friendRequest.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FriendRequestFindManyArgs>(
      args?: SelectSubset<T, FriendRequestFindManyArgs>
    ): Prisma.PrismaPromise<Array<FriendRequestGetPayload<T>>>

    /**
     * Create a FriendRequest.
     * @param {FriendRequestCreateArgs} args - Arguments to create a FriendRequest.
     * @example
     * // Create one FriendRequest
     * const FriendRequest = await prisma.friendRequest.create({
     *   data: {
     *     // ... data to create a FriendRequest
     *   }
     * })
     * 
    **/
    create<T extends FriendRequestCreateArgs>(
      args: SelectSubset<T, FriendRequestCreateArgs>
    ): Prisma__FriendRequestClient<FriendRequestGetPayload<T>>

    /**
     * Create many FriendRequests.
     *     @param {FriendRequestCreateManyArgs} args - Arguments to create many FriendRequests.
     *     @example
     *     // Create many FriendRequests
     *     const friendRequest = await prisma.friendRequest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FriendRequestCreateManyArgs>(
      args?: SelectSubset<T, FriendRequestCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FriendRequest.
     * @param {FriendRequestDeleteArgs} args - Arguments to delete one FriendRequest.
     * @example
     * // Delete one FriendRequest
     * const FriendRequest = await prisma.friendRequest.delete({
     *   where: {
     *     // ... filter to delete one FriendRequest
     *   }
     * })
     * 
    **/
    delete<T extends FriendRequestDeleteArgs>(
      args: SelectSubset<T, FriendRequestDeleteArgs>
    ): Prisma__FriendRequestClient<FriendRequestGetPayload<T>>

    /**
     * Update one FriendRequest.
     * @param {FriendRequestUpdateArgs} args - Arguments to update one FriendRequest.
     * @example
     * // Update one FriendRequest
     * const friendRequest = await prisma.friendRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FriendRequestUpdateArgs>(
      args: SelectSubset<T, FriendRequestUpdateArgs>
    ): Prisma__FriendRequestClient<FriendRequestGetPayload<T>>

    /**
     * Delete zero or more FriendRequests.
     * @param {FriendRequestDeleteManyArgs} args - Arguments to filter FriendRequests to delete.
     * @example
     * // Delete a few FriendRequests
     * const { count } = await prisma.friendRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FriendRequestDeleteManyArgs>(
      args?: SelectSubset<T, FriendRequestDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FriendRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FriendRequests
     * const friendRequest = await prisma.friendRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FriendRequestUpdateManyArgs>(
      args: SelectSubset<T, FriendRequestUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FriendRequest.
     * @param {FriendRequestUpsertArgs} args - Arguments to update or create a FriendRequest.
     * @example
     * // Update or create a FriendRequest
     * const friendRequest = await prisma.friendRequest.upsert({
     *   create: {
     *     // ... data to create a FriendRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FriendRequest we want to update
     *   }
     * })
    **/
    upsert<T extends FriendRequestUpsertArgs>(
      args: SelectSubset<T, FriendRequestUpsertArgs>
    ): Prisma__FriendRequestClient<FriendRequestGetPayload<T>>

    /**
     * Count the number of FriendRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendRequestCountArgs} args - Arguments to filter FriendRequests to count.
     * @example
     * // Count the number of FriendRequests
     * const count = await prisma.friendRequest.count({
     *   where: {
     *     // ... the filter for the FriendRequests we want to count
     *   }
     * })
    **/
    count<T extends FriendRequestCountArgs>(
      args?: Subset<T, FriendRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FriendRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FriendRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FriendRequestAggregateArgs>(args: Subset<T, FriendRequestAggregateArgs>): Prisma.PrismaPromise<GetFriendRequestAggregateType<T>>

    /**
     * Group by FriendRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FriendRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FriendRequestGroupByArgs['orderBy'] }
        : { orderBy?: FriendRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FriendRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFriendRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FriendRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FriendRequestClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    sender<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    reciever<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FriendRequest base type for findUnique actions
   */
  export type FriendRequestFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendRequestInclude | null
    /**
     * Filter, which FriendRequest to fetch.
     */
    where: FriendRequestWhereUniqueInput
  }

  /**
   * FriendRequest findUnique
   */
  export interface FriendRequestFindUniqueArgs extends FriendRequestFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FriendRequest findUniqueOrThrow
   */
  export type FriendRequestFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendRequestInclude | null
    /**
     * Filter, which FriendRequest to fetch.
     */
    where: FriendRequestWhereUniqueInput
  }


  /**
   * FriendRequest base type for findFirst actions
   */
  export type FriendRequestFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendRequestInclude | null
    /**
     * Filter, which FriendRequest to fetch.
     */
    where?: FriendRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FriendRequests to fetch.
     */
    orderBy?: Enumerable<FriendRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FriendRequests.
     */
    cursor?: FriendRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FriendRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FriendRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FriendRequests.
     */
    distinct?: Enumerable<FriendRequestScalarFieldEnum>
  }

  /**
   * FriendRequest findFirst
   */
  export interface FriendRequestFindFirstArgs extends FriendRequestFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FriendRequest findFirstOrThrow
   */
  export type FriendRequestFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendRequestInclude | null
    /**
     * Filter, which FriendRequest to fetch.
     */
    where?: FriendRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FriendRequests to fetch.
     */
    orderBy?: Enumerable<FriendRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FriendRequests.
     */
    cursor?: FriendRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FriendRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FriendRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FriendRequests.
     */
    distinct?: Enumerable<FriendRequestScalarFieldEnum>
  }


  /**
   * FriendRequest findMany
   */
  export type FriendRequestFindManyArgs = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendRequestInclude | null
    /**
     * Filter, which FriendRequests to fetch.
     */
    where?: FriendRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FriendRequests to fetch.
     */
    orderBy?: Enumerable<FriendRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FriendRequests.
     */
    cursor?: FriendRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FriendRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FriendRequests.
     */
    skip?: number
    distinct?: Enumerable<FriendRequestScalarFieldEnum>
  }


  /**
   * FriendRequest create
   */
  export type FriendRequestCreateArgs = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendRequestInclude | null
    /**
     * The data needed to create a FriendRequest.
     */
    data: XOR<FriendRequestCreateInput, FriendRequestUncheckedCreateInput>
  }


  /**
   * FriendRequest createMany
   */
  export type FriendRequestCreateManyArgs = {
    /**
     * The data used to create many FriendRequests.
     */
    data: Enumerable<FriendRequestCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FriendRequest update
   */
  export type FriendRequestUpdateArgs = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendRequestInclude | null
    /**
     * The data needed to update a FriendRequest.
     */
    data: XOR<FriendRequestUpdateInput, FriendRequestUncheckedUpdateInput>
    /**
     * Choose, which FriendRequest to update.
     */
    where: FriendRequestWhereUniqueInput
  }


  /**
   * FriendRequest updateMany
   */
  export type FriendRequestUpdateManyArgs = {
    /**
     * The data used to update FriendRequests.
     */
    data: XOR<FriendRequestUpdateManyMutationInput, FriendRequestUncheckedUpdateManyInput>
    /**
     * Filter which FriendRequests to update
     */
    where?: FriendRequestWhereInput
  }


  /**
   * FriendRequest upsert
   */
  export type FriendRequestUpsertArgs = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendRequestInclude | null
    /**
     * The filter to search for the FriendRequest to update in case it exists.
     */
    where: FriendRequestWhereUniqueInput
    /**
     * In case the FriendRequest found by the `where` argument doesn't exist, create a new FriendRequest with this data.
     */
    create: XOR<FriendRequestCreateInput, FriendRequestUncheckedCreateInput>
    /**
     * In case the FriendRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FriendRequestUpdateInput, FriendRequestUncheckedUpdateInput>
  }


  /**
   * FriendRequest delete
   */
  export type FriendRequestDeleteArgs = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendRequestInclude | null
    /**
     * Filter which FriendRequest to delete.
     */
    where: FriendRequestWhereUniqueInput
  }


  /**
   * FriendRequest deleteMany
   */
  export type FriendRequestDeleteManyArgs = {
    /**
     * Filter which FriendRequests to delete
     */
    where?: FriendRequestWhereInput
  }


  /**
   * FriendRequest without action
   */
  export type FriendRequestArgs = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FriendRequestInclude | null
  }



  /**
   * Model SharePTP
   */


  export type AggregateSharePTP = {
    _count: SharePTPCountAggregateOutputType | null
    _min: SharePTPMinAggregateOutputType | null
    _max: SharePTPMaxAggregateOutputType | null
  }

  export type SharePTPMinAggregateOutputType = {
    id: string | null
    resourceId: string | null
    resourceType: string | null
    senderId: string | null
    receiverId: string | null
    resourceLink: string | null
    look: boolean | null
    createdAt: Date | null
  }

  export type SharePTPMaxAggregateOutputType = {
    id: string | null
    resourceId: string | null
    resourceType: string | null
    senderId: string | null
    receiverId: string | null
    resourceLink: string | null
    look: boolean | null
    createdAt: Date | null
  }

  export type SharePTPCountAggregateOutputType = {
    id: number
    resourceId: number
    resourceType: number
    senderId: number
    receiverId: number
    resourceLink: number
    look: number
    createdAt: number
    _all: number
  }


  export type SharePTPMinAggregateInputType = {
    id?: true
    resourceId?: true
    resourceType?: true
    senderId?: true
    receiverId?: true
    resourceLink?: true
    look?: true
    createdAt?: true
  }

  export type SharePTPMaxAggregateInputType = {
    id?: true
    resourceId?: true
    resourceType?: true
    senderId?: true
    receiverId?: true
    resourceLink?: true
    look?: true
    createdAt?: true
  }

  export type SharePTPCountAggregateInputType = {
    id?: true
    resourceId?: true
    resourceType?: true
    senderId?: true
    receiverId?: true
    resourceLink?: true
    look?: true
    createdAt?: true
    _all?: true
  }

  export type SharePTPAggregateArgs = {
    /**
     * Filter which SharePTP to aggregate.
     */
    where?: SharePTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharePTPS to fetch.
     */
    orderBy?: Enumerable<SharePTPOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SharePTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharePTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharePTPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SharePTPS
    **/
    _count?: true | SharePTPCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SharePTPMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SharePTPMaxAggregateInputType
  }

  export type GetSharePTPAggregateType<T extends SharePTPAggregateArgs> = {
        [P in keyof T & keyof AggregateSharePTP]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSharePTP[P]>
      : GetScalarType<T[P], AggregateSharePTP[P]>
  }




  export type SharePTPGroupByArgs = {
    where?: SharePTPWhereInput
    orderBy?: Enumerable<SharePTPOrderByWithAggregationInput>
    by: SharePTPScalarFieldEnum[]
    having?: SharePTPScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SharePTPCountAggregateInputType | true
    _min?: SharePTPMinAggregateInputType
    _max?: SharePTPMaxAggregateInputType
  }


  export type SharePTPGroupByOutputType = {
    id: string
    resourceId: string
    resourceType: string
    senderId: string
    receiverId: string
    resourceLink: string | null
    look: boolean
    createdAt: Date
    _count: SharePTPCountAggregateOutputType | null
    _min: SharePTPMinAggregateOutputType | null
    _max: SharePTPMaxAggregateOutputType | null
  }

  type GetSharePTPGroupByPayload<T extends SharePTPGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SharePTPGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SharePTPGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SharePTPGroupByOutputType[P]>
            : GetScalarType<T[P], SharePTPGroupByOutputType[P]>
        }
      >
    >


  export type SharePTPSelect = {
    id?: boolean
    resourceId?: boolean
    resourceType?: boolean
    senderId?: boolean
    receiverId?: boolean
    resourceLink?: boolean
    look?: boolean
    createdAt?: boolean
  }


  export type SharePTPGetPayload<S extends boolean | null | undefined | SharePTPArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SharePTP :
    S extends undefined ? never :
    S extends { include: any } & (SharePTPArgs | SharePTPFindManyArgs)
    ? SharePTP 
    : S extends { select: any } & (SharePTPArgs | SharePTPFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SharePTP ? SharePTP[P] : never
  } 
      : SharePTP


  type SharePTPCountArgs = 
    Omit<SharePTPFindManyArgs, 'select' | 'include'> & {
      select?: SharePTPCountAggregateInputType | true
    }

  export interface SharePTPDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SharePTP that matches the filter.
     * @param {SharePTPFindUniqueArgs} args - Arguments to find a SharePTP
     * @example
     * // Get one SharePTP
     * const sharePTP = await prisma.sharePTP.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SharePTPFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SharePTPFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SharePTP'> extends True ? Prisma__SharePTPClient<SharePTPGetPayload<T>> : Prisma__SharePTPClient<SharePTPGetPayload<T> | null, null>

    /**
     * Find one SharePTP that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SharePTPFindUniqueOrThrowArgs} args - Arguments to find a SharePTP
     * @example
     * // Get one SharePTP
     * const sharePTP = await prisma.sharePTP.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SharePTPFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SharePTPFindUniqueOrThrowArgs>
    ): Prisma__SharePTPClient<SharePTPGetPayload<T>>

    /**
     * Find the first SharePTP that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharePTPFindFirstArgs} args - Arguments to find a SharePTP
     * @example
     * // Get one SharePTP
     * const sharePTP = await prisma.sharePTP.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SharePTPFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SharePTPFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SharePTP'> extends True ? Prisma__SharePTPClient<SharePTPGetPayload<T>> : Prisma__SharePTPClient<SharePTPGetPayload<T> | null, null>

    /**
     * Find the first SharePTP that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharePTPFindFirstOrThrowArgs} args - Arguments to find a SharePTP
     * @example
     * // Get one SharePTP
     * const sharePTP = await prisma.sharePTP.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SharePTPFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SharePTPFindFirstOrThrowArgs>
    ): Prisma__SharePTPClient<SharePTPGetPayload<T>>

    /**
     * Find zero or more SharePTPS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharePTPFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SharePTPS
     * const sharePTPS = await prisma.sharePTP.findMany()
     * 
     * // Get first 10 SharePTPS
     * const sharePTPS = await prisma.sharePTP.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sharePTPWithIdOnly = await prisma.sharePTP.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SharePTPFindManyArgs>(
      args?: SelectSubset<T, SharePTPFindManyArgs>
    ): Prisma.PrismaPromise<Array<SharePTPGetPayload<T>>>

    /**
     * Create a SharePTP.
     * @param {SharePTPCreateArgs} args - Arguments to create a SharePTP.
     * @example
     * // Create one SharePTP
     * const SharePTP = await prisma.sharePTP.create({
     *   data: {
     *     // ... data to create a SharePTP
     *   }
     * })
     * 
    **/
    create<T extends SharePTPCreateArgs>(
      args: SelectSubset<T, SharePTPCreateArgs>
    ): Prisma__SharePTPClient<SharePTPGetPayload<T>>

    /**
     * Create many SharePTPS.
     *     @param {SharePTPCreateManyArgs} args - Arguments to create many SharePTPS.
     *     @example
     *     // Create many SharePTPS
     *     const sharePTP = await prisma.sharePTP.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SharePTPCreateManyArgs>(
      args?: SelectSubset<T, SharePTPCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SharePTP.
     * @param {SharePTPDeleteArgs} args - Arguments to delete one SharePTP.
     * @example
     * // Delete one SharePTP
     * const SharePTP = await prisma.sharePTP.delete({
     *   where: {
     *     // ... filter to delete one SharePTP
     *   }
     * })
     * 
    **/
    delete<T extends SharePTPDeleteArgs>(
      args: SelectSubset<T, SharePTPDeleteArgs>
    ): Prisma__SharePTPClient<SharePTPGetPayload<T>>

    /**
     * Update one SharePTP.
     * @param {SharePTPUpdateArgs} args - Arguments to update one SharePTP.
     * @example
     * // Update one SharePTP
     * const sharePTP = await prisma.sharePTP.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SharePTPUpdateArgs>(
      args: SelectSubset<T, SharePTPUpdateArgs>
    ): Prisma__SharePTPClient<SharePTPGetPayload<T>>

    /**
     * Delete zero or more SharePTPS.
     * @param {SharePTPDeleteManyArgs} args - Arguments to filter SharePTPS to delete.
     * @example
     * // Delete a few SharePTPS
     * const { count } = await prisma.sharePTP.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SharePTPDeleteManyArgs>(
      args?: SelectSubset<T, SharePTPDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SharePTPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharePTPUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SharePTPS
     * const sharePTP = await prisma.sharePTP.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SharePTPUpdateManyArgs>(
      args: SelectSubset<T, SharePTPUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SharePTP.
     * @param {SharePTPUpsertArgs} args - Arguments to update or create a SharePTP.
     * @example
     * // Update or create a SharePTP
     * const sharePTP = await prisma.sharePTP.upsert({
     *   create: {
     *     // ... data to create a SharePTP
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SharePTP we want to update
     *   }
     * })
    **/
    upsert<T extends SharePTPUpsertArgs>(
      args: SelectSubset<T, SharePTPUpsertArgs>
    ): Prisma__SharePTPClient<SharePTPGetPayload<T>>

    /**
     * Count the number of SharePTPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharePTPCountArgs} args - Arguments to filter SharePTPS to count.
     * @example
     * // Count the number of SharePTPS
     * const count = await prisma.sharePTP.count({
     *   where: {
     *     // ... the filter for the SharePTPS we want to count
     *   }
     * })
    **/
    count<T extends SharePTPCountArgs>(
      args?: Subset<T, SharePTPCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SharePTPCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SharePTP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharePTPAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SharePTPAggregateArgs>(args: Subset<T, SharePTPAggregateArgs>): Prisma.PrismaPromise<GetSharePTPAggregateType<T>>

    /**
     * Group by SharePTP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharePTPGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SharePTPGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SharePTPGroupByArgs['orderBy'] }
        : { orderBy?: SharePTPGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SharePTPGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSharePTPGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SharePTP.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SharePTPClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SharePTP base type for findUnique actions
   */
  export type SharePTPFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SharePTP
     */
    select?: SharePTPSelect | null
    /**
     * Filter, which SharePTP to fetch.
     */
    where: SharePTPWhereUniqueInput
  }

  /**
   * SharePTP findUnique
   */
  export interface SharePTPFindUniqueArgs extends SharePTPFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SharePTP findUniqueOrThrow
   */
  export type SharePTPFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SharePTP
     */
    select?: SharePTPSelect | null
    /**
     * Filter, which SharePTP to fetch.
     */
    where: SharePTPWhereUniqueInput
  }


  /**
   * SharePTP base type for findFirst actions
   */
  export type SharePTPFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SharePTP
     */
    select?: SharePTPSelect | null
    /**
     * Filter, which SharePTP to fetch.
     */
    where?: SharePTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharePTPS to fetch.
     */
    orderBy?: Enumerable<SharePTPOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SharePTPS.
     */
    cursor?: SharePTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharePTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharePTPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SharePTPS.
     */
    distinct?: Enumerable<SharePTPScalarFieldEnum>
  }

  /**
   * SharePTP findFirst
   */
  export interface SharePTPFindFirstArgs extends SharePTPFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SharePTP findFirstOrThrow
   */
  export type SharePTPFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SharePTP
     */
    select?: SharePTPSelect | null
    /**
     * Filter, which SharePTP to fetch.
     */
    where?: SharePTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharePTPS to fetch.
     */
    orderBy?: Enumerable<SharePTPOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SharePTPS.
     */
    cursor?: SharePTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharePTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharePTPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SharePTPS.
     */
    distinct?: Enumerable<SharePTPScalarFieldEnum>
  }


  /**
   * SharePTP findMany
   */
  export type SharePTPFindManyArgs = {
    /**
     * Select specific fields to fetch from the SharePTP
     */
    select?: SharePTPSelect | null
    /**
     * Filter, which SharePTPS to fetch.
     */
    where?: SharePTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharePTPS to fetch.
     */
    orderBy?: Enumerable<SharePTPOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SharePTPS.
     */
    cursor?: SharePTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharePTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharePTPS.
     */
    skip?: number
    distinct?: Enumerable<SharePTPScalarFieldEnum>
  }


  /**
   * SharePTP create
   */
  export type SharePTPCreateArgs = {
    /**
     * Select specific fields to fetch from the SharePTP
     */
    select?: SharePTPSelect | null
    /**
     * The data needed to create a SharePTP.
     */
    data: XOR<SharePTPCreateInput, SharePTPUncheckedCreateInput>
  }


  /**
   * SharePTP createMany
   */
  export type SharePTPCreateManyArgs = {
    /**
     * The data used to create many SharePTPS.
     */
    data: Enumerable<SharePTPCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SharePTP update
   */
  export type SharePTPUpdateArgs = {
    /**
     * Select specific fields to fetch from the SharePTP
     */
    select?: SharePTPSelect | null
    /**
     * The data needed to update a SharePTP.
     */
    data: XOR<SharePTPUpdateInput, SharePTPUncheckedUpdateInput>
    /**
     * Choose, which SharePTP to update.
     */
    where: SharePTPWhereUniqueInput
  }


  /**
   * SharePTP updateMany
   */
  export type SharePTPUpdateManyArgs = {
    /**
     * The data used to update SharePTPS.
     */
    data: XOR<SharePTPUpdateManyMutationInput, SharePTPUncheckedUpdateManyInput>
    /**
     * Filter which SharePTPS to update
     */
    where?: SharePTPWhereInput
  }


  /**
   * SharePTP upsert
   */
  export type SharePTPUpsertArgs = {
    /**
     * Select specific fields to fetch from the SharePTP
     */
    select?: SharePTPSelect | null
    /**
     * The filter to search for the SharePTP to update in case it exists.
     */
    where: SharePTPWhereUniqueInput
    /**
     * In case the SharePTP found by the `where` argument doesn't exist, create a new SharePTP with this data.
     */
    create: XOR<SharePTPCreateInput, SharePTPUncheckedCreateInput>
    /**
     * In case the SharePTP was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SharePTPUpdateInput, SharePTPUncheckedUpdateInput>
  }


  /**
   * SharePTP delete
   */
  export type SharePTPDeleteArgs = {
    /**
     * Select specific fields to fetch from the SharePTP
     */
    select?: SharePTPSelect | null
    /**
     * Filter which SharePTP to delete.
     */
    where: SharePTPWhereUniqueInput
  }


  /**
   * SharePTP deleteMany
   */
  export type SharePTPDeleteManyArgs = {
    /**
     * Filter which SharePTPS to delete
     */
    where?: SharePTPWhereInput
  }


  /**
   * SharePTP without action
   */
  export type SharePTPArgs = {
    /**
     * Select specific fields to fetch from the SharePTP
     */
    select?: SharePTPSelect | null
  }



  /**
   * Model Group
   */


  export type AggregateGroup = {
    _count: GroupCountAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  export type GroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    creatorId: string | null
    generalChatSessionId: string | null
    createdAt: Date | null
  }

  export type GroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    creatorId: string | null
    generalChatSessionId: string | null
    createdAt: Date | null
  }

  export type GroupCountAggregateOutputType = {
    id: number
    name: number
    creatorId: number
    generalChatSessionId: number
    createdAt: number
    _all: number
  }


  export type GroupMinAggregateInputType = {
    id?: true
    name?: true
    creatorId?: true
    generalChatSessionId?: true
    createdAt?: true
  }

  export type GroupMaxAggregateInputType = {
    id?: true
    name?: true
    creatorId?: true
    generalChatSessionId?: true
    createdAt?: true
  }

  export type GroupCountAggregateInputType = {
    id?: true
    name?: true
    creatorId?: true
    generalChatSessionId?: true
    createdAt?: true
    _all?: true
  }

  export type GroupAggregateArgs = {
    /**
     * Filter which Group to aggregate.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: Enumerable<GroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Groups
    **/
    _count?: true | GroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMaxAggregateInputType
  }

  export type GetGroupAggregateType<T extends GroupAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup[P]>
      : GetScalarType<T[P], AggregateGroup[P]>
  }




  export type GroupGroupByArgs = {
    where?: GroupWhereInput
    orderBy?: Enumerable<GroupOrderByWithAggregationInput>
    by: GroupScalarFieldEnum[]
    having?: GroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupCountAggregateInputType | true
    _min?: GroupMinAggregateInputType
    _max?: GroupMaxAggregateInputType
  }


  export type GroupGroupByOutputType = {
    id: string
    name: string
    creatorId: string
    generalChatSessionId: string | null
    createdAt: Date
    _count: GroupCountAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  type GetGroupGroupByPayload<T extends GroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<GroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupGroupByOutputType[P]>
            : GetScalarType<T[P], GroupGroupByOutputType[P]>
        }
      >
    >


  export type GroupSelect = {
    id?: boolean
    name?: boolean
    creatorId?: boolean
    generalChatSessionId?: boolean
    createdAt?: boolean
    creator?: boolean | UserArgs
    users?: boolean | Group$usersArgs
    posts?: boolean | Group$postsArgs
    _count?: boolean | GroupCountOutputTypeArgs
  }


  export type GroupInclude = {
    creator?: boolean | UserArgs
    users?: boolean | Group$usersArgs
    posts?: boolean | Group$postsArgs
    _count?: boolean | GroupCountOutputTypeArgs
  }

  export type GroupGetPayload<S extends boolean | null | undefined | GroupArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Group :
    S extends undefined ? never :
    S extends { include: any } & (GroupArgs | GroupFindManyArgs)
    ? Group  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'creator' ? UserGetPayload<S['include'][P]> :
        P extends 'users' ? Array < UserGroupRelGetPayload<S['include'][P]>>  :
        P extends 'posts' ? Array < GroupPostGetPayload<S['include'][P]>>  :
        P extends '_count' ? GroupCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (GroupArgs | GroupFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'creator' ? UserGetPayload<S['select'][P]> :
        P extends 'users' ? Array < UserGroupRelGetPayload<S['select'][P]>>  :
        P extends 'posts' ? Array < GroupPostGetPayload<S['select'][P]>>  :
        P extends '_count' ? GroupCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Group ? Group[P] : never
  } 
      : Group


  type GroupCountArgs = 
    Omit<GroupFindManyArgs, 'select' | 'include'> & {
      select?: GroupCountAggregateInputType | true
    }

  export interface GroupDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Group that matches the filter.
     * @param {GroupFindUniqueArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GroupFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GroupFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Group'> extends True ? Prisma__GroupClient<GroupGetPayload<T>> : Prisma__GroupClient<GroupGetPayload<T> | null, null>

    /**
     * Find one Group that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GroupFindUniqueOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GroupFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, GroupFindUniqueOrThrowArgs>
    ): Prisma__GroupClient<GroupGetPayload<T>>

    /**
     * Find the first Group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GroupFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GroupFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Group'> extends True ? Prisma__GroupClient<GroupGetPayload<T>> : Prisma__GroupClient<GroupGetPayload<T> | null, null>

    /**
     * Find the first Group that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GroupFindFirstOrThrowArgs>(
      args?: SelectSubset<T, GroupFindFirstOrThrowArgs>
    ): Prisma__GroupClient<GroupGetPayload<T>>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.group.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupWithIdOnly = await prisma.group.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GroupFindManyArgs>(
      args?: SelectSubset<T, GroupFindManyArgs>
    ): Prisma.PrismaPromise<Array<GroupGetPayload<T>>>

    /**
     * Create a Group.
     * @param {GroupCreateArgs} args - Arguments to create a Group.
     * @example
     * // Create one Group
     * const Group = await prisma.group.create({
     *   data: {
     *     // ... data to create a Group
     *   }
     * })
     * 
    **/
    create<T extends GroupCreateArgs>(
      args: SelectSubset<T, GroupCreateArgs>
    ): Prisma__GroupClient<GroupGetPayload<T>>

    /**
     * Create many Groups.
     *     @param {GroupCreateManyArgs} args - Arguments to create many Groups.
     *     @example
     *     // Create many Groups
     *     const group = await prisma.group.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GroupCreateManyArgs>(
      args?: SelectSubset<T, GroupCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Group.
     * @param {GroupDeleteArgs} args - Arguments to delete one Group.
     * @example
     * // Delete one Group
     * const Group = await prisma.group.delete({
     *   where: {
     *     // ... filter to delete one Group
     *   }
     * })
     * 
    **/
    delete<T extends GroupDeleteArgs>(
      args: SelectSubset<T, GroupDeleteArgs>
    ): Prisma__GroupClient<GroupGetPayload<T>>

    /**
     * Update one Group.
     * @param {GroupUpdateArgs} args - Arguments to update one Group.
     * @example
     * // Update one Group
     * const group = await prisma.group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GroupUpdateArgs>(
      args: SelectSubset<T, GroupUpdateArgs>
    ): Prisma__GroupClient<GroupGetPayload<T>>

    /**
     * Delete zero or more Groups.
     * @param {GroupDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GroupDeleteManyArgs>(
      args?: SelectSubset<T, GroupDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GroupUpdateManyArgs>(
      args: SelectSubset<T, GroupUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Group.
     * @param {GroupUpsertArgs} args - Arguments to update or create a Group.
     * @example
     * // Update or create a Group
     * const group = await prisma.group.upsert({
     *   create: {
     *     // ... data to create a Group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group we want to update
     *   }
     * })
    **/
    upsert<T extends GroupUpsertArgs>(
      args: SelectSubset<T, GroupUpsertArgs>
    ): Prisma__GroupClient<GroupGetPayload<T>>

    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.group.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends GroupCountArgs>(
      args?: Subset<T, GroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupAggregateArgs>(args: Subset<T, GroupAggregateArgs>): Prisma.PrismaPromise<GetGroupAggregateType<T>>

    /**
     * Group by Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupGroupByArgs['orderBy'] }
        : { orderBy?: GroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GroupClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    creator<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    users<T extends Group$usersArgs= {}>(args?: Subset<T, Group$usersArgs>): Prisma.PrismaPromise<Array<UserGroupRelGetPayload<T>>| Null>;

    posts<T extends Group$postsArgs= {}>(args?: Subset<T, Group$postsArgs>): Prisma.PrismaPromise<Array<GroupPostGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Group base type for findUnique actions
   */
  export type GroupFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findUnique
   */
  export interface GroupFindUniqueArgs extends GroupFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Group findUniqueOrThrow
   */
  export type GroupFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }


  /**
   * Group base type for findFirst actions
   */
  export type GroupFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: Enumerable<GroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: Enumerable<GroupScalarFieldEnum>
  }

  /**
   * Group findFirst
   */
  export interface GroupFindFirstArgs extends GroupFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Group findFirstOrThrow
   */
  export type GroupFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: Enumerable<GroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: Enumerable<GroupScalarFieldEnum>
  }


  /**
   * Group findMany
   */
  export type GroupFindManyArgs = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: Enumerable<GroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    distinct?: Enumerable<GroupScalarFieldEnum>
  }


  /**
   * Group create
   */
  export type GroupCreateArgs = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude | null
    /**
     * The data needed to create a Group.
     */
    data: XOR<GroupCreateInput, GroupUncheckedCreateInput>
  }


  /**
   * Group createMany
   */
  export type GroupCreateManyArgs = {
    /**
     * The data used to create many Groups.
     */
    data: Enumerable<GroupCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Group update
   */
  export type GroupUpdateArgs = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude | null
    /**
     * The data needed to update a Group.
     */
    data: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
    /**
     * Choose, which Group to update.
     */
    where: GroupWhereUniqueInput
  }


  /**
   * Group updateMany
   */
  export type GroupUpdateManyArgs = {
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
  }


  /**
   * Group upsert
   */
  export type GroupUpsertArgs = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude | null
    /**
     * The filter to search for the Group to update in case it exists.
     */
    where: GroupWhereUniqueInput
    /**
     * In case the Group found by the `where` argument doesn't exist, create a new Group with this data.
     */
    create: XOR<GroupCreateInput, GroupUncheckedCreateInput>
    /**
     * In case the Group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
  }


  /**
   * Group delete
   */
  export type GroupDeleteArgs = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude | null
    /**
     * Filter which Group to delete.
     */
    where: GroupWhereUniqueInput
  }


  /**
   * Group deleteMany
   */
  export type GroupDeleteManyArgs = {
    /**
     * Filter which Groups to delete
     */
    where?: GroupWhereInput
  }


  /**
   * Group.users
   */
  export type Group$usersArgs = {
    /**
     * Select specific fields to fetch from the UserGroupRel
     */
    select?: UserGroupRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserGroupRelInclude | null
    where?: UserGroupRelWhereInput
    orderBy?: Enumerable<UserGroupRelOrderByWithRelationInput>
    cursor?: UserGroupRelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserGroupRelScalarFieldEnum>
  }


  /**
   * Group.posts
   */
  export type Group$postsArgs = {
    /**
     * Select specific fields to fetch from the GroupPost
     */
    select?: GroupPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupPostInclude | null
    where?: GroupPostWhereInput
    orderBy?: Enumerable<GroupPostOrderByWithRelationInput>
    cursor?: GroupPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<GroupPostScalarFieldEnum>
  }


  /**
   * Group without action
   */
  export type GroupArgs = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude | null
  }



  /**
   * Model UserGroupRel
   */


  export type AggregateUserGroupRel = {
    _count: UserGroupRelCountAggregateOutputType | null
    _min: UserGroupRelMinAggregateOutputType | null
    _max: UserGroupRelMaxAggregateOutputType | null
  }

  export type UserGroupRelMinAggregateOutputType = {
    username: string | null
    groupId: string | null
    joinedAt: Date | null
  }

  export type UserGroupRelMaxAggregateOutputType = {
    username: string | null
    groupId: string | null
    joinedAt: Date | null
  }

  export type UserGroupRelCountAggregateOutputType = {
    username: number
    groupId: number
    joinedAt: number
    _all: number
  }


  export type UserGroupRelMinAggregateInputType = {
    username?: true
    groupId?: true
    joinedAt?: true
  }

  export type UserGroupRelMaxAggregateInputType = {
    username?: true
    groupId?: true
    joinedAt?: true
  }

  export type UserGroupRelCountAggregateInputType = {
    username?: true
    groupId?: true
    joinedAt?: true
    _all?: true
  }

  export type UserGroupRelAggregateArgs = {
    /**
     * Filter which UserGroupRel to aggregate.
     */
    where?: UserGroupRelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroupRels to fetch.
     */
    orderBy?: Enumerable<UserGroupRelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserGroupRelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroupRels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroupRels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserGroupRels
    **/
    _count?: true | UserGroupRelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserGroupRelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserGroupRelMaxAggregateInputType
  }

  export type GetUserGroupRelAggregateType<T extends UserGroupRelAggregateArgs> = {
        [P in keyof T & keyof AggregateUserGroupRel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserGroupRel[P]>
      : GetScalarType<T[P], AggregateUserGroupRel[P]>
  }




  export type UserGroupRelGroupByArgs = {
    where?: UserGroupRelWhereInput
    orderBy?: Enumerable<UserGroupRelOrderByWithAggregationInput>
    by: UserGroupRelScalarFieldEnum[]
    having?: UserGroupRelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserGroupRelCountAggregateInputType | true
    _min?: UserGroupRelMinAggregateInputType
    _max?: UserGroupRelMaxAggregateInputType
  }


  export type UserGroupRelGroupByOutputType = {
    username: string
    groupId: string
    joinedAt: Date
    _count: UserGroupRelCountAggregateOutputType | null
    _min: UserGroupRelMinAggregateOutputType | null
    _max: UserGroupRelMaxAggregateOutputType | null
  }

  type GetUserGroupRelGroupByPayload<T extends UserGroupRelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupRelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupRelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupRelGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupRelGroupByOutputType[P]>
        }
      >
    >


  export type UserGroupRelSelect = {
    username?: boolean
    groupId?: boolean
    joinedAt?: boolean
    user?: boolean | UserArgs
    group?: boolean | GroupArgs
  }


  export type UserGroupRelInclude = {
    user?: boolean | UserArgs
    group?: boolean | GroupArgs
  }

  export type UserGroupRelGetPayload<S extends boolean | null | undefined | UserGroupRelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserGroupRel :
    S extends undefined ? never :
    S extends { include: any } & (UserGroupRelArgs | UserGroupRelFindManyArgs)
    ? UserGroupRel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'group' ? GroupGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserGroupRelArgs | UserGroupRelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'group' ? GroupGetPayload<S['select'][P]> :  P extends keyof UserGroupRel ? UserGroupRel[P] : never
  } 
      : UserGroupRel


  type UserGroupRelCountArgs = 
    Omit<UserGroupRelFindManyArgs, 'select' | 'include'> & {
      select?: UserGroupRelCountAggregateInputType | true
    }

  export interface UserGroupRelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UserGroupRel that matches the filter.
     * @param {UserGroupRelFindUniqueArgs} args - Arguments to find a UserGroupRel
     * @example
     * // Get one UserGroupRel
     * const userGroupRel = await prisma.userGroupRel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserGroupRelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserGroupRelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserGroupRel'> extends True ? Prisma__UserGroupRelClient<UserGroupRelGetPayload<T>> : Prisma__UserGroupRelClient<UserGroupRelGetPayload<T> | null, null>

    /**
     * Find one UserGroupRel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserGroupRelFindUniqueOrThrowArgs} args - Arguments to find a UserGroupRel
     * @example
     * // Get one UserGroupRel
     * const userGroupRel = await prisma.userGroupRel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserGroupRelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserGroupRelFindUniqueOrThrowArgs>
    ): Prisma__UserGroupRelClient<UserGroupRelGetPayload<T>>

    /**
     * Find the first UserGroupRel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupRelFindFirstArgs} args - Arguments to find a UserGroupRel
     * @example
     * // Get one UserGroupRel
     * const userGroupRel = await prisma.userGroupRel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserGroupRelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserGroupRelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserGroupRel'> extends True ? Prisma__UserGroupRelClient<UserGroupRelGetPayload<T>> : Prisma__UserGroupRelClient<UserGroupRelGetPayload<T> | null, null>

    /**
     * Find the first UserGroupRel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupRelFindFirstOrThrowArgs} args - Arguments to find a UserGroupRel
     * @example
     * // Get one UserGroupRel
     * const userGroupRel = await prisma.userGroupRel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserGroupRelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserGroupRelFindFirstOrThrowArgs>
    ): Prisma__UserGroupRelClient<UserGroupRelGetPayload<T>>

    /**
     * Find zero or more UserGroupRels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupRelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserGroupRels
     * const userGroupRels = await prisma.userGroupRel.findMany()
     * 
     * // Get first 10 UserGroupRels
     * const userGroupRels = await prisma.userGroupRel.findMany({ take: 10 })
     * 
     * // Only select the `username`
     * const userGroupRelWithUsernameOnly = await prisma.userGroupRel.findMany({ select: { username: true } })
     * 
    **/
    findMany<T extends UserGroupRelFindManyArgs>(
      args?: SelectSubset<T, UserGroupRelFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserGroupRelGetPayload<T>>>

    /**
     * Create a UserGroupRel.
     * @param {UserGroupRelCreateArgs} args - Arguments to create a UserGroupRel.
     * @example
     * // Create one UserGroupRel
     * const UserGroupRel = await prisma.userGroupRel.create({
     *   data: {
     *     // ... data to create a UserGroupRel
     *   }
     * })
     * 
    **/
    create<T extends UserGroupRelCreateArgs>(
      args: SelectSubset<T, UserGroupRelCreateArgs>
    ): Prisma__UserGroupRelClient<UserGroupRelGetPayload<T>>

    /**
     * Create many UserGroupRels.
     *     @param {UserGroupRelCreateManyArgs} args - Arguments to create many UserGroupRels.
     *     @example
     *     // Create many UserGroupRels
     *     const userGroupRel = await prisma.userGroupRel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserGroupRelCreateManyArgs>(
      args?: SelectSubset<T, UserGroupRelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserGroupRel.
     * @param {UserGroupRelDeleteArgs} args - Arguments to delete one UserGroupRel.
     * @example
     * // Delete one UserGroupRel
     * const UserGroupRel = await prisma.userGroupRel.delete({
     *   where: {
     *     // ... filter to delete one UserGroupRel
     *   }
     * })
     * 
    **/
    delete<T extends UserGroupRelDeleteArgs>(
      args: SelectSubset<T, UserGroupRelDeleteArgs>
    ): Prisma__UserGroupRelClient<UserGroupRelGetPayload<T>>

    /**
     * Update one UserGroupRel.
     * @param {UserGroupRelUpdateArgs} args - Arguments to update one UserGroupRel.
     * @example
     * // Update one UserGroupRel
     * const userGroupRel = await prisma.userGroupRel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserGroupRelUpdateArgs>(
      args: SelectSubset<T, UserGroupRelUpdateArgs>
    ): Prisma__UserGroupRelClient<UserGroupRelGetPayload<T>>

    /**
     * Delete zero or more UserGroupRels.
     * @param {UserGroupRelDeleteManyArgs} args - Arguments to filter UserGroupRels to delete.
     * @example
     * // Delete a few UserGroupRels
     * const { count } = await prisma.userGroupRel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserGroupRelDeleteManyArgs>(
      args?: SelectSubset<T, UserGroupRelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserGroupRels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupRelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserGroupRels
     * const userGroupRel = await prisma.userGroupRel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserGroupRelUpdateManyArgs>(
      args: SelectSubset<T, UserGroupRelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserGroupRel.
     * @param {UserGroupRelUpsertArgs} args - Arguments to update or create a UserGroupRel.
     * @example
     * // Update or create a UserGroupRel
     * const userGroupRel = await prisma.userGroupRel.upsert({
     *   create: {
     *     // ... data to create a UserGroupRel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserGroupRel we want to update
     *   }
     * })
    **/
    upsert<T extends UserGroupRelUpsertArgs>(
      args: SelectSubset<T, UserGroupRelUpsertArgs>
    ): Prisma__UserGroupRelClient<UserGroupRelGetPayload<T>>

    /**
     * Count the number of UserGroupRels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupRelCountArgs} args - Arguments to filter UserGroupRels to count.
     * @example
     * // Count the number of UserGroupRels
     * const count = await prisma.userGroupRel.count({
     *   where: {
     *     // ... the filter for the UserGroupRels we want to count
     *   }
     * })
    **/
    count<T extends UserGroupRelCountArgs>(
      args?: Subset<T, UserGroupRelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserGroupRelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserGroupRel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupRelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserGroupRelAggregateArgs>(args: Subset<T, UserGroupRelAggregateArgs>): Prisma.PrismaPromise<GetUserGroupRelAggregateType<T>>

    /**
     * Group by UserGroupRel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupRelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupRelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupRelGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupRelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupRelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupRelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserGroupRel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserGroupRelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    group<T extends GroupArgs= {}>(args?: Subset<T, GroupArgs>): Prisma__GroupClient<GroupGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserGroupRel base type for findUnique actions
   */
  export type UserGroupRelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserGroupRel
     */
    select?: UserGroupRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserGroupRelInclude | null
    /**
     * Filter, which UserGroupRel to fetch.
     */
    where: UserGroupRelWhereUniqueInput
  }

  /**
   * UserGroupRel findUnique
   */
  export interface UserGroupRelFindUniqueArgs extends UserGroupRelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserGroupRel findUniqueOrThrow
   */
  export type UserGroupRelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserGroupRel
     */
    select?: UserGroupRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserGroupRelInclude | null
    /**
     * Filter, which UserGroupRel to fetch.
     */
    where: UserGroupRelWhereUniqueInput
  }


  /**
   * UserGroupRel base type for findFirst actions
   */
  export type UserGroupRelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserGroupRel
     */
    select?: UserGroupRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserGroupRelInclude | null
    /**
     * Filter, which UserGroupRel to fetch.
     */
    where?: UserGroupRelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroupRels to fetch.
     */
    orderBy?: Enumerable<UserGroupRelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserGroupRels.
     */
    cursor?: UserGroupRelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroupRels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroupRels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserGroupRels.
     */
    distinct?: Enumerable<UserGroupRelScalarFieldEnum>
  }

  /**
   * UserGroupRel findFirst
   */
  export interface UserGroupRelFindFirstArgs extends UserGroupRelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserGroupRel findFirstOrThrow
   */
  export type UserGroupRelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserGroupRel
     */
    select?: UserGroupRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserGroupRelInclude | null
    /**
     * Filter, which UserGroupRel to fetch.
     */
    where?: UserGroupRelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroupRels to fetch.
     */
    orderBy?: Enumerable<UserGroupRelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserGroupRels.
     */
    cursor?: UserGroupRelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroupRels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroupRels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserGroupRels.
     */
    distinct?: Enumerable<UserGroupRelScalarFieldEnum>
  }


  /**
   * UserGroupRel findMany
   */
  export type UserGroupRelFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserGroupRel
     */
    select?: UserGroupRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserGroupRelInclude | null
    /**
     * Filter, which UserGroupRels to fetch.
     */
    where?: UserGroupRelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroupRels to fetch.
     */
    orderBy?: Enumerable<UserGroupRelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserGroupRels.
     */
    cursor?: UserGroupRelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroupRels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroupRels.
     */
    skip?: number
    distinct?: Enumerable<UserGroupRelScalarFieldEnum>
  }


  /**
   * UserGroupRel create
   */
  export type UserGroupRelCreateArgs = {
    /**
     * Select specific fields to fetch from the UserGroupRel
     */
    select?: UserGroupRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserGroupRelInclude | null
    /**
     * The data needed to create a UserGroupRel.
     */
    data: XOR<UserGroupRelCreateInput, UserGroupRelUncheckedCreateInput>
  }


  /**
   * UserGroupRel createMany
   */
  export type UserGroupRelCreateManyArgs = {
    /**
     * The data used to create many UserGroupRels.
     */
    data: Enumerable<UserGroupRelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserGroupRel update
   */
  export type UserGroupRelUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserGroupRel
     */
    select?: UserGroupRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserGroupRelInclude | null
    /**
     * The data needed to update a UserGroupRel.
     */
    data: XOR<UserGroupRelUpdateInput, UserGroupRelUncheckedUpdateInput>
    /**
     * Choose, which UserGroupRel to update.
     */
    where: UserGroupRelWhereUniqueInput
  }


  /**
   * UserGroupRel updateMany
   */
  export type UserGroupRelUpdateManyArgs = {
    /**
     * The data used to update UserGroupRels.
     */
    data: XOR<UserGroupRelUpdateManyMutationInput, UserGroupRelUncheckedUpdateManyInput>
    /**
     * Filter which UserGroupRels to update
     */
    where?: UserGroupRelWhereInput
  }


  /**
   * UserGroupRel upsert
   */
  export type UserGroupRelUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserGroupRel
     */
    select?: UserGroupRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserGroupRelInclude | null
    /**
     * The filter to search for the UserGroupRel to update in case it exists.
     */
    where: UserGroupRelWhereUniqueInput
    /**
     * In case the UserGroupRel found by the `where` argument doesn't exist, create a new UserGroupRel with this data.
     */
    create: XOR<UserGroupRelCreateInput, UserGroupRelUncheckedCreateInput>
    /**
     * In case the UserGroupRel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserGroupRelUpdateInput, UserGroupRelUncheckedUpdateInput>
  }


  /**
   * UserGroupRel delete
   */
  export type UserGroupRelDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserGroupRel
     */
    select?: UserGroupRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserGroupRelInclude | null
    /**
     * Filter which UserGroupRel to delete.
     */
    where: UserGroupRelWhereUniqueInput
  }


  /**
   * UserGroupRel deleteMany
   */
  export type UserGroupRelDeleteManyArgs = {
    /**
     * Filter which UserGroupRels to delete
     */
    where?: UserGroupRelWhereInput
  }


  /**
   * UserGroupRel without action
   */
  export type UserGroupRelArgs = {
    /**
     * Select specific fields to fetch from the UserGroupRel
     */
    select?: UserGroupRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserGroupRelInclude | null
  }



  /**
   * Model UserProfile
   */


  export type AggregateUserProfile = {
    _count: UserProfileCountAggregateOutputType | null
    _avg: UserProfileAvgAggregateOutputType | null
    _sum: UserProfileSumAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  export type UserProfileAvgAggregateOutputType = {
    accepted_number: number | null
    total_score: number | null
    total_practice_score: number | null
    submission_number: number | null
    rating: number | null
  }

  export type UserProfileSumAggregateOutputType = {
    accepted_number: number | null
    total_score: number | null
    total_practice_score: number | null
    submission_number: number | null
    rating: number | null
  }

  export type UserProfileMinAggregateOutputType = {
    id: string | null
    real_name: string | null
    avatar: string | null
    blog: string | null
    github: string | null
    school: string | null
    major: string | null
    language: string | null
    accepted_number: number | null
    total_score: number | null
    total_practice_score: number | null
    submission_number: number | null
    rating: number | null
    username: string | null
  }

  export type UserProfileMaxAggregateOutputType = {
    id: string | null
    real_name: string | null
    avatar: string | null
    blog: string | null
    github: string | null
    school: string | null
    major: string | null
    language: string | null
    accepted_number: number | null
    total_score: number | null
    total_practice_score: number | null
    submission_number: number | null
    rating: number | null
    username: string | null
  }

  export type UserProfileCountAggregateOutputType = {
    id: number
    real_name: number
    avatar: number
    blog: number
    github: number
    school: number
    major: number
    language: number
    accepted_number: number
    total_score: number
    total_practice_score: number
    submission_number: number
    rating: number
    username: number
    _all: number
  }


  export type UserProfileAvgAggregateInputType = {
    accepted_number?: true
    total_score?: true
    total_practice_score?: true
    submission_number?: true
    rating?: true
  }

  export type UserProfileSumAggregateInputType = {
    accepted_number?: true
    total_score?: true
    total_practice_score?: true
    submission_number?: true
    rating?: true
  }

  export type UserProfileMinAggregateInputType = {
    id?: true
    real_name?: true
    avatar?: true
    blog?: true
    github?: true
    school?: true
    major?: true
    language?: true
    accepted_number?: true
    total_score?: true
    total_practice_score?: true
    submission_number?: true
    rating?: true
    username?: true
  }

  export type UserProfileMaxAggregateInputType = {
    id?: true
    real_name?: true
    avatar?: true
    blog?: true
    github?: true
    school?: true
    major?: true
    language?: true
    accepted_number?: true
    total_score?: true
    total_practice_score?: true
    submission_number?: true
    rating?: true
    username?: true
  }

  export type UserProfileCountAggregateInputType = {
    id?: true
    real_name?: true
    avatar?: true
    blog?: true
    github?: true
    school?: true
    major?: true
    language?: true
    accepted_number?: true
    total_score?: true
    total_practice_score?: true
    submission_number?: true
    rating?: true
    username?: true
    _all?: true
  }

  export type UserProfileAggregateArgs = {
    /**
     * Filter which UserProfile to aggregate.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: Enumerable<UserProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProfiles
    **/
    _count?: true | UserProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProfileMaxAggregateInputType
  }

  export type GetUserProfileAggregateType<T extends UserProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProfile[P]>
      : GetScalarType<T[P], AggregateUserProfile[P]>
  }




  export type UserProfileGroupByArgs = {
    where?: UserProfileWhereInput
    orderBy?: Enumerable<UserProfileOrderByWithAggregationInput>
    by: UserProfileScalarFieldEnum[]
    having?: UserProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProfileCountAggregateInputType | true
    _avg?: UserProfileAvgAggregateInputType
    _sum?: UserProfileSumAggregateInputType
    _min?: UserProfileMinAggregateInputType
    _max?: UserProfileMaxAggregateInputType
  }


  export type UserProfileGroupByOutputType = {
    id: string
    real_name: string | null
    avatar: string | null
    blog: string | null
    github: string | null
    school: string | null
    major: string | null
    language: string | null
    accepted_number: number | null
    total_score: number | null
    total_practice_score: number | null
    submission_number: number | null
    rating: number | null
    username: string
    _count: UserProfileCountAggregateOutputType | null
    _avg: UserProfileAvgAggregateOutputType | null
    _sum: UserProfileSumAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  type GetUserProfileGroupByPayload<T extends UserProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
        }
      >
    >


  export type UserProfileSelect = {
    id?: boolean
    real_name?: boolean
    avatar?: boolean
    blog?: boolean
    github?: boolean
    school?: boolean
    major?: boolean
    language?: boolean
    accepted_number?: boolean
    total_score?: boolean
    total_practice_score?: boolean
    submission_number?: boolean
    rating?: boolean
    username?: boolean
    user?: boolean | UserArgs
  }


  export type UserProfileInclude = {
    user?: boolean | UserArgs
  }

  export type UserProfileGetPayload<S extends boolean | null | undefined | UserProfileArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserProfile :
    S extends undefined ? never :
    S extends { include: any } & (UserProfileArgs | UserProfileFindManyArgs)
    ? UserProfile  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserProfileArgs | UserProfileFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof UserProfile ? UserProfile[P] : never
  } 
      : UserProfile


  type UserProfileCountArgs = 
    Omit<UserProfileFindManyArgs, 'select' | 'include'> & {
      select?: UserProfileCountAggregateInputType | true
    }

  export interface UserProfileDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UserProfile that matches the filter.
     * @param {UserProfileFindUniqueArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserProfileFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserProfileFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserProfile'> extends True ? Prisma__UserProfileClient<UserProfileGetPayload<T>> : Prisma__UserProfileClient<UserProfileGetPayload<T> | null, null>

    /**
     * Find one UserProfile that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserProfileFindUniqueOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserProfileFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserProfileFindUniqueOrThrowArgs>
    ): Prisma__UserProfileClient<UserProfileGetPayload<T>>

    /**
     * Find the first UserProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserProfileFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserProfileFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserProfile'> extends True ? Prisma__UserProfileClient<UserProfileGetPayload<T>> : Prisma__UserProfileClient<UserProfileGetPayload<T> | null, null>

    /**
     * Find the first UserProfile that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserProfileFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserProfileFindFirstOrThrowArgs>
    ): Prisma__UserProfileClient<UserProfileGetPayload<T>>

    /**
     * Find zero or more UserProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfiles
     * const userProfiles = await prisma.userProfile.findMany()
     * 
     * // Get first 10 UserProfiles
     * const userProfiles = await prisma.userProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserProfileFindManyArgs>(
      args?: SelectSubset<T, UserProfileFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserProfileGetPayload<T>>>

    /**
     * Create a UserProfile.
     * @param {UserProfileCreateArgs} args - Arguments to create a UserProfile.
     * @example
     * // Create one UserProfile
     * const UserProfile = await prisma.userProfile.create({
     *   data: {
     *     // ... data to create a UserProfile
     *   }
     * })
     * 
    **/
    create<T extends UserProfileCreateArgs>(
      args: SelectSubset<T, UserProfileCreateArgs>
    ): Prisma__UserProfileClient<UserProfileGetPayload<T>>

    /**
     * Create many UserProfiles.
     *     @param {UserProfileCreateManyArgs} args - Arguments to create many UserProfiles.
     *     @example
     *     // Create many UserProfiles
     *     const userProfile = await prisma.userProfile.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserProfileCreateManyArgs>(
      args?: SelectSubset<T, UserProfileCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserProfile.
     * @param {UserProfileDeleteArgs} args - Arguments to delete one UserProfile.
     * @example
     * // Delete one UserProfile
     * const UserProfile = await prisma.userProfile.delete({
     *   where: {
     *     // ... filter to delete one UserProfile
     *   }
     * })
     * 
    **/
    delete<T extends UserProfileDeleteArgs>(
      args: SelectSubset<T, UserProfileDeleteArgs>
    ): Prisma__UserProfileClient<UserProfileGetPayload<T>>

    /**
     * Update one UserProfile.
     * @param {UserProfileUpdateArgs} args - Arguments to update one UserProfile.
     * @example
     * // Update one UserProfile
     * const userProfile = await prisma.userProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserProfileUpdateArgs>(
      args: SelectSubset<T, UserProfileUpdateArgs>
    ): Prisma__UserProfileClient<UserProfileGetPayload<T>>

    /**
     * Delete zero or more UserProfiles.
     * @param {UserProfileDeleteManyArgs} args - Arguments to filter UserProfiles to delete.
     * @example
     * // Delete a few UserProfiles
     * const { count } = await prisma.userProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserProfileDeleteManyArgs>(
      args?: SelectSubset<T, UserProfileDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserProfileUpdateManyArgs>(
      args: SelectSubset<T, UserProfileUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserProfile.
     * @param {UserProfileUpsertArgs} args - Arguments to update or create a UserProfile.
     * @example
     * // Update or create a UserProfile
     * const userProfile = await prisma.userProfile.upsert({
     *   create: {
     *     // ... data to create a UserProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfile we want to update
     *   }
     * })
    **/
    upsert<T extends UserProfileUpsertArgs>(
      args: SelectSubset<T, UserProfileUpsertArgs>
    ): Prisma__UserProfileClient<UserProfileGetPayload<T>>

    /**
     * Count the number of UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileCountArgs} args - Arguments to filter UserProfiles to count.
     * @example
     * // Count the number of UserProfiles
     * const count = await prisma.userProfile.count({
     *   where: {
     *     // ... the filter for the UserProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserProfileCountArgs>(
      args?: Subset<T, UserProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProfileAggregateArgs>(args: Subset<T, UserProfileAggregateArgs>): Prisma.PrismaPromise<GetUserProfileAggregateType<T>>

    /**
     * Group by UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProfileGroupByArgs['orderBy'] }
        : { orderBy?: UserProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserProfileClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserProfile base type for findUnique actions
   */
  export type UserProfileFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findUnique
   */
  export interface UserProfileFindUniqueArgs extends UserProfileFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserProfile findUniqueOrThrow
   */
  export type UserProfileFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }


  /**
   * UserProfile base type for findFirst actions
   */
  export type UserProfileFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: Enumerable<UserProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: Enumerable<UserProfileScalarFieldEnum>
  }

  /**
   * UserProfile findFirst
   */
  export interface UserProfileFindFirstArgs extends UserProfileFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserProfile findFirstOrThrow
   */
  export type UserProfileFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: Enumerable<UserProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: Enumerable<UserProfileScalarFieldEnum>
  }


  /**
   * UserProfile findMany
   */
  export type UserProfileFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude | null
    /**
     * Filter, which UserProfiles to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: Enumerable<UserProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    distinct?: Enumerable<UserProfileScalarFieldEnum>
  }


  /**
   * UserProfile create
   */
  export type UserProfileCreateArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude | null
    /**
     * The data needed to create a UserProfile.
     */
    data: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
  }


  /**
   * UserProfile createMany
   */
  export type UserProfileCreateManyArgs = {
    /**
     * The data used to create many UserProfiles.
     */
    data: Enumerable<UserProfileCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserProfile update
   */
  export type UserProfileUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude | null
    /**
     * The data needed to update a UserProfile.
     */
    data: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
    /**
     * Choose, which UserProfile to update.
     */
    where: UserProfileWhereUniqueInput
  }


  /**
   * UserProfile updateMany
   */
  export type UserProfileUpdateManyArgs = {
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
  }


  /**
   * UserProfile upsert
   */
  export type UserProfileUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude | null
    /**
     * The filter to search for the UserProfile to update in case it exists.
     */
    where: UserProfileWhereUniqueInput
    /**
     * In case the UserProfile found by the `where` argument doesn't exist, create a new UserProfile with this data.
     */
    create: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
    /**
     * In case the UserProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
  }


  /**
   * UserProfile delete
   */
  export type UserProfileDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude | null
    /**
     * Filter which UserProfile to delete.
     */
    where: UserProfileWhereUniqueInput
  }


  /**
   * UserProfile deleteMany
   */
  export type UserProfileDeleteManyArgs = {
    /**
     * Filter which UserProfiles to delete
     */
    where?: UserProfileWhereInput
  }


  /**
   * UserProfile without action
   */
  export type UserProfileArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude | null
  }



  /**
   * Model CodingProblemCategory
   */


  export type AggregateCodingProblemCategory = {
    _count: CodingProblemCategoryCountAggregateOutputType | null
    _avg: CodingProblemCategoryAvgAggregateOutputType | null
    _sum: CodingProblemCategorySumAggregateOutputType | null
    _min: CodingProblemCategoryMinAggregateOutputType | null
    _max: CodingProblemCategoryMaxAggregateOutputType | null
  }

  export type CodingProblemCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type CodingProblemCategorySumAggregateOutputType = {
    id: number | null
  }

  export type CodingProblemCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type CodingProblemCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type CodingProblemCategoryCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type CodingProblemCategoryAvgAggregateInputType = {
    id?: true
  }

  export type CodingProblemCategorySumAggregateInputType = {
    id?: true
  }

  export type CodingProblemCategoryMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type CodingProblemCategoryMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type CodingProblemCategoryCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type CodingProblemCategoryAggregateArgs = {
    /**
     * Filter which CodingProblemCategory to aggregate.
     */
    where?: CodingProblemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodingProblemCategories to fetch.
     */
    orderBy?: Enumerable<CodingProblemCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CodingProblemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodingProblemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodingProblemCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CodingProblemCategories
    **/
    _count?: true | CodingProblemCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CodingProblemCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CodingProblemCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CodingProblemCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CodingProblemCategoryMaxAggregateInputType
  }

  export type GetCodingProblemCategoryAggregateType<T extends CodingProblemCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCodingProblemCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCodingProblemCategory[P]>
      : GetScalarType<T[P], AggregateCodingProblemCategory[P]>
  }




  export type CodingProblemCategoryGroupByArgs = {
    where?: CodingProblemCategoryWhereInput
    orderBy?: Enumerable<CodingProblemCategoryOrderByWithAggregationInput>
    by: CodingProblemCategoryScalarFieldEnum[]
    having?: CodingProblemCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CodingProblemCategoryCountAggregateInputType | true
    _avg?: CodingProblemCategoryAvgAggregateInputType
    _sum?: CodingProblemCategorySumAggregateInputType
    _min?: CodingProblemCategoryMinAggregateInputType
    _max?: CodingProblemCategoryMaxAggregateInputType
  }


  export type CodingProblemCategoryGroupByOutputType = {
    id: number
    name: string
    _count: CodingProblemCategoryCountAggregateOutputType | null
    _avg: CodingProblemCategoryAvgAggregateOutputType | null
    _sum: CodingProblemCategorySumAggregateOutputType | null
    _min: CodingProblemCategoryMinAggregateOutputType | null
    _max: CodingProblemCategoryMaxAggregateOutputType | null
  }

  type GetCodingProblemCategoryGroupByPayload<T extends CodingProblemCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CodingProblemCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CodingProblemCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CodingProblemCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CodingProblemCategoryGroupByOutputType[P]>
        }
      >
    >


  export type CodingProblemCategorySelect = {
    id?: boolean
    name?: boolean
    codingProblems?: boolean | CodingProblemCategory$codingProblemsArgs
    _count?: boolean | CodingProblemCategoryCountOutputTypeArgs
  }


  export type CodingProblemCategoryInclude = {
    codingProblems?: boolean | CodingProblemCategory$codingProblemsArgs
    _count?: boolean | CodingProblemCategoryCountOutputTypeArgs
  }

  export type CodingProblemCategoryGetPayload<S extends boolean | null | undefined | CodingProblemCategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CodingProblemCategory :
    S extends undefined ? never :
    S extends { include: any } & (CodingProblemCategoryArgs | CodingProblemCategoryFindManyArgs)
    ? CodingProblemCategory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'codingProblems' ? Array < CodingProblemGetPayload<S['include'][P]>>  :
        P extends '_count' ? CodingProblemCategoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CodingProblemCategoryArgs | CodingProblemCategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'codingProblems' ? Array < CodingProblemGetPayload<S['select'][P]>>  :
        P extends '_count' ? CodingProblemCategoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof CodingProblemCategory ? CodingProblemCategory[P] : never
  } 
      : CodingProblemCategory


  type CodingProblemCategoryCountArgs = 
    Omit<CodingProblemCategoryFindManyArgs, 'select' | 'include'> & {
      select?: CodingProblemCategoryCountAggregateInputType | true
    }

  export interface CodingProblemCategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one CodingProblemCategory that matches the filter.
     * @param {CodingProblemCategoryFindUniqueArgs} args - Arguments to find a CodingProblemCategory
     * @example
     * // Get one CodingProblemCategory
     * const codingProblemCategory = await prisma.codingProblemCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CodingProblemCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CodingProblemCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CodingProblemCategory'> extends True ? Prisma__CodingProblemCategoryClient<CodingProblemCategoryGetPayload<T>> : Prisma__CodingProblemCategoryClient<CodingProblemCategoryGetPayload<T> | null, null>

    /**
     * Find one CodingProblemCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CodingProblemCategoryFindUniqueOrThrowArgs} args - Arguments to find a CodingProblemCategory
     * @example
     * // Get one CodingProblemCategory
     * const codingProblemCategory = await prisma.codingProblemCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CodingProblemCategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CodingProblemCategoryFindUniqueOrThrowArgs>
    ): Prisma__CodingProblemCategoryClient<CodingProblemCategoryGetPayload<T>>

    /**
     * Find the first CodingProblemCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodingProblemCategoryFindFirstArgs} args - Arguments to find a CodingProblemCategory
     * @example
     * // Get one CodingProblemCategory
     * const codingProblemCategory = await prisma.codingProblemCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CodingProblemCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CodingProblemCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CodingProblemCategory'> extends True ? Prisma__CodingProblemCategoryClient<CodingProblemCategoryGetPayload<T>> : Prisma__CodingProblemCategoryClient<CodingProblemCategoryGetPayload<T> | null, null>

    /**
     * Find the first CodingProblemCategory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodingProblemCategoryFindFirstOrThrowArgs} args - Arguments to find a CodingProblemCategory
     * @example
     * // Get one CodingProblemCategory
     * const codingProblemCategory = await prisma.codingProblemCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CodingProblemCategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CodingProblemCategoryFindFirstOrThrowArgs>
    ): Prisma__CodingProblemCategoryClient<CodingProblemCategoryGetPayload<T>>

    /**
     * Find zero or more CodingProblemCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodingProblemCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CodingProblemCategories
     * const codingProblemCategories = await prisma.codingProblemCategory.findMany()
     * 
     * // Get first 10 CodingProblemCategories
     * const codingProblemCategories = await prisma.codingProblemCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const codingProblemCategoryWithIdOnly = await prisma.codingProblemCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CodingProblemCategoryFindManyArgs>(
      args?: SelectSubset<T, CodingProblemCategoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<CodingProblemCategoryGetPayload<T>>>

    /**
     * Create a CodingProblemCategory.
     * @param {CodingProblemCategoryCreateArgs} args - Arguments to create a CodingProblemCategory.
     * @example
     * // Create one CodingProblemCategory
     * const CodingProblemCategory = await prisma.codingProblemCategory.create({
     *   data: {
     *     // ... data to create a CodingProblemCategory
     *   }
     * })
     * 
    **/
    create<T extends CodingProblemCategoryCreateArgs>(
      args: SelectSubset<T, CodingProblemCategoryCreateArgs>
    ): Prisma__CodingProblemCategoryClient<CodingProblemCategoryGetPayload<T>>

    /**
     * Create many CodingProblemCategories.
     *     @param {CodingProblemCategoryCreateManyArgs} args - Arguments to create many CodingProblemCategories.
     *     @example
     *     // Create many CodingProblemCategories
     *     const codingProblemCategory = await prisma.codingProblemCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CodingProblemCategoryCreateManyArgs>(
      args?: SelectSubset<T, CodingProblemCategoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CodingProblemCategory.
     * @param {CodingProblemCategoryDeleteArgs} args - Arguments to delete one CodingProblemCategory.
     * @example
     * // Delete one CodingProblemCategory
     * const CodingProblemCategory = await prisma.codingProblemCategory.delete({
     *   where: {
     *     // ... filter to delete one CodingProblemCategory
     *   }
     * })
     * 
    **/
    delete<T extends CodingProblemCategoryDeleteArgs>(
      args: SelectSubset<T, CodingProblemCategoryDeleteArgs>
    ): Prisma__CodingProblemCategoryClient<CodingProblemCategoryGetPayload<T>>

    /**
     * Update one CodingProblemCategory.
     * @param {CodingProblemCategoryUpdateArgs} args - Arguments to update one CodingProblemCategory.
     * @example
     * // Update one CodingProblemCategory
     * const codingProblemCategory = await prisma.codingProblemCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CodingProblemCategoryUpdateArgs>(
      args: SelectSubset<T, CodingProblemCategoryUpdateArgs>
    ): Prisma__CodingProblemCategoryClient<CodingProblemCategoryGetPayload<T>>

    /**
     * Delete zero or more CodingProblemCategories.
     * @param {CodingProblemCategoryDeleteManyArgs} args - Arguments to filter CodingProblemCategories to delete.
     * @example
     * // Delete a few CodingProblemCategories
     * const { count } = await prisma.codingProblemCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CodingProblemCategoryDeleteManyArgs>(
      args?: SelectSubset<T, CodingProblemCategoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CodingProblemCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodingProblemCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CodingProblemCategories
     * const codingProblemCategory = await prisma.codingProblemCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CodingProblemCategoryUpdateManyArgs>(
      args: SelectSubset<T, CodingProblemCategoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CodingProblemCategory.
     * @param {CodingProblemCategoryUpsertArgs} args - Arguments to update or create a CodingProblemCategory.
     * @example
     * // Update or create a CodingProblemCategory
     * const codingProblemCategory = await prisma.codingProblemCategory.upsert({
     *   create: {
     *     // ... data to create a CodingProblemCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CodingProblemCategory we want to update
     *   }
     * })
    **/
    upsert<T extends CodingProblemCategoryUpsertArgs>(
      args: SelectSubset<T, CodingProblemCategoryUpsertArgs>
    ): Prisma__CodingProblemCategoryClient<CodingProblemCategoryGetPayload<T>>

    /**
     * Count the number of CodingProblemCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodingProblemCategoryCountArgs} args - Arguments to filter CodingProblemCategories to count.
     * @example
     * // Count the number of CodingProblemCategories
     * const count = await prisma.codingProblemCategory.count({
     *   where: {
     *     // ... the filter for the CodingProblemCategories we want to count
     *   }
     * })
    **/
    count<T extends CodingProblemCategoryCountArgs>(
      args?: Subset<T, CodingProblemCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CodingProblemCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CodingProblemCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodingProblemCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CodingProblemCategoryAggregateArgs>(args: Subset<T, CodingProblemCategoryAggregateArgs>): Prisma.PrismaPromise<GetCodingProblemCategoryAggregateType<T>>

    /**
     * Group by CodingProblemCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodingProblemCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CodingProblemCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CodingProblemCategoryGroupByArgs['orderBy'] }
        : { orderBy?: CodingProblemCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CodingProblemCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCodingProblemCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CodingProblemCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CodingProblemCategoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    codingProblems<T extends CodingProblemCategory$codingProblemsArgs= {}>(args?: Subset<T, CodingProblemCategory$codingProblemsArgs>): Prisma.PrismaPromise<Array<CodingProblemGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CodingProblemCategory base type for findUnique actions
   */
  export type CodingProblemCategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CodingProblemCategory
     */
    select?: CodingProblemCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemCategoryInclude | null
    /**
     * Filter, which CodingProblemCategory to fetch.
     */
    where: CodingProblemCategoryWhereUniqueInput
  }

  /**
   * CodingProblemCategory findUnique
   */
  export interface CodingProblemCategoryFindUniqueArgs extends CodingProblemCategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CodingProblemCategory findUniqueOrThrow
   */
  export type CodingProblemCategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CodingProblemCategory
     */
    select?: CodingProblemCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemCategoryInclude | null
    /**
     * Filter, which CodingProblemCategory to fetch.
     */
    where: CodingProblemCategoryWhereUniqueInput
  }


  /**
   * CodingProblemCategory base type for findFirst actions
   */
  export type CodingProblemCategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CodingProblemCategory
     */
    select?: CodingProblemCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemCategoryInclude | null
    /**
     * Filter, which CodingProblemCategory to fetch.
     */
    where?: CodingProblemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodingProblemCategories to fetch.
     */
    orderBy?: Enumerable<CodingProblemCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodingProblemCategories.
     */
    cursor?: CodingProblemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodingProblemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodingProblemCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodingProblemCategories.
     */
    distinct?: Enumerable<CodingProblemCategoryScalarFieldEnum>
  }

  /**
   * CodingProblemCategory findFirst
   */
  export interface CodingProblemCategoryFindFirstArgs extends CodingProblemCategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CodingProblemCategory findFirstOrThrow
   */
  export type CodingProblemCategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CodingProblemCategory
     */
    select?: CodingProblemCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemCategoryInclude | null
    /**
     * Filter, which CodingProblemCategory to fetch.
     */
    where?: CodingProblemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodingProblemCategories to fetch.
     */
    orderBy?: Enumerable<CodingProblemCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodingProblemCategories.
     */
    cursor?: CodingProblemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodingProblemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodingProblemCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodingProblemCategories.
     */
    distinct?: Enumerable<CodingProblemCategoryScalarFieldEnum>
  }


  /**
   * CodingProblemCategory findMany
   */
  export type CodingProblemCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the CodingProblemCategory
     */
    select?: CodingProblemCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemCategoryInclude | null
    /**
     * Filter, which CodingProblemCategories to fetch.
     */
    where?: CodingProblemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodingProblemCategories to fetch.
     */
    orderBy?: Enumerable<CodingProblemCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CodingProblemCategories.
     */
    cursor?: CodingProblemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodingProblemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodingProblemCategories.
     */
    skip?: number
    distinct?: Enumerable<CodingProblemCategoryScalarFieldEnum>
  }


  /**
   * CodingProblemCategory create
   */
  export type CodingProblemCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the CodingProblemCategory
     */
    select?: CodingProblemCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemCategoryInclude | null
    /**
     * The data needed to create a CodingProblemCategory.
     */
    data: XOR<CodingProblemCategoryCreateInput, CodingProblemCategoryUncheckedCreateInput>
  }


  /**
   * CodingProblemCategory createMany
   */
  export type CodingProblemCategoryCreateManyArgs = {
    /**
     * The data used to create many CodingProblemCategories.
     */
    data: Enumerable<CodingProblemCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CodingProblemCategory update
   */
  export type CodingProblemCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the CodingProblemCategory
     */
    select?: CodingProblemCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemCategoryInclude | null
    /**
     * The data needed to update a CodingProblemCategory.
     */
    data: XOR<CodingProblemCategoryUpdateInput, CodingProblemCategoryUncheckedUpdateInput>
    /**
     * Choose, which CodingProblemCategory to update.
     */
    where: CodingProblemCategoryWhereUniqueInput
  }


  /**
   * CodingProblemCategory updateMany
   */
  export type CodingProblemCategoryUpdateManyArgs = {
    /**
     * The data used to update CodingProblemCategories.
     */
    data: XOR<CodingProblemCategoryUpdateManyMutationInput, CodingProblemCategoryUncheckedUpdateManyInput>
    /**
     * Filter which CodingProblemCategories to update
     */
    where?: CodingProblemCategoryWhereInput
  }


  /**
   * CodingProblemCategory upsert
   */
  export type CodingProblemCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the CodingProblemCategory
     */
    select?: CodingProblemCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemCategoryInclude | null
    /**
     * The filter to search for the CodingProblemCategory to update in case it exists.
     */
    where: CodingProblemCategoryWhereUniqueInput
    /**
     * In case the CodingProblemCategory found by the `where` argument doesn't exist, create a new CodingProblemCategory with this data.
     */
    create: XOR<CodingProblemCategoryCreateInput, CodingProblemCategoryUncheckedCreateInput>
    /**
     * In case the CodingProblemCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CodingProblemCategoryUpdateInput, CodingProblemCategoryUncheckedUpdateInput>
  }


  /**
   * CodingProblemCategory delete
   */
  export type CodingProblemCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the CodingProblemCategory
     */
    select?: CodingProblemCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemCategoryInclude | null
    /**
     * Filter which CodingProblemCategory to delete.
     */
    where: CodingProblemCategoryWhereUniqueInput
  }


  /**
   * CodingProblemCategory deleteMany
   */
  export type CodingProblemCategoryDeleteManyArgs = {
    /**
     * Filter which CodingProblemCategories to delete
     */
    where?: CodingProblemCategoryWhereInput
  }


  /**
   * CodingProblemCategory.codingProblems
   */
  export type CodingProblemCategory$codingProblemsArgs = {
    /**
     * Select specific fields to fetch from the CodingProblem
     */
    select?: CodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemInclude | null
    where?: CodingProblemWhereInput
    orderBy?: Enumerable<CodingProblemOrderByWithRelationInput>
    cursor?: CodingProblemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CodingProblemScalarFieldEnum>
  }


  /**
   * CodingProblemCategory without action
   */
  export type CodingProblemCategoryArgs = {
    /**
     * Select specific fields to fetch from the CodingProblemCategory
     */
    select?: CodingProblemCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemCategoryInclude | null
  }



  /**
   * Model CodingProblemTag
   */


  export type AggregateCodingProblemTag = {
    _count: CodingProblemTagCountAggregateOutputType | null
    _avg: CodingProblemTagAvgAggregateOutputType | null
    _sum: CodingProblemTagSumAggregateOutputType | null
    _min: CodingProblemTagMinAggregateOutputType | null
    _max: CodingProblemTagMaxAggregateOutputType | null
  }

  export type CodingProblemTagAvgAggregateOutputType = {
    id: number | null
  }

  export type CodingProblemTagSumAggregateOutputType = {
    id: number | null
  }

  export type CodingProblemTagMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type CodingProblemTagMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type CodingProblemTagCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type CodingProblemTagAvgAggregateInputType = {
    id?: true
  }

  export type CodingProblemTagSumAggregateInputType = {
    id?: true
  }

  export type CodingProblemTagMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type CodingProblemTagMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type CodingProblemTagCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type CodingProblemTagAggregateArgs = {
    /**
     * Filter which CodingProblemTag to aggregate.
     */
    where?: CodingProblemTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodingProblemTags to fetch.
     */
    orderBy?: Enumerable<CodingProblemTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CodingProblemTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodingProblemTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodingProblemTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CodingProblemTags
    **/
    _count?: true | CodingProblemTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CodingProblemTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CodingProblemTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CodingProblemTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CodingProblemTagMaxAggregateInputType
  }

  export type GetCodingProblemTagAggregateType<T extends CodingProblemTagAggregateArgs> = {
        [P in keyof T & keyof AggregateCodingProblemTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCodingProblemTag[P]>
      : GetScalarType<T[P], AggregateCodingProblemTag[P]>
  }




  export type CodingProblemTagGroupByArgs = {
    where?: CodingProblemTagWhereInput
    orderBy?: Enumerable<CodingProblemTagOrderByWithAggregationInput>
    by: CodingProblemTagScalarFieldEnum[]
    having?: CodingProblemTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CodingProblemTagCountAggregateInputType | true
    _avg?: CodingProblemTagAvgAggregateInputType
    _sum?: CodingProblemTagSumAggregateInputType
    _min?: CodingProblemTagMinAggregateInputType
    _max?: CodingProblemTagMaxAggregateInputType
  }


  export type CodingProblemTagGroupByOutputType = {
    id: number
    name: string
    _count: CodingProblemTagCountAggregateOutputType | null
    _avg: CodingProblemTagAvgAggregateOutputType | null
    _sum: CodingProblemTagSumAggregateOutputType | null
    _min: CodingProblemTagMinAggregateOutputType | null
    _max: CodingProblemTagMaxAggregateOutputType | null
  }

  type GetCodingProblemTagGroupByPayload<T extends CodingProblemTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CodingProblemTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CodingProblemTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CodingProblemTagGroupByOutputType[P]>
            : GetScalarType<T[P], CodingProblemTagGroupByOutputType[P]>
        }
      >
    >


  export type CodingProblemTagSelect = {
    id?: boolean
    name?: boolean
    codingProblems?: boolean | CodingProblemTag$codingProblemsArgs
    _count?: boolean | CodingProblemTagCountOutputTypeArgs
  }


  export type CodingProblemTagInclude = {
    codingProblems?: boolean | CodingProblemTag$codingProblemsArgs
    _count?: boolean | CodingProblemTagCountOutputTypeArgs
  }

  export type CodingProblemTagGetPayload<S extends boolean | null | undefined | CodingProblemTagArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CodingProblemTag :
    S extends undefined ? never :
    S extends { include: any } & (CodingProblemTagArgs | CodingProblemTagFindManyArgs)
    ? CodingProblemTag  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'codingProblems' ? Array < TagCodingProblemGetPayload<S['include'][P]>>  :
        P extends '_count' ? CodingProblemTagCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CodingProblemTagArgs | CodingProblemTagFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'codingProblems' ? Array < TagCodingProblemGetPayload<S['select'][P]>>  :
        P extends '_count' ? CodingProblemTagCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof CodingProblemTag ? CodingProblemTag[P] : never
  } 
      : CodingProblemTag


  type CodingProblemTagCountArgs = 
    Omit<CodingProblemTagFindManyArgs, 'select' | 'include'> & {
      select?: CodingProblemTagCountAggregateInputType | true
    }

  export interface CodingProblemTagDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one CodingProblemTag that matches the filter.
     * @param {CodingProblemTagFindUniqueArgs} args - Arguments to find a CodingProblemTag
     * @example
     * // Get one CodingProblemTag
     * const codingProblemTag = await prisma.codingProblemTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CodingProblemTagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CodingProblemTagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CodingProblemTag'> extends True ? Prisma__CodingProblemTagClient<CodingProblemTagGetPayload<T>> : Prisma__CodingProblemTagClient<CodingProblemTagGetPayload<T> | null, null>

    /**
     * Find one CodingProblemTag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CodingProblemTagFindUniqueOrThrowArgs} args - Arguments to find a CodingProblemTag
     * @example
     * // Get one CodingProblemTag
     * const codingProblemTag = await prisma.codingProblemTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CodingProblemTagFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CodingProblemTagFindUniqueOrThrowArgs>
    ): Prisma__CodingProblemTagClient<CodingProblemTagGetPayload<T>>

    /**
     * Find the first CodingProblemTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodingProblemTagFindFirstArgs} args - Arguments to find a CodingProblemTag
     * @example
     * // Get one CodingProblemTag
     * const codingProblemTag = await prisma.codingProblemTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CodingProblemTagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CodingProblemTagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CodingProblemTag'> extends True ? Prisma__CodingProblemTagClient<CodingProblemTagGetPayload<T>> : Prisma__CodingProblemTagClient<CodingProblemTagGetPayload<T> | null, null>

    /**
     * Find the first CodingProblemTag that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodingProblemTagFindFirstOrThrowArgs} args - Arguments to find a CodingProblemTag
     * @example
     * // Get one CodingProblemTag
     * const codingProblemTag = await prisma.codingProblemTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CodingProblemTagFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CodingProblemTagFindFirstOrThrowArgs>
    ): Prisma__CodingProblemTagClient<CodingProblemTagGetPayload<T>>

    /**
     * Find zero or more CodingProblemTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodingProblemTagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CodingProblemTags
     * const codingProblemTags = await prisma.codingProblemTag.findMany()
     * 
     * // Get first 10 CodingProblemTags
     * const codingProblemTags = await prisma.codingProblemTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const codingProblemTagWithIdOnly = await prisma.codingProblemTag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CodingProblemTagFindManyArgs>(
      args?: SelectSubset<T, CodingProblemTagFindManyArgs>
    ): Prisma.PrismaPromise<Array<CodingProblemTagGetPayload<T>>>

    /**
     * Create a CodingProblemTag.
     * @param {CodingProblemTagCreateArgs} args - Arguments to create a CodingProblemTag.
     * @example
     * // Create one CodingProblemTag
     * const CodingProblemTag = await prisma.codingProblemTag.create({
     *   data: {
     *     // ... data to create a CodingProblemTag
     *   }
     * })
     * 
    **/
    create<T extends CodingProblemTagCreateArgs>(
      args: SelectSubset<T, CodingProblemTagCreateArgs>
    ): Prisma__CodingProblemTagClient<CodingProblemTagGetPayload<T>>

    /**
     * Create many CodingProblemTags.
     *     @param {CodingProblemTagCreateManyArgs} args - Arguments to create many CodingProblemTags.
     *     @example
     *     // Create many CodingProblemTags
     *     const codingProblemTag = await prisma.codingProblemTag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CodingProblemTagCreateManyArgs>(
      args?: SelectSubset<T, CodingProblemTagCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CodingProblemTag.
     * @param {CodingProblemTagDeleteArgs} args - Arguments to delete one CodingProblemTag.
     * @example
     * // Delete one CodingProblemTag
     * const CodingProblemTag = await prisma.codingProblemTag.delete({
     *   where: {
     *     // ... filter to delete one CodingProblemTag
     *   }
     * })
     * 
    **/
    delete<T extends CodingProblemTagDeleteArgs>(
      args: SelectSubset<T, CodingProblemTagDeleteArgs>
    ): Prisma__CodingProblemTagClient<CodingProblemTagGetPayload<T>>

    /**
     * Update one CodingProblemTag.
     * @param {CodingProblemTagUpdateArgs} args - Arguments to update one CodingProblemTag.
     * @example
     * // Update one CodingProblemTag
     * const codingProblemTag = await prisma.codingProblemTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CodingProblemTagUpdateArgs>(
      args: SelectSubset<T, CodingProblemTagUpdateArgs>
    ): Prisma__CodingProblemTagClient<CodingProblemTagGetPayload<T>>

    /**
     * Delete zero or more CodingProblemTags.
     * @param {CodingProblemTagDeleteManyArgs} args - Arguments to filter CodingProblemTags to delete.
     * @example
     * // Delete a few CodingProblemTags
     * const { count } = await prisma.codingProblemTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CodingProblemTagDeleteManyArgs>(
      args?: SelectSubset<T, CodingProblemTagDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CodingProblemTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodingProblemTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CodingProblemTags
     * const codingProblemTag = await prisma.codingProblemTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CodingProblemTagUpdateManyArgs>(
      args: SelectSubset<T, CodingProblemTagUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CodingProblemTag.
     * @param {CodingProblemTagUpsertArgs} args - Arguments to update or create a CodingProblemTag.
     * @example
     * // Update or create a CodingProblemTag
     * const codingProblemTag = await prisma.codingProblemTag.upsert({
     *   create: {
     *     // ... data to create a CodingProblemTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CodingProblemTag we want to update
     *   }
     * })
    **/
    upsert<T extends CodingProblemTagUpsertArgs>(
      args: SelectSubset<T, CodingProblemTagUpsertArgs>
    ): Prisma__CodingProblemTagClient<CodingProblemTagGetPayload<T>>

    /**
     * Count the number of CodingProblemTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodingProblemTagCountArgs} args - Arguments to filter CodingProblemTags to count.
     * @example
     * // Count the number of CodingProblemTags
     * const count = await prisma.codingProblemTag.count({
     *   where: {
     *     // ... the filter for the CodingProblemTags we want to count
     *   }
     * })
    **/
    count<T extends CodingProblemTagCountArgs>(
      args?: Subset<T, CodingProblemTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CodingProblemTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CodingProblemTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodingProblemTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CodingProblemTagAggregateArgs>(args: Subset<T, CodingProblemTagAggregateArgs>): Prisma.PrismaPromise<GetCodingProblemTagAggregateType<T>>

    /**
     * Group by CodingProblemTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodingProblemTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CodingProblemTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CodingProblemTagGroupByArgs['orderBy'] }
        : { orderBy?: CodingProblemTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CodingProblemTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCodingProblemTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CodingProblemTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CodingProblemTagClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    codingProblems<T extends CodingProblemTag$codingProblemsArgs= {}>(args?: Subset<T, CodingProblemTag$codingProblemsArgs>): Prisma.PrismaPromise<Array<TagCodingProblemGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CodingProblemTag base type for findUnique actions
   */
  export type CodingProblemTagFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CodingProblemTag
     */
    select?: CodingProblemTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemTagInclude | null
    /**
     * Filter, which CodingProblemTag to fetch.
     */
    where: CodingProblemTagWhereUniqueInput
  }

  /**
   * CodingProblemTag findUnique
   */
  export interface CodingProblemTagFindUniqueArgs extends CodingProblemTagFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CodingProblemTag findUniqueOrThrow
   */
  export type CodingProblemTagFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CodingProblemTag
     */
    select?: CodingProblemTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemTagInclude | null
    /**
     * Filter, which CodingProblemTag to fetch.
     */
    where: CodingProblemTagWhereUniqueInput
  }


  /**
   * CodingProblemTag base type for findFirst actions
   */
  export type CodingProblemTagFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CodingProblemTag
     */
    select?: CodingProblemTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemTagInclude | null
    /**
     * Filter, which CodingProblemTag to fetch.
     */
    where?: CodingProblemTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodingProblemTags to fetch.
     */
    orderBy?: Enumerable<CodingProblemTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodingProblemTags.
     */
    cursor?: CodingProblemTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodingProblemTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodingProblemTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodingProblemTags.
     */
    distinct?: Enumerable<CodingProblemTagScalarFieldEnum>
  }

  /**
   * CodingProblemTag findFirst
   */
  export interface CodingProblemTagFindFirstArgs extends CodingProblemTagFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CodingProblemTag findFirstOrThrow
   */
  export type CodingProblemTagFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CodingProblemTag
     */
    select?: CodingProblemTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemTagInclude | null
    /**
     * Filter, which CodingProblemTag to fetch.
     */
    where?: CodingProblemTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodingProblemTags to fetch.
     */
    orderBy?: Enumerable<CodingProblemTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodingProblemTags.
     */
    cursor?: CodingProblemTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodingProblemTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodingProblemTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodingProblemTags.
     */
    distinct?: Enumerable<CodingProblemTagScalarFieldEnum>
  }


  /**
   * CodingProblemTag findMany
   */
  export type CodingProblemTagFindManyArgs = {
    /**
     * Select specific fields to fetch from the CodingProblemTag
     */
    select?: CodingProblemTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemTagInclude | null
    /**
     * Filter, which CodingProblemTags to fetch.
     */
    where?: CodingProblemTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodingProblemTags to fetch.
     */
    orderBy?: Enumerable<CodingProblemTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CodingProblemTags.
     */
    cursor?: CodingProblemTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodingProblemTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodingProblemTags.
     */
    skip?: number
    distinct?: Enumerable<CodingProblemTagScalarFieldEnum>
  }


  /**
   * CodingProblemTag create
   */
  export type CodingProblemTagCreateArgs = {
    /**
     * Select specific fields to fetch from the CodingProblemTag
     */
    select?: CodingProblemTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemTagInclude | null
    /**
     * The data needed to create a CodingProblemTag.
     */
    data: XOR<CodingProblemTagCreateInput, CodingProblemTagUncheckedCreateInput>
  }


  /**
   * CodingProblemTag createMany
   */
  export type CodingProblemTagCreateManyArgs = {
    /**
     * The data used to create many CodingProblemTags.
     */
    data: Enumerable<CodingProblemTagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CodingProblemTag update
   */
  export type CodingProblemTagUpdateArgs = {
    /**
     * Select specific fields to fetch from the CodingProblemTag
     */
    select?: CodingProblemTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemTagInclude | null
    /**
     * The data needed to update a CodingProblemTag.
     */
    data: XOR<CodingProblemTagUpdateInput, CodingProblemTagUncheckedUpdateInput>
    /**
     * Choose, which CodingProblemTag to update.
     */
    where: CodingProblemTagWhereUniqueInput
  }


  /**
   * CodingProblemTag updateMany
   */
  export type CodingProblemTagUpdateManyArgs = {
    /**
     * The data used to update CodingProblemTags.
     */
    data: XOR<CodingProblemTagUpdateManyMutationInput, CodingProblemTagUncheckedUpdateManyInput>
    /**
     * Filter which CodingProblemTags to update
     */
    where?: CodingProblemTagWhereInput
  }


  /**
   * CodingProblemTag upsert
   */
  export type CodingProblemTagUpsertArgs = {
    /**
     * Select specific fields to fetch from the CodingProblemTag
     */
    select?: CodingProblemTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemTagInclude | null
    /**
     * The filter to search for the CodingProblemTag to update in case it exists.
     */
    where: CodingProblemTagWhereUniqueInput
    /**
     * In case the CodingProblemTag found by the `where` argument doesn't exist, create a new CodingProblemTag with this data.
     */
    create: XOR<CodingProblemTagCreateInput, CodingProblemTagUncheckedCreateInput>
    /**
     * In case the CodingProblemTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CodingProblemTagUpdateInput, CodingProblemTagUncheckedUpdateInput>
  }


  /**
   * CodingProblemTag delete
   */
  export type CodingProblemTagDeleteArgs = {
    /**
     * Select specific fields to fetch from the CodingProblemTag
     */
    select?: CodingProblemTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemTagInclude | null
    /**
     * Filter which CodingProblemTag to delete.
     */
    where: CodingProblemTagWhereUniqueInput
  }


  /**
   * CodingProblemTag deleteMany
   */
  export type CodingProblemTagDeleteManyArgs = {
    /**
     * Filter which CodingProblemTags to delete
     */
    where?: CodingProblemTagWhereInput
  }


  /**
   * CodingProblemTag.codingProblems
   */
  export type CodingProblemTag$codingProblemsArgs = {
    /**
     * Select specific fields to fetch from the TagCodingProblem
     */
    select?: TagCodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagCodingProblemInclude | null
    where?: TagCodingProblemWhereInput
    orderBy?: Enumerable<TagCodingProblemOrderByWithRelationInput>
    cursor?: TagCodingProblemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TagCodingProblemScalarFieldEnum>
  }


  /**
   * CodingProblemTag without action
   */
  export type CodingProblemTagArgs = {
    /**
     * Select specific fields to fetch from the CodingProblemTag
     */
    select?: CodingProblemTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemTagInclude | null
  }



  /**
   * Model CodeforcesTag
   */


  export type AggregateCodeforcesTag = {
    _count: CodeforcesTagCountAggregateOutputType | null
    _min: CodeforcesTagMinAggregateOutputType | null
    _max: CodeforcesTagMaxAggregateOutputType | null
  }

  export type CodeforcesTagMinAggregateOutputType = {
    id: string | null
    name: string | null
    parentId: string | null
  }

  export type CodeforcesTagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    parentId: string | null
  }

  export type CodeforcesTagCountAggregateOutputType = {
    id: number
    name: number
    parentId: number
    _all: number
  }


  export type CodeforcesTagMinAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
  }

  export type CodeforcesTagMaxAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
  }

  export type CodeforcesTagCountAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    _all?: true
  }

  export type CodeforcesTagAggregateArgs = {
    /**
     * Filter which CodeforcesTag to aggregate.
     */
    where?: CodeforcesTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeforcesTags to fetch.
     */
    orderBy?: Enumerable<CodeforcesTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CodeforcesTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeforcesTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeforcesTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CodeforcesTags
    **/
    _count?: true | CodeforcesTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CodeforcesTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CodeforcesTagMaxAggregateInputType
  }

  export type GetCodeforcesTagAggregateType<T extends CodeforcesTagAggregateArgs> = {
        [P in keyof T & keyof AggregateCodeforcesTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCodeforcesTag[P]>
      : GetScalarType<T[P], AggregateCodeforcesTag[P]>
  }




  export type CodeforcesTagGroupByArgs = {
    where?: CodeforcesTagWhereInput
    orderBy?: Enumerable<CodeforcesTagOrderByWithAggregationInput>
    by: CodeforcesTagScalarFieldEnum[]
    having?: CodeforcesTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CodeforcesTagCountAggregateInputType | true
    _min?: CodeforcesTagMinAggregateInputType
    _max?: CodeforcesTagMaxAggregateInputType
  }


  export type CodeforcesTagGroupByOutputType = {
    id: string
    name: string
    parentId: string | null
    _count: CodeforcesTagCountAggregateOutputType | null
    _min: CodeforcesTagMinAggregateOutputType | null
    _max: CodeforcesTagMaxAggregateOutputType | null
  }

  type GetCodeforcesTagGroupByPayload<T extends CodeforcesTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CodeforcesTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CodeforcesTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CodeforcesTagGroupByOutputType[P]>
            : GetScalarType<T[P], CodeforcesTagGroupByOutputType[P]>
        }
      >
    >


  export type CodeforcesTagSelect = {
    id?: boolean
    name?: boolean
    parentId?: boolean
    problems?: boolean | CodeforcesTag$problemsArgs
    _count?: boolean | CodeforcesTagCountOutputTypeArgs
  }


  export type CodeforcesTagInclude = {
    problems?: boolean | CodeforcesTag$problemsArgs
    _count?: boolean | CodeforcesTagCountOutputTypeArgs
  }

  export type CodeforcesTagGetPayload<S extends boolean | null | undefined | CodeforcesTagArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CodeforcesTag :
    S extends undefined ? never :
    S extends { include: any } & (CodeforcesTagArgs | CodeforcesTagFindManyArgs)
    ? CodeforcesTag  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'problems' ? Array < CodefocesTagProblemGetPayload<S['include'][P]>>  :
        P extends '_count' ? CodeforcesTagCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CodeforcesTagArgs | CodeforcesTagFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'problems' ? Array < CodefocesTagProblemGetPayload<S['select'][P]>>  :
        P extends '_count' ? CodeforcesTagCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof CodeforcesTag ? CodeforcesTag[P] : never
  } 
      : CodeforcesTag


  type CodeforcesTagCountArgs = 
    Omit<CodeforcesTagFindManyArgs, 'select' | 'include'> & {
      select?: CodeforcesTagCountAggregateInputType | true
    }

  export interface CodeforcesTagDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one CodeforcesTag that matches the filter.
     * @param {CodeforcesTagFindUniqueArgs} args - Arguments to find a CodeforcesTag
     * @example
     * // Get one CodeforcesTag
     * const codeforcesTag = await prisma.codeforcesTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CodeforcesTagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CodeforcesTagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CodeforcesTag'> extends True ? Prisma__CodeforcesTagClient<CodeforcesTagGetPayload<T>> : Prisma__CodeforcesTagClient<CodeforcesTagGetPayload<T> | null, null>

    /**
     * Find one CodeforcesTag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CodeforcesTagFindUniqueOrThrowArgs} args - Arguments to find a CodeforcesTag
     * @example
     * // Get one CodeforcesTag
     * const codeforcesTag = await prisma.codeforcesTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CodeforcesTagFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CodeforcesTagFindUniqueOrThrowArgs>
    ): Prisma__CodeforcesTagClient<CodeforcesTagGetPayload<T>>

    /**
     * Find the first CodeforcesTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeforcesTagFindFirstArgs} args - Arguments to find a CodeforcesTag
     * @example
     * // Get one CodeforcesTag
     * const codeforcesTag = await prisma.codeforcesTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CodeforcesTagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CodeforcesTagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CodeforcesTag'> extends True ? Prisma__CodeforcesTagClient<CodeforcesTagGetPayload<T>> : Prisma__CodeforcesTagClient<CodeforcesTagGetPayload<T> | null, null>

    /**
     * Find the first CodeforcesTag that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeforcesTagFindFirstOrThrowArgs} args - Arguments to find a CodeforcesTag
     * @example
     * // Get one CodeforcesTag
     * const codeforcesTag = await prisma.codeforcesTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CodeforcesTagFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CodeforcesTagFindFirstOrThrowArgs>
    ): Prisma__CodeforcesTagClient<CodeforcesTagGetPayload<T>>

    /**
     * Find zero or more CodeforcesTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeforcesTagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CodeforcesTags
     * const codeforcesTags = await prisma.codeforcesTag.findMany()
     * 
     * // Get first 10 CodeforcesTags
     * const codeforcesTags = await prisma.codeforcesTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const codeforcesTagWithIdOnly = await prisma.codeforcesTag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CodeforcesTagFindManyArgs>(
      args?: SelectSubset<T, CodeforcesTagFindManyArgs>
    ): Prisma.PrismaPromise<Array<CodeforcesTagGetPayload<T>>>

    /**
     * Create a CodeforcesTag.
     * @param {CodeforcesTagCreateArgs} args - Arguments to create a CodeforcesTag.
     * @example
     * // Create one CodeforcesTag
     * const CodeforcesTag = await prisma.codeforcesTag.create({
     *   data: {
     *     // ... data to create a CodeforcesTag
     *   }
     * })
     * 
    **/
    create<T extends CodeforcesTagCreateArgs>(
      args: SelectSubset<T, CodeforcesTagCreateArgs>
    ): Prisma__CodeforcesTagClient<CodeforcesTagGetPayload<T>>

    /**
     * Create many CodeforcesTags.
     *     @param {CodeforcesTagCreateManyArgs} args - Arguments to create many CodeforcesTags.
     *     @example
     *     // Create many CodeforcesTags
     *     const codeforcesTag = await prisma.codeforcesTag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CodeforcesTagCreateManyArgs>(
      args?: SelectSubset<T, CodeforcesTagCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CodeforcesTag.
     * @param {CodeforcesTagDeleteArgs} args - Arguments to delete one CodeforcesTag.
     * @example
     * // Delete one CodeforcesTag
     * const CodeforcesTag = await prisma.codeforcesTag.delete({
     *   where: {
     *     // ... filter to delete one CodeforcesTag
     *   }
     * })
     * 
    **/
    delete<T extends CodeforcesTagDeleteArgs>(
      args: SelectSubset<T, CodeforcesTagDeleteArgs>
    ): Prisma__CodeforcesTagClient<CodeforcesTagGetPayload<T>>

    /**
     * Update one CodeforcesTag.
     * @param {CodeforcesTagUpdateArgs} args - Arguments to update one CodeforcesTag.
     * @example
     * // Update one CodeforcesTag
     * const codeforcesTag = await prisma.codeforcesTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CodeforcesTagUpdateArgs>(
      args: SelectSubset<T, CodeforcesTagUpdateArgs>
    ): Prisma__CodeforcesTagClient<CodeforcesTagGetPayload<T>>

    /**
     * Delete zero or more CodeforcesTags.
     * @param {CodeforcesTagDeleteManyArgs} args - Arguments to filter CodeforcesTags to delete.
     * @example
     * // Delete a few CodeforcesTags
     * const { count } = await prisma.codeforcesTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CodeforcesTagDeleteManyArgs>(
      args?: SelectSubset<T, CodeforcesTagDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CodeforcesTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeforcesTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CodeforcesTags
     * const codeforcesTag = await prisma.codeforcesTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CodeforcesTagUpdateManyArgs>(
      args: SelectSubset<T, CodeforcesTagUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CodeforcesTag.
     * @param {CodeforcesTagUpsertArgs} args - Arguments to update or create a CodeforcesTag.
     * @example
     * // Update or create a CodeforcesTag
     * const codeforcesTag = await prisma.codeforcesTag.upsert({
     *   create: {
     *     // ... data to create a CodeforcesTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CodeforcesTag we want to update
     *   }
     * })
    **/
    upsert<T extends CodeforcesTagUpsertArgs>(
      args: SelectSubset<T, CodeforcesTagUpsertArgs>
    ): Prisma__CodeforcesTagClient<CodeforcesTagGetPayload<T>>

    /**
     * Count the number of CodeforcesTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeforcesTagCountArgs} args - Arguments to filter CodeforcesTags to count.
     * @example
     * // Count the number of CodeforcesTags
     * const count = await prisma.codeforcesTag.count({
     *   where: {
     *     // ... the filter for the CodeforcesTags we want to count
     *   }
     * })
    **/
    count<T extends CodeforcesTagCountArgs>(
      args?: Subset<T, CodeforcesTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CodeforcesTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CodeforcesTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeforcesTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CodeforcesTagAggregateArgs>(args: Subset<T, CodeforcesTagAggregateArgs>): Prisma.PrismaPromise<GetCodeforcesTagAggregateType<T>>

    /**
     * Group by CodeforcesTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeforcesTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CodeforcesTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CodeforcesTagGroupByArgs['orderBy'] }
        : { orderBy?: CodeforcesTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CodeforcesTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCodeforcesTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CodeforcesTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CodeforcesTagClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    problems<T extends CodeforcesTag$problemsArgs= {}>(args?: Subset<T, CodeforcesTag$problemsArgs>): Prisma.PrismaPromise<Array<CodefocesTagProblemGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CodeforcesTag base type for findUnique actions
   */
  export type CodeforcesTagFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CodeforcesTag
     */
    select?: CodeforcesTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeforcesTagInclude | null
    /**
     * Filter, which CodeforcesTag to fetch.
     */
    where: CodeforcesTagWhereUniqueInput
  }

  /**
   * CodeforcesTag findUnique
   */
  export interface CodeforcesTagFindUniqueArgs extends CodeforcesTagFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CodeforcesTag findUniqueOrThrow
   */
  export type CodeforcesTagFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CodeforcesTag
     */
    select?: CodeforcesTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeforcesTagInclude | null
    /**
     * Filter, which CodeforcesTag to fetch.
     */
    where: CodeforcesTagWhereUniqueInput
  }


  /**
   * CodeforcesTag base type for findFirst actions
   */
  export type CodeforcesTagFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CodeforcesTag
     */
    select?: CodeforcesTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeforcesTagInclude | null
    /**
     * Filter, which CodeforcesTag to fetch.
     */
    where?: CodeforcesTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeforcesTags to fetch.
     */
    orderBy?: Enumerable<CodeforcesTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodeforcesTags.
     */
    cursor?: CodeforcesTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeforcesTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeforcesTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodeforcesTags.
     */
    distinct?: Enumerable<CodeforcesTagScalarFieldEnum>
  }

  /**
   * CodeforcesTag findFirst
   */
  export interface CodeforcesTagFindFirstArgs extends CodeforcesTagFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CodeforcesTag findFirstOrThrow
   */
  export type CodeforcesTagFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CodeforcesTag
     */
    select?: CodeforcesTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeforcesTagInclude | null
    /**
     * Filter, which CodeforcesTag to fetch.
     */
    where?: CodeforcesTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeforcesTags to fetch.
     */
    orderBy?: Enumerable<CodeforcesTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodeforcesTags.
     */
    cursor?: CodeforcesTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeforcesTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeforcesTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodeforcesTags.
     */
    distinct?: Enumerable<CodeforcesTagScalarFieldEnum>
  }


  /**
   * CodeforcesTag findMany
   */
  export type CodeforcesTagFindManyArgs = {
    /**
     * Select specific fields to fetch from the CodeforcesTag
     */
    select?: CodeforcesTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeforcesTagInclude | null
    /**
     * Filter, which CodeforcesTags to fetch.
     */
    where?: CodeforcesTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeforcesTags to fetch.
     */
    orderBy?: Enumerable<CodeforcesTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CodeforcesTags.
     */
    cursor?: CodeforcesTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeforcesTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeforcesTags.
     */
    skip?: number
    distinct?: Enumerable<CodeforcesTagScalarFieldEnum>
  }


  /**
   * CodeforcesTag create
   */
  export type CodeforcesTagCreateArgs = {
    /**
     * Select specific fields to fetch from the CodeforcesTag
     */
    select?: CodeforcesTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeforcesTagInclude | null
    /**
     * The data needed to create a CodeforcesTag.
     */
    data: XOR<CodeforcesTagCreateInput, CodeforcesTagUncheckedCreateInput>
  }


  /**
   * CodeforcesTag createMany
   */
  export type CodeforcesTagCreateManyArgs = {
    /**
     * The data used to create many CodeforcesTags.
     */
    data: Enumerable<CodeforcesTagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CodeforcesTag update
   */
  export type CodeforcesTagUpdateArgs = {
    /**
     * Select specific fields to fetch from the CodeforcesTag
     */
    select?: CodeforcesTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeforcesTagInclude | null
    /**
     * The data needed to update a CodeforcesTag.
     */
    data: XOR<CodeforcesTagUpdateInput, CodeforcesTagUncheckedUpdateInput>
    /**
     * Choose, which CodeforcesTag to update.
     */
    where: CodeforcesTagWhereUniqueInput
  }


  /**
   * CodeforcesTag updateMany
   */
  export type CodeforcesTagUpdateManyArgs = {
    /**
     * The data used to update CodeforcesTags.
     */
    data: XOR<CodeforcesTagUpdateManyMutationInput, CodeforcesTagUncheckedUpdateManyInput>
    /**
     * Filter which CodeforcesTags to update
     */
    where?: CodeforcesTagWhereInput
  }


  /**
   * CodeforcesTag upsert
   */
  export type CodeforcesTagUpsertArgs = {
    /**
     * Select specific fields to fetch from the CodeforcesTag
     */
    select?: CodeforcesTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeforcesTagInclude | null
    /**
     * The filter to search for the CodeforcesTag to update in case it exists.
     */
    where: CodeforcesTagWhereUniqueInput
    /**
     * In case the CodeforcesTag found by the `where` argument doesn't exist, create a new CodeforcesTag with this data.
     */
    create: XOR<CodeforcesTagCreateInput, CodeforcesTagUncheckedCreateInput>
    /**
     * In case the CodeforcesTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CodeforcesTagUpdateInput, CodeforcesTagUncheckedUpdateInput>
  }


  /**
   * CodeforcesTag delete
   */
  export type CodeforcesTagDeleteArgs = {
    /**
     * Select specific fields to fetch from the CodeforcesTag
     */
    select?: CodeforcesTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeforcesTagInclude | null
    /**
     * Filter which CodeforcesTag to delete.
     */
    where: CodeforcesTagWhereUniqueInput
  }


  /**
   * CodeforcesTag deleteMany
   */
  export type CodeforcesTagDeleteManyArgs = {
    /**
     * Filter which CodeforcesTags to delete
     */
    where?: CodeforcesTagWhereInput
  }


  /**
   * CodeforcesTag.problems
   */
  export type CodeforcesTag$problemsArgs = {
    /**
     * Select specific fields to fetch from the CodefocesTagProblem
     */
    select?: CodefocesTagProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodefocesTagProblemInclude | null
    where?: CodefocesTagProblemWhereInput
    orderBy?: Enumerable<CodefocesTagProblemOrderByWithRelationInput>
    cursor?: CodefocesTagProblemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CodefocesTagProblemScalarFieldEnum>
  }


  /**
   * CodeforcesTag without action
   */
  export type CodeforcesTagArgs = {
    /**
     * Select specific fields to fetch from the CodeforcesTag
     */
    select?: CodeforcesTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeforcesTagInclude | null
  }



  /**
   * Model CodefocesTagProblem
   */


  export type AggregateCodefocesTagProblem = {
    _count: CodefocesTagProblemCountAggregateOutputType | null
    _min: CodefocesTagProblemMinAggregateOutputType | null
    _max: CodefocesTagProblemMaxAggregateOutputType | null
  }

  export type CodefocesTagProblemMinAggregateOutputType = {
    problemId: string | null
    codeforcesTagId: string | null
  }

  export type CodefocesTagProblemMaxAggregateOutputType = {
    problemId: string | null
    codeforcesTagId: string | null
  }

  export type CodefocesTagProblemCountAggregateOutputType = {
    problemId: number
    codeforcesTagId: number
    _all: number
  }


  export type CodefocesTagProblemMinAggregateInputType = {
    problemId?: true
    codeforcesTagId?: true
  }

  export type CodefocesTagProblemMaxAggregateInputType = {
    problemId?: true
    codeforcesTagId?: true
  }

  export type CodefocesTagProblemCountAggregateInputType = {
    problemId?: true
    codeforcesTagId?: true
    _all?: true
  }

  export type CodefocesTagProblemAggregateArgs = {
    /**
     * Filter which CodefocesTagProblem to aggregate.
     */
    where?: CodefocesTagProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodefocesTagProblems to fetch.
     */
    orderBy?: Enumerable<CodefocesTagProblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CodefocesTagProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodefocesTagProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodefocesTagProblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CodefocesTagProblems
    **/
    _count?: true | CodefocesTagProblemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CodefocesTagProblemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CodefocesTagProblemMaxAggregateInputType
  }

  export type GetCodefocesTagProblemAggregateType<T extends CodefocesTagProblemAggregateArgs> = {
        [P in keyof T & keyof AggregateCodefocesTagProblem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCodefocesTagProblem[P]>
      : GetScalarType<T[P], AggregateCodefocesTagProblem[P]>
  }




  export type CodefocesTagProblemGroupByArgs = {
    where?: CodefocesTagProblemWhereInput
    orderBy?: Enumerable<CodefocesTagProblemOrderByWithAggregationInput>
    by: CodefocesTagProblemScalarFieldEnum[]
    having?: CodefocesTagProblemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CodefocesTagProblemCountAggregateInputType | true
    _min?: CodefocesTagProblemMinAggregateInputType
    _max?: CodefocesTagProblemMaxAggregateInputType
  }


  export type CodefocesTagProblemGroupByOutputType = {
    problemId: string
    codeforcesTagId: string
    _count: CodefocesTagProblemCountAggregateOutputType | null
    _min: CodefocesTagProblemMinAggregateOutputType | null
    _max: CodefocesTagProblemMaxAggregateOutputType | null
  }

  type GetCodefocesTagProblemGroupByPayload<T extends CodefocesTagProblemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CodefocesTagProblemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CodefocesTagProblemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CodefocesTagProblemGroupByOutputType[P]>
            : GetScalarType<T[P], CodefocesTagProblemGroupByOutputType[P]>
        }
      >
    >


  export type CodefocesTagProblemSelect = {
    problemId?: boolean
    codeforcesTagId?: boolean
    problem?: boolean | CodingProblemArgs
    codeforcesTag?: boolean | CodeforcesTagArgs
  }


  export type CodefocesTagProblemInclude = {
    problem?: boolean | CodingProblemArgs
    codeforcesTag?: boolean | CodeforcesTagArgs
  }

  export type CodefocesTagProblemGetPayload<S extends boolean | null | undefined | CodefocesTagProblemArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CodefocesTagProblem :
    S extends undefined ? never :
    S extends { include: any } & (CodefocesTagProblemArgs | CodefocesTagProblemFindManyArgs)
    ? CodefocesTagProblem  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'problem' ? CodingProblemGetPayload<S['include'][P]> :
        P extends 'codeforcesTag' ? CodeforcesTagGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CodefocesTagProblemArgs | CodefocesTagProblemFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'problem' ? CodingProblemGetPayload<S['select'][P]> :
        P extends 'codeforcesTag' ? CodeforcesTagGetPayload<S['select'][P]> :  P extends keyof CodefocesTagProblem ? CodefocesTagProblem[P] : never
  } 
      : CodefocesTagProblem


  type CodefocesTagProblemCountArgs = 
    Omit<CodefocesTagProblemFindManyArgs, 'select' | 'include'> & {
      select?: CodefocesTagProblemCountAggregateInputType | true
    }

  export interface CodefocesTagProblemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one CodefocesTagProblem that matches the filter.
     * @param {CodefocesTagProblemFindUniqueArgs} args - Arguments to find a CodefocesTagProblem
     * @example
     * // Get one CodefocesTagProblem
     * const codefocesTagProblem = await prisma.codefocesTagProblem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CodefocesTagProblemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CodefocesTagProblemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CodefocesTagProblem'> extends True ? Prisma__CodefocesTagProblemClient<CodefocesTagProblemGetPayload<T>> : Prisma__CodefocesTagProblemClient<CodefocesTagProblemGetPayload<T> | null, null>

    /**
     * Find one CodefocesTagProblem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CodefocesTagProblemFindUniqueOrThrowArgs} args - Arguments to find a CodefocesTagProblem
     * @example
     * // Get one CodefocesTagProblem
     * const codefocesTagProblem = await prisma.codefocesTagProblem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CodefocesTagProblemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CodefocesTagProblemFindUniqueOrThrowArgs>
    ): Prisma__CodefocesTagProblemClient<CodefocesTagProblemGetPayload<T>>

    /**
     * Find the first CodefocesTagProblem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodefocesTagProblemFindFirstArgs} args - Arguments to find a CodefocesTagProblem
     * @example
     * // Get one CodefocesTagProblem
     * const codefocesTagProblem = await prisma.codefocesTagProblem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CodefocesTagProblemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CodefocesTagProblemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CodefocesTagProblem'> extends True ? Prisma__CodefocesTagProblemClient<CodefocesTagProblemGetPayload<T>> : Prisma__CodefocesTagProblemClient<CodefocesTagProblemGetPayload<T> | null, null>

    /**
     * Find the first CodefocesTagProblem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodefocesTagProblemFindFirstOrThrowArgs} args - Arguments to find a CodefocesTagProblem
     * @example
     * // Get one CodefocesTagProblem
     * const codefocesTagProblem = await prisma.codefocesTagProblem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CodefocesTagProblemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CodefocesTagProblemFindFirstOrThrowArgs>
    ): Prisma__CodefocesTagProblemClient<CodefocesTagProblemGetPayload<T>>

    /**
     * Find zero or more CodefocesTagProblems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodefocesTagProblemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CodefocesTagProblems
     * const codefocesTagProblems = await prisma.codefocesTagProblem.findMany()
     * 
     * // Get first 10 CodefocesTagProblems
     * const codefocesTagProblems = await prisma.codefocesTagProblem.findMany({ take: 10 })
     * 
     * // Only select the `problemId`
     * const codefocesTagProblemWithProblemIdOnly = await prisma.codefocesTagProblem.findMany({ select: { problemId: true } })
     * 
    **/
    findMany<T extends CodefocesTagProblemFindManyArgs>(
      args?: SelectSubset<T, CodefocesTagProblemFindManyArgs>
    ): Prisma.PrismaPromise<Array<CodefocesTagProblemGetPayload<T>>>

    /**
     * Create a CodefocesTagProblem.
     * @param {CodefocesTagProblemCreateArgs} args - Arguments to create a CodefocesTagProblem.
     * @example
     * // Create one CodefocesTagProblem
     * const CodefocesTagProblem = await prisma.codefocesTagProblem.create({
     *   data: {
     *     // ... data to create a CodefocesTagProblem
     *   }
     * })
     * 
    **/
    create<T extends CodefocesTagProblemCreateArgs>(
      args: SelectSubset<T, CodefocesTagProblemCreateArgs>
    ): Prisma__CodefocesTagProblemClient<CodefocesTagProblemGetPayload<T>>

    /**
     * Create many CodefocesTagProblems.
     *     @param {CodefocesTagProblemCreateManyArgs} args - Arguments to create many CodefocesTagProblems.
     *     @example
     *     // Create many CodefocesTagProblems
     *     const codefocesTagProblem = await prisma.codefocesTagProblem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CodefocesTagProblemCreateManyArgs>(
      args?: SelectSubset<T, CodefocesTagProblemCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CodefocesTagProblem.
     * @param {CodefocesTagProblemDeleteArgs} args - Arguments to delete one CodefocesTagProblem.
     * @example
     * // Delete one CodefocesTagProblem
     * const CodefocesTagProblem = await prisma.codefocesTagProblem.delete({
     *   where: {
     *     // ... filter to delete one CodefocesTagProblem
     *   }
     * })
     * 
    **/
    delete<T extends CodefocesTagProblemDeleteArgs>(
      args: SelectSubset<T, CodefocesTagProblemDeleteArgs>
    ): Prisma__CodefocesTagProblemClient<CodefocesTagProblemGetPayload<T>>

    /**
     * Update one CodefocesTagProblem.
     * @param {CodefocesTagProblemUpdateArgs} args - Arguments to update one CodefocesTagProblem.
     * @example
     * // Update one CodefocesTagProblem
     * const codefocesTagProblem = await prisma.codefocesTagProblem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CodefocesTagProblemUpdateArgs>(
      args: SelectSubset<T, CodefocesTagProblemUpdateArgs>
    ): Prisma__CodefocesTagProblemClient<CodefocesTagProblemGetPayload<T>>

    /**
     * Delete zero or more CodefocesTagProblems.
     * @param {CodefocesTagProblemDeleteManyArgs} args - Arguments to filter CodefocesTagProblems to delete.
     * @example
     * // Delete a few CodefocesTagProblems
     * const { count } = await prisma.codefocesTagProblem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CodefocesTagProblemDeleteManyArgs>(
      args?: SelectSubset<T, CodefocesTagProblemDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CodefocesTagProblems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodefocesTagProblemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CodefocesTagProblems
     * const codefocesTagProblem = await prisma.codefocesTagProblem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CodefocesTagProblemUpdateManyArgs>(
      args: SelectSubset<T, CodefocesTagProblemUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CodefocesTagProblem.
     * @param {CodefocesTagProblemUpsertArgs} args - Arguments to update or create a CodefocesTagProblem.
     * @example
     * // Update or create a CodefocesTagProblem
     * const codefocesTagProblem = await prisma.codefocesTagProblem.upsert({
     *   create: {
     *     // ... data to create a CodefocesTagProblem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CodefocesTagProblem we want to update
     *   }
     * })
    **/
    upsert<T extends CodefocesTagProblemUpsertArgs>(
      args: SelectSubset<T, CodefocesTagProblemUpsertArgs>
    ): Prisma__CodefocesTagProblemClient<CodefocesTagProblemGetPayload<T>>

    /**
     * Count the number of CodefocesTagProblems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodefocesTagProblemCountArgs} args - Arguments to filter CodefocesTagProblems to count.
     * @example
     * // Count the number of CodefocesTagProblems
     * const count = await prisma.codefocesTagProblem.count({
     *   where: {
     *     // ... the filter for the CodefocesTagProblems we want to count
     *   }
     * })
    **/
    count<T extends CodefocesTagProblemCountArgs>(
      args?: Subset<T, CodefocesTagProblemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CodefocesTagProblemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CodefocesTagProblem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodefocesTagProblemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CodefocesTagProblemAggregateArgs>(args: Subset<T, CodefocesTagProblemAggregateArgs>): Prisma.PrismaPromise<GetCodefocesTagProblemAggregateType<T>>

    /**
     * Group by CodefocesTagProblem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodefocesTagProblemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CodefocesTagProblemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CodefocesTagProblemGroupByArgs['orderBy'] }
        : { orderBy?: CodefocesTagProblemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CodefocesTagProblemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCodefocesTagProblemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CodefocesTagProblem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CodefocesTagProblemClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    problem<T extends CodingProblemArgs= {}>(args?: Subset<T, CodingProblemArgs>): Prisma__CodingProblemClient<CodingProblemGetPayload<T> | Null>;

    codeforcesTag<T extends CodeforcesTagArgs= {}>(args?: Subset<T, CodeforcesTagArgs>): Prisma__CodeforcesTagClient<CodeforcesTagGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CodefocesTagProblem base type for findUnique actions
   */
  export type CodefocesTagProblemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CodefocesTagProblem
     */
    select?: CodefocesTagProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodefocesTagProblemInclude | null
    /**
     * Filter, which CodefocesTagProblem to fetch.
     */
    where: CodefocesTagProblemWhereUniqueInput
  }

  /**
   * CodefocesTagProblem findUnique
   */
  export interface CodefocesTagProblemFindUniqueArgs extends CodefocesTagProblemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CodefocesTagProblem findUniqueOrThrow
   */
  export type CodefocesTagProblemFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CodefocesTagProblem
     */
    select?: CodefocesTagProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodefocesTagProblemInclude | null
    /**
     * Filter, which CodefocesTagProblem to fetch.
     */
    where: CodefocesTagProblemWhereUniqueInput
  }


  /**
   * CodefocesTagProblem base type for findFirst actions
   */
  export type CodefocesTagProblemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CodefocesTagProblem
     */
    select?: CodefocesTagProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodefocesTagProblemInclude | null
    /**
     * Filter, which CodefocesTagProblem to fetch.
     */
    where?: CodefocesTagProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodefocesTagProblems to fetch.
     */
    orderBy?: Enumerable<CodefocesTagProblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodefocesTagProblems.
     */
    cursor?: CodefocesTagProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodefocesTagProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodefocesTagProblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodefocesTagProblems.
     */
    distinct?: Enumerable<CodefocesTagProblemScalarFieldEnum>
  }

  /**
   * CodefocesTagProblem findFirst
   */
  export interface CodefocesTagProblemFindFirstArgs extends CodefocesTagProblemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CodefocesTagProblem findFirstOrThrow
   */
  export type CodefocesTagProblemFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CodefocesTagProblem
     */
    select?: CodefocesTagProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodefocesTagProblemInclude | null
    /**
     * Filter, which CodefocesTagProblem to fetch.
     */
    where?: CodefocesTagProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodefocesTagProblems to fetch.
     */
    orderBy?: Enumerable<CodefocesTagProblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodefocesTagProblems.
     */
    cursor?: CodefocesTagProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodefocesTagProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodefocesTagProblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodefocesTagProblems.
     */
    distinct?: Enumerable<CodefocesTagProblemScalarFieldEnum>
  }


  /**
   * CodefocesTagProblem findMany
   */
  export type CodefocesTagProblemFindManyArgs = {
    /**
     * Select specific fields to fetch from the CodefocesTagProblem
     */
    select?: CodefocesTagProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodefocesTagProblemInclude | null
    /**
     * Filter, which CodefocesTagProblems to fetch.
     */
    where?: CodefocesTagProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodefocesTagProblems to fetch.
     */
    orderBy?: Enumerable<CodefocesTagProblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CodefocesTagProblems.
     */
    cursor?: CodefocesTagProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodefocesTagProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodefocesTagProblems.
     */
    skip?: number
    distinct?: Enumerable<CodefocesTagProblemScalarFieldEnum>
  }


  /**
   * CodefocesTagProblem create
   */
  export type CodefocesTagProblemCreateArgs = {
    /**
     * Select specific fields to fetch from the CodefocesTagProblem
     */
    select?: CodefocesTagProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodefocesTagProblemInclude | null
    /**
     * The data needed to create a CodefocesTagProblem.
     */
    data: XOR<CodefocesTagProblemCreateInput, CodefocesTagProblemUncheckedCreateInput>
  }


  /**
   * CodefocesTagProblem createMany
   */
  export type CodefocesTagProblemCreateManyArgs = {
    /**
     * The data used to create many CodefocesTagProblems.
     */
    data: Enumerable<CodefocesTagProblemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CodefocesTagProblem update
   */
  export type CodefocesTagProblemUpdateArgs = {
    /**
     * Select specific fields to fetch from the CodefocesTagProblem
     */
    select?: CodefocesTagProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodefocesTagProblemInclude | null
    /**
     * The data needed to update a CodefocesTagProblem.
     */
    data: XOR<CodefocesTagProblemUpdateInput, CodefocesTagProblemUncheckedUpdateInput>
    /**
     * Choose, which CodefocesTagProblem to update.
     */
    where: CodefocesTagProblemWhereUniqueInput
  }


  /**
   * CodefocesTagProblem updateMany
   */
  export type CodefocesTagProblemUpdateManyArgs = {
    /**
     * The data used to update CodefocesTagProblems.
     */
    data: XOR<CodefocesTagProblemUpdateManyMutationInput, CodefocesTagProblemUncheckedUpdateManyInput>
    /**
     * Filter which CodefocesTagProblems to update
     */
    where?: CodefocesTagProblemWhereInput
  }


  /**
   * CodefocesTagProblem upsert
   */
  export type CodefocesTagProblemUpsertArgs = {
    /**
     * Select specific fields to fetch from the CodefocesTagProblem
     */
    select?: CodefocesTagProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodefocesTagProblemInclude | null
    /**
     * The filter to search for the CodefocesTagProblem to update in case it exists.
     */
    where: CodefocesTagProblemWhereUniqueInput
    /**
     * In case the CodefocesTagProblem found by the `where` argument doesn't exist, create a new CodefocesTagProblem with this data.
     */
    create: XOR<CodefocesTagProblemCreateInput, CodefocesTagProblemUncheckedCreateInput>
    /**
     * In case the CodefocesTagProblem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CodefocesTagProblemUpdateInput, CodefocesTagProblemUncheckedUpdateInput>
  }


  /**
   * CodefocesTagProblem delete
   */
  export type CodefocesTagProblemDeleteArgs = {
    /**
     * Select specific fields to fetch from the CodefocesTagProblem
     */
    select?: CodefocesTagProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodefocesTagProblemInclude | null
    /**
     * Filter which CodefocesTagProblem to delete.
     */
    where: CodefocesTagProblemWhereUniqueInput
  }


  /**
   * CodefocesTagProblem deleteMany
   */
  export type CodefocesTagProblemDeleteManyArgs = {
    /**
     * Filter which CodefocesTagProblems to delete
     */
    where?: CodefocesTagProblemWhereInput
  }


  /**
   * CodefocesTagProblem without action
   */
  export type CodefocesTagProblemArgs = {
    /**
     * Select specific fields to fetch from the CodefocesTagProblem
     */
    select?: CodefocesTagProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodefocesTagProblemInclude | null
  }



  /**
   * Model CodingProblem
   */


  export type AggregateCodingProblem = {
    _count: CodingProblemCountAggregateOutputType | null
    _avg: CodingProblemAvgAggregateOutputType | null
    _sum: CodingProblemSumAggregateOutputType | null
    _min: CodingProblemMinAggregateOutputType | null
    _max: CodingProblemMaxAggregateOutputType | null
  }

  export type CodingProblemAvgAggregateOutputType = {
    categoryId: number | null
    timeLimit: number | null
    memoryLimit: number | null
    difficulty: number | null
    practicePoint: number | null
    totalPoint: number | null
    submissionNumber: number | null
    acceptedNumber: number | null
  }

  export type CodingProblemSumAggregateOutputType = {
    categoryId: number | null
    timeLimit: number | null
    memoryLimit: number | null
    difficulty: number | null
    practicePoint: number | null
    totalPoint: number | null
    submissionNumber: number | null
    acceptedNumber: number | null
  }

  export type CodingProblemMinAggregateOutputType = {
    id: string | null
    code: string | null
    title: string | null
    categoryId: number | null
    link: string | null
    description: string | null
    timeLimit: number | null
    memoryLimit: number | null
    difficulty: number | null
    practicePoint: number | null
    totalPoint: number | null
    submissionNumber: number | null
    acceptedNumber: number | null
    contestId: string | null
    visibleFrom: Date | null
  }

  export type CodingProblemMaxAggregateOutputType = {
    id: string | null
    code: string | null
    title: string | null
    categoryId: number | null
    link: string | null
    description: string | null
    timeLimit: number | null
    memoryLimit: number | null
    difficulty: number | null
    practicePoint: number | null
    totalPoint: number | null
    submissionNumber: number | null
    acceptedNumber: number | null
    contestId: string | null
    visibleFrom: Date | null
  }

  export type CodingProblemCountAggregateOutputType = {
    id: number
    code: number
    title: number
    categoryId: number
    link: number
    description: number
    timeLimit: number
    memoryLimit: number
    difficulty: number
    practicePoint: number
    totalPoint: number
    submissionNumber: number
    acceptedNumber: number
    contestId: number
    visibleFrom: number
    _all: number
  }


  export type CodingProblemAvgAggregateInputType = {
    categoryId?: true
    timeLimit?: true
    memoryLimit?: true
    difficulty?: true
    practicePoint?: true
    totalPoint?: true
    submissionNumber?: true
    acceptedNumber?: true
  }

  export type CodingProblemSumAggregateInputType = {
    categoryId?: true
    timeLimit?: true
    memoryLimit?: true
    difficulty?: true
    practicePoint?: true
    totalPoint?: true
    submissionNumber?: true
    acceptedNumber?: true
  }

  export type CodingProblemMinAggregateInputType = {
    id?: true
    code?: true
    title?: true
    categoryId?: true
    link?: true
    description?: true
    timeLimit?: true
    memoryLimit?: true
    difficulty?: true
    practicePoint?: true
    totalPoint?: true
    submissionNumber?: true
    acceptedNumber?: true
    contestId?: true
    visibleFrom?: true
  }

  export type CodingProblemMaxAggregateInputType = {
    id?: true
    code?: true
    title?: true
    categoryId?: true
    link?: true
    description?: true
    timeLimit?: true
    memoryLimit?: true
    difficulty?: true
    practicePoint?: true
    totalPoint?: true
    submissionNumber?: true
    acceptedNumber?: true
    contestId?: true
    visibleFrom?: true
  }

  export type CodingProblemCountAggregateInputType = {
    id?: true
    code?: true
    title?: true
    categoryId?: true
    link?: true
    description?: true
    timeLimit?: true
    memoryLimit?: true
    difficulty?: true
    practicePoint?: true
    totalPoint?: true
    submissionNumber?: true
    acceptedNumber?: true
    contestId?: true
    visibleFrom?: true
    _all?: true
  }

  export type CodingProblemAggregateArgs = {
    /**
     * Filter which CodingProblem to aggregate.
     */
    where?: CodingProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodingProblems to fetch.
     */
    orderBy?: Enumerable<CodingProblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CodingProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodingProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodingProblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CodingProblems
    **/
    _count?: true | CodingProblemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CodingProblemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CodingProblemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CodingProblemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CodingProblemMaxAggregateInputType
  }

  export type GetCodingProblemAggregateType<T extends CodingProblemAggregateArgs> = {
        [P in keyof T & keyof AggregateCodingProblem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCodingProblem[P]>
      : GetScalarType<T[P], AggregateCodingProblem[P]>
  }




  export type CodingProblemGroupByArgs = {
    where?: CodingProblemWhereInput
    orderBy?: Enumerable<CodingProblemOrderByWithAggregationInput>
    by: CodingProblemScalarFieldEnum[]
    having?: CodingProblemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CodingProblemCountAggregateInputType | true
    _avg?: CodingProblemAvgAggregateInputType
    _sum?: CodingProblemSumAggregateInputType
    _min?: CodingProblemMinAggregateInputType
    _max?: CodingProblemMaxAggregateInputType
  }


  export type CodingProblemGroupByOutputType = {
    id: string
    code: string
    title: string
    categoryId: number
    link: string | null
    description: string | null
    timeLimit: number
    memoryLimit: number
    difficulty: number
    practicePoint: number
    totalPoint: number
    submissionNumber: number
    acceptedNumber: number
    contestId: string | null
    visibleFrom: Date | null
    _count: CodingProblemCountAggregateOutputType | null
    _avg: CodingProblemAvgAggregateOutputType | null
    _sum: CodingProblemSumAggregateOutputType | null
    _min: CodingProblemMinAggregateOutputType | null
    _max: CodingProblemMaxAggregateOutputType | null
  }

  type GetCodingProblemGroupByPayload<T extends CodingProblemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CodingProblemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CodingProblemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CodingProblemGroupByOutputType[P]>
            : GetScalarType<T[P], CodingProblemGroupByOutputType[P]>
        }
      >
    >


  export type CodingProblemSelect = {
    id?: boolean
    code?: boolean
    title?: boolean
    categoryId?: boolean
    link?: boolean
    description?: boolean
    timeLimit?: boolean
    memoryLimit?: boolean
    difficulty?: boolean
    practicePoint?: boolean
    totalPoint?: boolean
    submissionNumber?: boolean
    acceptedNumber?: boolean
    contestId?: boolean
    visibleFrom?: boolean
    category?: boolean | CodingProblemCategoryArgs
    authors?: boolean | CodingProblem$authorsArgs
    tags?: boolean | CodingProblem$tagsArgs
    codeforcesTag?: boolean | CodingProblem$codeforcesTagArgs
    testCases?: boolean | CodingProblem$testCasesArgs
    contest?: boolean | ContestArgs
    _count?: boolean | CodingProblemCountOutputTypeArgs
  }


  export type CodingProblemInclude = {
    category?: boolean | CodingProblemCategoryArgs
    authors?: boolean | CodingProblem$authorsArgs
    tags?: boolean | CodingProblem$tagsArgs
    codeforcesTag?: boolean | CodingProblem$codeforcesTagArgs
    testCases?: boolean | CodingProblem$testCasesArgs
    contest?: boolean | ContestArgs
    _count?: boolean | CodingProblemCountOutputTypeArgs
  }

  export type CodingProblemGetPayload<S extends boolean | null | undefined | CodingProblemArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CodingProblem :
    S extends undefined ? never :
    S extends { include: any } & (CodingProblemArgs | CodingProblemFindManyArgs)
    ? CodingProblem  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'category' ? CodingProblemCategoryGetPayload<S['include'][P]> :
        P extends 'authors' ? Array < AuthorCodingProblemGetPayload<S['include'][P]>>  :
        P extends 'tags' ? Array < TagCodingProblemGetPayload<S['include'][P]>>  :
        P extends 'codeforcesTag' ? Array < CodefocesTagProblemGetPayload<S['include'][P]>>  :
        P extends 'testCases' ? Array < TestcaseGetPayload<S['include'][P]>>  :
        P extends 'contest' ? ContestGetPayload<S['include'][P]> | null :
        P extends '_count' ? CodingProblemCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CodingProblemArgs | CodingProblemFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'category' ? CodingProblemCategoryGetPayload<S['select'][P]> :
        P extends 'authors' ? Array < AuthorCodingProblemGetPayload<S['select'][P]>>  :
        P extends 'tags' ? Array < TagCodingProblemGetPayload<S['select'][P]>>  :
        P extends 'codeforcesTag' ? Array < CodefocesTagProblemGetPayload<S['select'][P]>>  :
        P extends 'testCases' ? Array < TestcaseGetPayload<S['select'][P]>>  :
        P extends 'contest' ? ContestGetPayload<S['select'][P]> | null :
        P extends '_count' ? CodingProblemCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof CodingProblem ? CodingProblem[P] : never
  } 
      : CodingProblem


  type CodingProblemCountArgs = 
    Omit<CodingProblemFindManyArgs, 'select' | 'include'> & {
      select?: CodingProblemCountAggregateInputType | true
    }

  export interface CodingProblemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one CodingProblem that matches the filter.
     * @param {CodingProblemFindUniqueArgs} args - Arguments to find a CodingProblem
     * @example
     * // Get one CodingProblem
     * const codingProblem = await prisma.codingProblem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CodingProblemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CodingProblemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CodingProblem'> extends True ? Prisma__CodingProblemClient<CodingProblemGetPayload<T>> : Prisma__CodingProblemClient<CodingProblemGetPayload<T> | null, null>

    /**
     * Find one CodingProblem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CodingProblemFindUniqueOrThrowArgs} args - Arguments to find a CodingProblem
     * @example
     * // Get one CodingProblem
     * const codingProblem = await prisma.codingProblem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CodingProblemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CodingProblemFindUniqueOrThrowArgs>
    ): Prisma__CodingProblemClient<CodingProblemGetPayload<T>>

    /**
     * Find the first CodingProblem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodingProblemFindFirstArgs} args - Arguments to find a CodingProblem
     * @example
     * // Get one CodingProblem
     * const codingProblem = await prisma.codingProblem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CodingProblemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CodingProblemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CodingProblem'> extends True ? Prisma__CodingProblemClient<CodingProblemGetPayload<T>> : Prisma__CodingProblemClient<CodingProblemGetPayload<T> | null, null>

    /**
     * Find the first CodingProblem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodingProblemFindFirstOrThrowArgs} args - Arguments to find a CodingProblem
     * @example
     * // Get one CodingProblem
     * const codingProblem = await prisma.codingProblem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CodingProblemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CodingProblemFindFirstOrThrowArgs>
    ): Prisma__CodingProblemClient<CodingProblemGetPayload<T>>

    /**
     * Find zero or more CodingProblems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodingProblemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CodingProblems
     * const codingProblems = await prisma.codingProblem.findMany()
     * 
     * // Get first 10 CodingProblems
     * const codingProblems = await prisma.codingProblem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const codingProblemWithIdOnly = await prisma.codingProblem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CodingProblemFindManyArgs>(
      args?: SelectSubset<T, CodingProblemFindManyArgs>
    ): Prisma.PrismaPromise<Array<CodingProblemGetPayload<T>>>

    /**
     * Create a CodingProblem.
     * @param {CodingProblemCreateArgs} args - Arguments to create a CodingProblem.
     * @example
     * // Create one CodingProblem
     * const CodingProblem = await prisma.codingProblem.create({
     *   data: {
     *     // ... data to create a CodingProblem
     *   }
     * })
     * 
    **/
    create<T extends CodingProblemCreateArgs>(
      args: SelectSubset<T, CodingProblemCreateArgs>
    ): Prisma__CodingProblemClient<CodingProblemGetPayload<T>>

    /**
     * Create many CodingProblems.
     *     @param {CodingProblemCreateManyArgs} args - Arguments to create many CodingProblems.
     *     @example
     *     // Create many CodingProblems
     *     const codingProblem = await prisma.codingProblem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CodingProblemCreateManyArgs>(
      args?: SelectSubset<T, CodingProblemCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CodingProblem.
     * @param {CodingProblemDeleteArgs} args - Arguments to delete one CodingProblem.
     * @example
     * // Delete one CodingProblem
     * const CodingProblem = await prisma.codingProblem.delete({
     *   where: {
     *     // ... filter to delete one CodingProblem
     *   }
     * })
     * 
    **/
    delete<T extends CodingProblemDeleteArgs>(
      args: SelectSubset<T, CodingProblemDeleteArgs>
    ): Prisma__CodingProblemClient<CodingProblemGetPayload<T>>

    /**
     * Update one CodingProblem.
     * @param {CodingProblemUpdateArgs} args - Arguments to update one CodingProblem.
     * @example
     * // Update one CodingProblem
     * const codingProblem = await prisma.codingProblem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CodingProblemUpdateArgs>(
      args: SelectSubset<T, CodingProblemUpdateArgs>
    ): Prisma__CodingProblemClient<CodingProblemGetPayload<T>>

    /**
     * Delete zero or more CodingProblems.
     * @param {CodingProblemDeleteManyArgs} args - Arguments to filter CodingProblems to delete.
     * @example
     * // Delete a few CodingProblems
     * const { count } = await prisma.codingProblem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CodingProblemDeleteManyArgs>(
      args?: SelectSubset<T, CodingProblemDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CodingProblems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodingProblemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CodingProblems
     * const codingProblem = await prisma.codingProblem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CodingProblemUpdateManyArgs>(
      args: SelectSubset<T, CodingProblemUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CodingProblem.
     * @param {CodingProblemUpsertArgs} args - Arguments to update or create a CodingProblem.
     * @example
     * // Update or create a CodingProblem
     * const codingProblem = await prisma.codingProblem.upsert({
     *   create: {
     *     // ... data to create a CodingProblem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CodingProblem we want to update
     *   }
     * })
    **/
    upsert<T extends CodingProblemUpsertArgs>(
      args: SelectSubset<T, CodingProblemUpsertArgs>
    ): Prisma__CodingProblemClient<CodingProblemGetPayload<T>>

    /**
     * Count the number of CodingProblems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodingProblemCountArgs} args - Arguments to filter CodingProblems to count.
     * @example
     * // Count the number of CodingProblems
     * const count = await prisma.codingProblem.count({
     *   where: {
     *     // ... the filter for the CodingProblems we want to count
     *   }
     * })
    **/
    count<T extends CodingProblemCountArgs>(
      args?: Subset<T, CodingProblemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CodingProblemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CodingProblem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodingProblemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CodingProblemAggregateArgs>(args: Subset<T, CodingProblemAggregateArgs>): Prisma.PrismaPromise<GetCodingProblemAggregateType<T>>

    /**
     * Group by CodingProblem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodingProblemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CodingProblemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CodingProblemGroupByArgs['orderBy'] }
        : { orderBy?: CodingProblemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CodingProblemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCodingProblemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CodingProblem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CodingProblemClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    category<T extends CodingProblemCategoryArgs= {}>(args?: Subset<T, CodingProblemCategoryArgs>): Prisma__CodingProblemCategoryClient<CodingProblemCategoryGetPayload<T> | Null>;

    authors<T extends CodingProblem$authorsArgs= {}>(args?: Subset<T, CodingProblem$authorsArgs>): Prisma.PrismaPromise<Array<AuthorCodingProblemGetPayload<T>>| Null>;

    tags<T extends CodingProblem$tagsArgs= {}>(args?: Subset<T, CodingProblem$tagsArgs>): Prisma.PrismaPromise<Array<TagCodingProblemGetPayload<T>>| Null>;

    codeforcesTag<T extends CodingProblem$codeforcesTagArgs= {}>(args?: Subset<T, CodingProblem$codeforcesTagArgs>): Prisma.PrismaPromise<Array<CodefocesTagProblemGetPayload<T>>| Null>;

    testCases<T extends CodingProblem$testCasesArgs= {}>(args?: Subset<T, CodingProblem$testCasesArgs>): Prisma.PrismaPromise<Array<TestcaseGetPayload<T>>| Null>;

    contest<T extends ContestArgs= {}>(args?: Subset<T, ContestArgs>): Prisma__ContestClient<ContestGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CodingProblem base type for findUnique actions
   */
  export type CodingProblemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CodingProblem
     */
    select?: CodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemInclude | null
    /**
     * Filter, which CodingProblem to fetch.
     */
    where: CodingProblemWhereUniqueInput
  }

  /**
   * CodingProblem findUnique
   */
  export interface CodingProblemFindUniqueArgs extends CodingProblemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CodingProblem findUniqueOrThrow
   */
  export type CodingProblemFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CodingProblem
     */
    select?: CodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemInclude | null
    /**
     * Filter, which CodingProblem to fetch.
     */
    where: CodingProblemWhereUniqueInput
  }


  /**
   * CodingProblem base type for findFirst actions
   */
  export type CodingProblemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CodingProblem
     */
    select?: CodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemInclude | null
    /**
     * Filter, which CodingProblem to fetch.
     */
    where?: CodingProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodingProblems to fetch.
     */
    orderBy?: Enumerable<CodingProblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodingProblems.
     */
    cursor?: CodingProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodingProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodingProblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodingProblems.
     */
    distinct?: Enumerable<CodingProblemScalarFieldEnum>
  }

  /**
   * CodingProblem findFirst
   */
  export interface CodingProblemFindFirstArgs extends CodingProblemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CodingProblem findFirstOrThrow
   */
  export type CodingProblemFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CodingProblem
     */
    select?: CodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemInclude | null
    /**
     * Filter, which CodingProblem to fetch.
     */
    where?: CodingProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodingProblems to fetch.
     */
    orderBy?: Enumerable<CodingProblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodingProblems.
     */
    cursor?: CodingProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodingProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodingProblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodingProblems.
     */
    distinct?: Enumerable<CodingProblemScalarFieldEnum>
  }


  /**
   * CodingProblem findMany
   */
  export type CodingProblemFindManyArgs = {
    /**
     * Select specific fields to fetch from the CodingProblem
     */
    select?: CodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemInclude | null
    /**
     * Filter, which CodingProblems to fetch.
     */
    where?: CodingProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodingProblems to fetch.
     */
    orderBy?: Enumerable<CodingProblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CodingProblems.
     */
    cursor?: CodingProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodingProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodingProblems.
     */
    skip?: number
    distinct?: Enumerable<CodingProblemScalarFieldEnum>
  }


  /**
   * CodingProblem create
   */
  export type CodingProblemCreateArgs = {
    /**
     * Select specific fields to fetch from the CodingProblem
     */
    select?: CodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemInclude | null
    /**
     * The data needed to create a CodingProblem.
     */
    data: XOR<CodingProblemCreateInput, CodingProblemUncheckedCreateInput>
  }


  /**
   * CodingProblem createMany
   */
  export type CodingProblemCreateManyArgs = {
    /**
     * The data used to create many CodingProblems.
     */
    data: Enumerable<CodingProblemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CodingProblem update
   */
  export type CodingProblemUpdateArgs = {
    /**
     * Select specific fields to fetch from the CodingProblem
     */
    select?: CodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemInclude | null
    /**
     * The data needed to update a CodingProblem.
     */
    data: XOR<CodingProblemUpdateInput, CodingProblemUncheckedUpdateInput>
    /**
     * Choose, which CodingProblem to update.
     */
    where: CodingProblemWhereUniqueInput
  }


  /**
   * CodingProblem updateMany
   */
  export type CodingProblemUpdateManyArgs = {
    /**
     * The data used to update CodingProblems.
     */
    data: XOR<CodingProblemUpdateManyMutationInput, CodingProblemUncheckedUpdateManyInput>
    /**
     * Filter which CodingProblems to update
     */
    where?: CodingProblemWhereInput
  }


  /**
   * CodingProblem upsert
   */
  export type CodingProblemUpsertArgs = {
    /**
     * Select specific fields to fetch from the CodingProblem
     */
    select?: CodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemInclude | null
    /**
     * The filter to search for the CodingProblem to update in case it exists.
     */
    where: CodingProblemWhereUniqueInput
    /**
     * In case the CodingProblem found by the `where` argument doesn't exist, create a new CodingProblem with this data.
     */
    create: XOR<CodingProblemCreateInput, CodingProblemUncheckedCreateInput>
    /**
     * In case the CodingProblem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CodingProblemUpdateInput, CodingProblemUncheckedUpdateInput>
  }


  /**
   * CodingProblem delete
   */
  export type CodingProblemDeleteArgs = {
    /**
     * Select specific fields to fetch from the CodingProblem
     */
    select?: CodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemInclude | null
    /**
     * Filter which CodingProblem to delete.
     */
    where: CodingProblemWhereUniqueInput
  }


  /**
   * CodingProblem deleteMany
   */
  export type CodingProblemDeleteManyArgs = {
    /**
     * Filter which CodingProblems to delete
     */
    where?: CodingProblemWhereInput
  }


  /**
   * CodingProblem.authors
   */
  export type CodingProblem$authorsArgs = {
    /**
     * Select specific fields to fetch from the AuthorCodingProblem
     */
    select?: AuthorCodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorCodingProblemInclude | null
    where?: AuthorCodingProblemWhereInput
    orderBy?: Enumerable<AuthorCodingProblemOrderByWithRelationInput>
    cursor?: AuthorCodingProblemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AuthorCodingProblemScalarFieldEnum>
  }


  /**
   * CodingProblem.tags
   */
  export type CodingProblem$tagsArgs = {
    /**
     * Select specific fields to fetch from the TagCodingProblem
     */
    select?: TagCodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagCodingProblemInclude | null
    where?: TagCodingProblemWhereInput
    orderBy?: Enumerable<TagCodingProblemOrderByWithRelationInput>
    cursor?: TagCodingProblemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TagCodingProblemScalarFieldEnum>
  }


  /**
   * CodingProblem.codeforcesTag
   */
  export type CodingProblem$codeforcesTagArgs = {
    /**
     * Select specific fields to fetch from the CodefocesTagProblem
     */
    select?: CodefocesTagProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodefocesTagProblemInclude | null
    where?: CodefocesTagProblemWhereInput
    orderBy?: Enumerable<CodefocesTagProblemOrderByWithRelationInput>
    cursor?: CodefocesTagProblemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CodefocesTagProblemScalarFieldEnum>
  }


  /**
   * CodingProblem.testCases
   */
  export type CodingProblem$testCasesArgs = {
    /**
     * Select specific fields to fetch from the Testcase
     */
    select?: TestcaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestcaseInclude | null
    where?: TestcaseWhereInput
    orderBy?: Enumerable<TestcaseOrderByWithRelationInput>
    cursor?: TestcaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TestcaseScalarFieldEnum>
  }


  /**
   * CodingProblem without action
   */
  export type CodingProblemArgs = {
    /**
     * Select specific fields to fetch from the CodingProblem
     */
    select?: CodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemInclude | null
  }



  /**
   * Model AuthorCodingProblem
   */


  export type AggregateAuthorCodingProblem = {
    _count: AuthorCodingProblemCountAggregateOutputType | null
    _min: AuthorCodingProblemMinAggregateOutputType | null
    _max: AuthorCodingProblemMaxAggregateOutputType | null
  }

  export type AuthorCodingProblemMinAggregateOutputType = {
    username: string | null
    codingProblemId: string | null
  }

  export type AuthorCodingProblemMaxAggregateOutputType = {
    username: string | null
    codingProblemId: string | null
  }

  export type AuthorCodingProblemCountAggregateOutputType = {
    username: number
    codingProblemId: number
    _all: number
  }


  export type AuthorCodingProblemMinAggregateInputType = {
    username?: true
    codingProblemId?: true
  }

  export type AuthorCodingProblemMaxAggregateInputType = {
    username?: true
    codingProblemId?: true
  }

  export type AuthorCodingProblemCountAggregateInputType = {
    username?: true
    codingProblemId?: true
    _all?: true
  }

  export type AuthorCodingProblemAggregateArgs = {
    /**
     * Filter which AuthorCodingProblem to aggregate.
     */
    where?: AuthorCodingProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthorCodingProblems to fetch.
     */
    orderBy?: Enumerable<AuthorCodingProblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthorCodingProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthorCodingProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthorCodingProblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuthorCodingProblems
    **/
    _count?: true | AuthorCodingProblemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthorCodingProblemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthorCodingProblemMaxAggregateInputType
  }

  export type GetAuthorCodingProblemAggregateType<T extends AuthorCodingProblemAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthorCodingProblem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthorCodingProblem[P]>
      : GetScalarType<T[P], AggregateAuthorCodingProblem[P]>
  }




  export type AuthorCodingProblemGroupByArgs = {
    where?: AuthorCodingProblemWhereInput
    orderBy?: Enumerable<AuthorCodingProblemOrderByWithAggregationInput>
    by: AuthorCodingProblemScalarFieldEnum[]
    having?: AuthorCodingProblemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthorCodingProblemCountAggregateInputType | true
    _min?: AuthorCodingProblemMinAggregateInputType
    _max?: AuthorCodingProblemMaxAggregateInputType
  }


  export type AuthorCodingProblemGroupByOutputType = {
    username: string
    codingProblemId: string
    _count: AuthorCodingProblemCountAggregateOutputType | null
    _min: AuthorCodingProblemMinAggregateOutputType | null
    _max: AuthorCodingProblemMaxAggregateOutputType | null
  }

  type GetAuthorCodingProblemGroupByPayload<T extends AuthorCodingProblemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AuthorCodingProblemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthorCodingProblemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthorCodingProblemGroupByOutputType[P]>
            : GetScalarType<T[P], AuthorCodingProblemGroupByOutputType[P]>
        }
      >
    >


  export type AuthorCodingProblemSelect = {
    username?: boolean
    codingProblemId?: boolean
    user?: boolean | UserArgs
    codingProblem?: boolean | CodingProblemArgs
  }


  export type AuthorCodingProblemInclude = {
    user?: boolean | UserArgs
    codingProblem?: boolean | CodingProblemArgs
  }

  export type AuthorCodingProblemGetPayload<S extends boolean | null | undefined | AuthorCodingProblemArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AuthorCodingProblem :
    S extends undefined ? never :
    S extends { include: any } & (AuthorCodingProblemArgs | AuthorCodingProblemFindManyArgs)
    ? AuthorCodingProblem  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'codingProblem' ? CodingProblemGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (AuthorCodingProblemArgs | AuthorCodingProblemFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'codingProblem' ? CodingProblemGetPayload<S['select'][P]> :  P extends keyof AuthorCodingProblem ? AuthorCodingProblem[P] : never
  } 
      : AuthorCodingProblem


  type AuthorCodingProblemCountArgs = 
    Omit<AuthorCodingProblemFindManyArgs, 'select' | 'include'> & {
      select?: AuthorCodingProblemCountAggregateInputType | true
    }

  export interface AuthorCodingProblemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one AuthorCodingProblem that matches the filter.
     * @param {AuthorCodingProblemFindUniqueArgs} args - Arguments to find a AuthorCodingProblem
     * @example
     * // Get one AuthorCodingProblem
     * const authorCodingProblem = await prisma.authorCodingProblem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AuthorCodingProblemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AuthorCodingProblemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AuthorCodingProblem'> extends True ? Prisma__AuthorCodingProblemClient<AuthorCodingProblemGetPayload<T>> : Prisma__AuthorCodingProblemClient<AuthorCodingProblemGetPayload<T> | null, null>

    /**
     * Find one AuthorCodingProblem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AuthorCodingProblemFindUniqueOrThrowArgs} args - Arguments to find a AuthorCodingProblem
     * @example
     * // Get one AuthorCodingProblem
     * const authorCodingProblem = await prisma.authorCodingProblem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AuthorCodingProblemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AuthorCodingProblemFindUniqueOrThrowArgs>
    ): Prisma__AuthorCodingProblemClient<AuthorCodingProblemGetPayload<T>>

    /**
     * Find the first AuthorCodingProblem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorCodingProblemFindFirstArgs} args - Arguments to find a AuthorCodingProblem
     * @example
     * // Get one AuthorCodingProblem
     * const authorCodingProblem = await prisma.authorCodingProblem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AuthorCodingProblemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AuthorCodingProblemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AuthorCodingProblem'> extends True ? Prisma__AuthorCodingProblemClient<AuthorCodingProblemGetPayload<T>> : Prisma__AuthorCodingProblemClient<AuthorCodingProblemGetPayload<T> | null, null>

    /**
     * Find the first AuthorCodingProblem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorCodingProblemFindFirstOrThrowArgs} args - Arguments to find a AuthorCodingProblem
     * @example
     * // Get one AuthorCodingProblem
     * const authorCodingProblem = await prisma.authorCodingProblem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AuthorCodingProblemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AuthorCodingProblemFindFirstOrThrowArgs>
    ): Prisma__AuthorCodingProblemClient<AuthorCodingProblemGetPayload<T>>

    /**
     * Find zero or more AuthorCodingProblems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorCodingProblemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuthorCodingProblems
     * const authorCodingProblems = await prisma.authorCodingProblem.findMany()
     * 
     * // Get first 10 AuthorCodingProblems
     * const authorCodingProblems = await prisma.authorCodingProblem.findMany({ take: 10 })
     * 
     * // Only select the `username`
     * const authorCodingProblemWithUsernameOnly = await prisma.authorCodingProblem.findMany({ select: { username: true } })
     * 
    **/
    findMany<T extends AuthorCodingProblemFindManyArgs>(
      args?: SelectSubset<T, AuthorCodingProblemFindManyArgs>
    ): Prisma.PrismaPromise<Array<AuthorCodingProblemGetPayload<T>>>

    /**
     * Create a AuthorCodingProblem.
     * @param {AuthorCodingProblemCreateArgs} args - Arguments to create a AuthorCodingProblem.
     * @example
     * // Create one AuthorCodingProblem
     * const AuthorCodingProblem = await prisma.authorCodingProblem.create({
     *   data: {
     *     // ... data to create a AuthorCodingProblem
     *   }
     * })
     * 
    **/
    create<T extends AuthorCodingProblemCreateArgs>(
      args: SelectSubset<T, AuthorCodingProblemCreateArgs>
    ): Prisma__AuthorCodingProblemClient<AuthorCodingProblemGetPayload<T>>

    /**
     * Create many AuthorCodingProblems.
     *     @param {AuthorCodingProblemCreateManyArgs} args - Arguments to create many AuthorCodingProblems.
     *     @example
     *     // Create many AuthorCodingProblems
     *     const authorCodingProblem = await prisma.authorCodingProblem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AuthorCodingProblemCreateManyArgs>(
      args?: SelectSubset<T, AuthorCodingProblemCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AuthorCodingProblem.
     * @param {AuthorCodingProblemDeleteArgs} args - Arguments to delete one AuthorCodingProblem.
     * @example
     * // Delete one AuthorCodingProblem
     * const AuthorCodingProblem = await prisma.authorCodingProblem.delete({
     *   where: {
     *     // ... filter to delete one AuthorCodingProblem
     *   }
     * })
     * 
    **/
    delete<T extends AuthorCodingProblemDeleteArgs>(
      args: SelectSubset<T, AuthorCodingProblemDeleteArgs>
    ): Prisma__AuthorCodingProblemClient<AuthorCodingProblemGetPayload<T>>

    /**
     * Update one AuthorCodingProblem.
     * @param {AuthorCodingProblemUpdateArgs} args - Arguments to update one AuthorCodingProblem.
     * @example
     * // Update one AuthorCodingProblem
     * const authorCodingProblem = await prisma.authorCodingProblem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AuthorCodingProblemUpdateArgs>(
      args: SelectSubset<T, AuthorCodingProblemUpdateArgs>
    ): Prisma__AuthorCodingProblemClient<AuthorCodingProblemGetPayload<T>>

    /**
     * Delete zero or more AuthorCodingProblems.
     * @param {AuthorCodingProblemDeleteManyArgs} args - Arguments to filter AuthorCodingProblems to delete.
     * @example
     * // Delete a few AuthorCodingProblems
     * const { count } = await prisma.authorCodingProblem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AuthorCodingProblemDeleteManyArgs>(
      args?: SelectSubset<T, AuthorCodingProblemDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuthorCodingProblems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorCodingProblemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuthorCodingProblems
     * const authorCodingProblem = await prisma.authorCodingProblem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AuthorCodingProblemUpdateManyArgs>(
      args: SelectSubset<T, AuthorCodingProblemUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuthorCodingProblem.
     * @param {AuthorCodingProblemUpsertArgs} args - Arguments to update or create a AuthorCodingProblem.
     * @example
     * // Update or create a AuthorCodingProblem
     * const authorCodingProblem = await prisma.authorCodingProblem.upsert({
     *   create: {
     *     // ... data to create a AuthorCodingProblem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuthorCodingProblem we want to update
     *   }
     * })
    **/
    upsert<T extends AuthorCodingProblemUpsertArgs>(
      args: SelectSubset<T, AuthorCodingProblemUpsertArgs>
    ): Prisma__AuthorCodingProblemClient<AuthorCodingProblemGetPayload<T>>

    /**
     * Count the number of AuthorCodingProblems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorCodingProblemCountArgs} args - Arguments to filter AuthorCodingProblems to count.
     * @example
     * // Count the number of AuthorCodingProblems
     * const count = await prisma.authorCodingProblem.count({
     *   where: {
     *     // ... the filter for the AuthorCodingProblems we want to count
     *   }
     * })
    **/
    count<T extends AuthorCodingProblemCountArgs>(
      args?: Subset<T, AuthorCodingProblemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthorCodingProblemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuthorCodingProblem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorCodingProblemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthorCodingProblemAggregateArgs>(args: Subset<T, AuthorCodingProblemAggregateArgs>): Prisma.PrismaPromise<GetAuthorCodingProblemAggregateType<T>>

    /**
     * Group by AuthorCodingProblem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorCodingProblemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthorCodingProblemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthorCodingProblemGroupByArgs['orderBy'] }
        : { orderBy?: AuthorCodingProblemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthorCodingProblemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthorCodingProblemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AuthorCodingProblem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AuthorCodingProblemClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    codingProblem<T extends CodingProblemArgs= {}>(args?: Subset<T, CodingProblemArgs>): Prisma__CodingProblemClient<CodingProblemGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AuthorCodingProblem base type for findUnique actions
   */
  export type AuthorCodingProblemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the AuthorCodingProblem
     */
    select?: AuthorCodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorCodingProblemInclude | null
    /**
     * Filter, which AuthorCodingProblem to fetch.
     */
    where: AuthorCodingProblemWhereUniqueInput
  }

  /**
   * AuthorCodingProblem findUnique
   */
  export interface AuthorCodingProblemFindUniqueArgs extends AuthorCodingProblemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AuthorCodingProblem findUniqueOrThrow
   */
  export type AuthorCodingProblemFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AuthorCodingProblem
     */
    select?: AuthorCodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorCodingProblemInclude | null
    /**
     * Filter, which AuthorCodingProblem to fetch.
     */
    where: AuthorCodingProblemWhereUniqueInput
  }


  /**
   * AuthorCodingProblem base type for findFirst actions
   */
  export type AuthorCodingProblemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the AuthorCodingProblem
     */
    select?: AuthorCodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorCodingProblemInclude | null
    /**
     * Filter, which AuthorCodingProblem to fetch.
     */
    where?: AuthorCodingProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthorCodingProblems to fetch.
     */
    orderBy?: Enumerable<AuthorCodingProblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthorCodingProblems.
     */
    cursor?: AuthorCodingProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthorCodingProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthorCodingProblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthorCodingProblems.
     */
    distinct?: Enumerable<AuthorCodingProblemScalarFieldEnum>
  }

  /**
   * AuthorCodingProblem findFirst
   */
  export interface AuthorCodingProblemFindFirstArgs extends AuthorCodingProblemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AuthorCodingProblem findFirstOrThrow
   */
  export type AuthorCodingProblemFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AuthorCodingProblem
     */
    select?: AuthorCodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorCodingProblemInclude | null
    /**
     * Filter, which AuthorCodingProblem to fetch.
     */
    where?: AuthorCodingProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthorCodingProblems to fetch.
     */
    orderBy?: Enumerable<AuthorCodingProblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthorCodingProblems.
     */
    cursor?: AuthorCodingProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthorCodingProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthorCodingProblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthorCodingProblems.
     */
    distinct?: Enumerable<AuthorCodingProblemScalarFieldEnum>
  }


  /**
   * AuthorCodingProblem findMany
   */
  export type AuthorCodingProblemFindManyArgs = {
    /**
     * Select specific fields to fetch from the AuthorCodingProblem
     */
    select?: AuthorCodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorCodingProblemInclude | null
    /**
     * Filter, which AuthorCodingProblems to fetch.
     */
    where?: AuthorCodingProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthorCodingProblems to fetch.
     */
    orderBy?: Enumerable<AuthorCodingProblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuthorCodingProblems.
     */
    cursor?: AuthorCodingProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthorCodingProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthorCodingProblems.
     */
    skip?: number
    distinct?: Enumerable<AuthorCodingProblemScalarFieldEnum>
  }


  /**
   * AuthorCodingProblem create
   */
  export type AuthorCodingProblemCreateArgs = {
    /**
     * Select specific fields to fetch from the AuthorCodingProblem
     */
    select?: AuthorCodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorCodingProblemInclude | null
    /**
     * The data needed to create a AuthorCodingProblem.
     */
    data: XOR<AuthorCodingProblemCreateInput, AuthorCodingProblemUncheckedCreateInput>
  }


  /**
   * AuthorCodingProblem createMany
   */
  export type AuthorCodingProblemCreateManyArgs = {
    /**
     * The data used to create many AuthorCodingProblems.
     */
    data: Enumerable<AuthorCodingProblemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AuthorCodingProblem update
   */
  export type AuthorCodingProblemUpdateArgs = {
    /**
     * Select specific fields to fetch from the AuthorCodingProblem
     */
    select?: AuthorCodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorCodingProblemInclude | null
    /**
     * The data needed to update a AuthorCodingProblem.
     */
    data: XOR<AuthorCodingProblemUpdateInput, AuthorCodingProblemUncheckedUpdateInput>
    /**
     * Choose, which AuthorCodingProblem to update.
     */
    where: AuthorCodingProblemWhereUniqueInput
  }


  /**
   * AuthorCodingProblem updateMany
   */
  export type AuthorCodingProblemUpdateManyArgs = {
    /**
     * The data used to update AuthorCodingProblems.
     */
    data: XOR<AuthorCodingProblemUpdateManyMutationInput, AuthorCodingProblemUncheckedUpdateManyInput>
    /**
     * Filter which AuthorCodingProblems to update
     */
    where?: AuthorCodingProblemWhereInput
  }


  /**
   * AuthorCodingProblem upsert
   */
  export type AuthorCodingProblemUpsertArgs = {
    /**
     * Select specific fields to fetch from the AuthorCodingProblem
     */
    select?: AuthorCodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorCodingProblemInclude | null
    /**
     * The filter to search for the AuthorCodingProblem to update in case it exists.
     */
    where: AuthorCodingProblemWhereUniqueInput
    /**
     * In case the AuthorCodingProblem found by the `where` argument doesn't exist, create a new AuthorCodingProblem with this data.
     */
    create: XOR<AuthorCodingProblemCreateInput, AuthorCodingProblemUncheckedCreateInput>
    /**
     * In case the AuthorCodingProblem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthorCodingProblemUpdateInput, AuthorCodingProblemUncheckedUpdateInput>
  }


  /**
   * AuthorCodingProblem delete
   */
  export type AuthorCodingProblemDeleteArgs = {
    /**
     * Select specific fields to fetch from the AuthorCodingProblem
     */
    select?: AuthorCodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorCodingProblemInclude | null
    /**
     * Filter which AuthorCodingProblem to delete.
     */
    where: AuthorCodingProblemWhereUniqueInput
  }


  /**
   * AuthorCodingProblem deleteMany
   */
  export type AuthorCodingProblemDeleteManyArgs = {
    /**
     * Filter which AuthorCodingProblems to delete
     */
    where?: AuthorCodingProblemWhereInput
  }


  /**
   * AuthorCodingProblem without action
   */
  export type AuthorCodingProblemArgs = {
    /**
     * Select specific fields to fetch from the AuthorCodingProblem
     */
    select?: AuthorCodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorCodingProblemInclude | null
  }



  /**
   * Model TagCodingProblem
   */


  export type AggregateTagCodingProblem = {
    _count: TagCodingProblemCountAggregateOutputType | null
    _avg: TagCodingProblemAvgAggregateOutputType | null
    _sum: TagCodingProblemSumAggregateOutputType | null
    _min: TagCodingProblemMinAggregateOutputType | null
    _max: TagCodingProblemMaxAggregateOutputType | null
  }

  export type TagCodingProblemAvgAggregateOutputType = {
    tagId: number | null
  }

  export type TagCodingProblemSumAggregateOutputType = {
    tagId: number | null
  }

  export type TagCodingProblemMinAggregateOutputType = {
    tagId: number | null
    codingProblemId: string | null
  }

  export type TagCodingProblemMaxAggregateOutputType = {
    tagId: number | null
    codingProblemId: string | null
  }

  export type TagCodingProblemCountAggregateOutputType = {
    tagId: number
    codingProblemId: number
    _all: number
  }


  export type TagCodingProblemAvgAggregateInputType = {
    tagId?: true
  }

  export type TagCodingProblemSumAggregateInputType = {
    tagId?: true
  }

  export type TagCodingProblemMinAggregateInputType = {
    tagId?: true
    codingProblemId?: true
  }

  export type TagCodingProblemMaxAggregateInputType = {
    tagId?: true
    codingProblemId?: true
  }

  export type TagCodingProblemCountAggregateInputType = {
    tagId?: true
    codingProblemId?: true
    _all?: true
  }

  export type TagCodingProblemAggregateArgs = {
    /**
     * Filter which TagCodingProblem to aggregate.
     */
    where?: TagCodingProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagCodingProblems to fetch.
     */
    orderBy?: Enumerable<TagCodingProblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagCodingProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagCodingProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagCodingProblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TagCodingProblems
    **/
    _count?: true | TagCodingProblemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagCodingProblemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagCodingProblemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagCodingProblemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagCodingProblemMaxAggregateInputType
  }

  export type GetTagCodingProblemAggregateType<T extends TagCodingProblemAggregateArgs> = {
        [P in keyof T & keyof AggregateTagCodingProblem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTagCodingProblem[P]>
      : GetScalarType<T[P], AggregateTagCodingProblem[P]>
  }




  export type TagCodingProblemGroupByArgs = {
    where?: TagCodingProblemWhereInput
    orderBy?: Enumerable<TagCodingProblemOrderByWithAggregationInput>
    by: TagCodingProblemScalarFieldEnum[]
    having?: TagCodingProblemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCodingProblemCountAggregateInputType | true
    _avg?: TagCodingProblemAvgAggregateInputType
    _sum?: TagCodingProblemSumAggregateInputType
    _min?: TagCodingProblemMinAggregateInputType
    _max?: TagCodingProblemMaxAggregateInputType
  }


  export type TagCodingProblemGroupByOutputType = {
    tagId: number
    codingProblemId: string
    _count: TagCodingProblemCountAggregateOutputType | null
    _avg: TagCodingProblemAvgAggregateOutputType | null
    _sum: TagCodingProblemSumAggregateOutputType | null
    _min: TagCodingProblemMinAggregateOutputType | null
    _max: TagCodingProblemMaxAggregateOutputType | null
  }

  type GetTagCodingProblemGroupByPayload<T extends TagCodingProblemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TagCodingProblemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagCodingProblemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagCodingProblemGroupByOutputType[P]>
            : GetScalarType<T[P], TagCodingProblemGroupByOutputType[P]>
        }
      >
    >


  export type TagCodingProblemSelect = {
    tagId?: boolean
    codingProblemId?: boolean
    tag?: boolean | CodingProblemTagArgs
    codingProblem?: boolean | CodingProblemArgs
  }


  export type TagCodingProblemInclude = {
    tag?: boolean | CodingProblemTagArgs
    codingProblem?: boolean | CodingProblemArgs
  }

  export type TagCodingProblemGetPayload<S extends boolean | null | undefined | TagCodingProblemArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TagCodingProblem :
    S extends undefined ? never :
    S extends { include: any } & (TagCodingProblemArgs | TagCodingProblemFindManyArgs)
    ? TagCodingProblem  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'tag' ? CodingProblemTagGetPayload<S['include'][P]> :
        P extends 'codingProblem' ? CodingProblemGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TagCodingProblemArgs | TagCodingProblemFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'tag' ? CodingProblemTagGetPayload<S['select'][P]> :
        P extends 'codingProblem' ? CodingProblemGetPayload<S['select'][P]> :  P extends keyof TagCodingProblem ? TagCodingProblem[P] : never
  } 
      : TagCodingProblem


  type TagCodingProblemCountArgs = 
    Omit<TagCodingProblemFindManyArgs, 'select' | 'include'> & {
      select?: TagCodingProblemCountAggregateInputType | true
    }

  export interface TagCodingProblemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TagCodingProblem that matches the filter.
     * @param {TagCodingProblemFindUniqueArgs} args - Arguments to find a TagCodingProblem
     * @example
     * // Get one TagCodingProblem
     * const tagCodingProblem = await prisma.tagCodingProblem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TagCodingProblemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TagCodingProblemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TagCodingProblem'> extends True ? Prisma__TagCodingProblemClient<TagCodingProblemGetPayload<T>> : Prisma__TagCodingProblemClient<TagCodingProblemGetPayload<T> | null, null>

    /**
     * Find one TagCodingProblem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TagCodingProblemFindUniqueOrThrowArgs} args - Arguments to find a TagCodingProblem
     * @example
     * // Get one TagCodingProblem
     * const tagCodingProblem = await prisma.tagCodingProblem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TagCodingProblemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TagCodingProblemFindUniqueOrThrowArgs>
    ): Prisma__TagCodingProblemClient<TagCodingProblemGetPayload<T>>

    /**
     * Find the first TagCodingProblem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCodingProblemFindFirstArgs} args - Arguments to find a TagCodingProblem
     * @example
     * // Get one TagCodingProblem
     * const tagCodingProblem = await prisma.tagCodingProblem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TagCodingProblemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TagCodingProblemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TagCodingProblem'> extends True ? Prisma__TagCodingProblemClient<TagCodingProblemGetPayload<T>> : Prisma__TagCodingProblemClient<TagCodingProblemGetPayload<T> | null, null>

    /**
     * Find the first TagCodingProblem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCodingProblemFindFirstOrThrowArgs} args - Arguments to find a TagCodingProblem
     * @example
     * // Get one TagCodingProblem
     * const tagCodingProblem = await prisma.tagCodingProblem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TagCodingProblemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TagCodingProblemFindFirstOrThrowArgs>
    ): Prisma__TagCodingProblemClient<TagCodingProblemGetPayload<T>>

    /**
     * Find zero or more TagCodingProblems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCodingProblemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TagCodingProblems
     * const tagCodingProblems = await prisma.tagCodingProblem.findMany()
     * 
     * // Get first 10 TagCodingProblems
     * const tagCodingProblems = await prisma.tagCodingProblem.findMany({ take: 10 })
     * 
     * // Only select the `tagId`
     * const tagCodingProblemWithTagIdOnly = await prisma.tagCodingProblem.findMany({ select: { tagId: true } })
     * 
    **/
    findMany<T extends TagCodingProblemFindManyArgs>(
      args?: SelectSubset<T, TagCodingProblemFindManyArgs>
    ): Prisma.PrismaPromise<Array<TagCodingProblemGetPayload<T>>>

    /**
     * Create a TagCodingProblem.
     * @param {TagCodingProblemCreateArgs} args - Arguments to create a TagCodingProblem.
     * @example
     * // Create one TagCodingProblem
     * const TagCodingProblem = await prisma.tagCodingProblem.create({
     *   data: {
     *     // ... data to create a TagCodingProblem
     *   }
     * })
     * 
    **/
    create<T extends TagCodingProblemCreateArgs>(
      args: SelectSubset<T, TagCodingProblemCreateArgs>
    ): Prisma__TagCodingProblemClient<TagCodingProblemGetPayload<T>>

    /**
     * Create many TagCodingProblems.
     *     @param {TagCodingProblemCreateManyArgs} args - Arguments to create many TagCodingProblems.
     *     @example
     *     // Create many TagCodingProblems
     *     const tagCodingProblem = await prisma.tagCodingProblem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TagCodingProblemCreateManyArgs>(
      args?: SelectSubset<T, TagCodingProblemCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TagCodingProblem.
     * @param {TagCodingProblemDeleteArgs} args - Arguments to delete one TagCodingProblem.
     * @example
     * // Delete one TagCodingProblem
     * const TagCodingProblem = await prisma.tagCodingProblem.delete({
     *   where: {
     *     // ... filter to delete one TagCodingProblem
     *   }
     * })
     * 
    **/
    delete<T extends TagCodingProblemDeleteArgs>(
      args: SelectSubset<T, TagCodingProblemDeleteArgs>
    ): Prisma__TagCodingProblemClient<TagCodingProblemGetPayload<T>>

    /**
     * Update one TagCodingProblem.
     * @param {TagCodingProblemUpdateArgs} args - Arguments to update one TagCodingProblem.
     * @example
     * // Update one TagCodingProblem
     * const tagCodingProblem = await prisma.tagCodingProblem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TagCodingProblemUpdateArgs>(
      args: SelectSubset<T, TagCodingProblemUpdateArgs>
    ): Prisma__TagCodingProblemClient<TagCodingProblemGetPayload<T>>

    /**
     * Delete zero or more TagCodingProblems.
     * @param {TagCodingProblemDeleteManyArgs} args - Arguments to filter TagCodingProblems to delete.
     * @example
     * // Delete a few TagCodingProblems
     * const { count } = await prisma.tagCodingProblem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TagCodingProblemDeleteManyArgs>(
      args?: SelectSubset<T, TagCodingProblemDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TagCodingProblems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCodingProblemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TagCodingProblems
     * const tagCodingProblem = await prisma.tagCodingProblem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TagCodingProblemUpdateManyArgs>(
      args: SelectSubset<T, TagCodingProblemUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TagCodingProblem.
     * @param {TagCodingProblemUpsertArgs} args - Arguments to update or create a TagCodingProblem.
     * @example
     * // Update or create a TagCodingProblem
     * const tagCodingProblem = await prisma.tagCodingProblem.upsert({
     *   create: {
     *     // ... data to create a TagCodingProblem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TagCodingProblem we want to update
     *   }
     * })
    **/
    upsert<T extends TagCodingProblemUpsertArgs>(
      args: SelectSubset<T, TagCodingProblemUpsertArgs>
    ): Prisma__TagCodingProblemClient<TagCodingProblemGetPayload<T>>

    /**
     * Count the number of TagCodingProblems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCodingProblemCountArgs} args - Arguments to filter TagCodingProblems to count.
     * @example
     * // Count the number of TagCodingProblems
     * const count = await prisma.tagCodingProblem.count({
     *   where: {
     *     // ... the filter for the TagCodingProblems we want to count
     *   }
     * })
    **/
    count<T extends TagCodingProblemCountArgs>(
      args?: Subset<T, TagCodingProblemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCodingProblemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TagCodingProblem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCodingProblemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagCodingProblemAggregateArgs>(args: Subset<T, TagCodingProblemAggregateArgs>): Prisma.PrismaPromise<GetTagCodingProblemAggregateType<T>>

    /**
     * Group by TagCodingProblem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCodingProblemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagCodingProblemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagCodingProblemGroupByArgs['orderBy'] }
        : { orderBy?: TagCodingProblemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagCodingProblemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagCodingProblemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TagCodingProblem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TagCodingProblemClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    tag<T extends CodingProblemTagArgs= {}>(args?: Subset<T, CodingProblemTagArgs>): Prisma__CodingProblemTagClient<CodingProblemTagGetPayload<T> | Null>;

    codingProblem<T extends CodingProblemArgs= {}>(args?: Subset<T, CodingProblemArgs>): Prisma__CodingProblemClient<CodingProblemGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TagCodingProblem base type for findUnique actions
   */
  export type TagCodingProblemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TagCodingProblem
     */
    select?: TagCodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagCodingProblemInclude | null
    /**
     * Filter, which TagCodingProblem to fetch.
     */
    where: TagCodingProblemWhereUniqueInput
  }

  /**
   * TagCodingProblem findUnique
   */
  export interface TagCodingProblemFindUniqueArgs extends TagCodingProblemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TagCodingProblem findUniqueOrThrow
   */
  export type TagCodingProblemFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TagCodingProblem
     */
    select?: TagCodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagCodingProblemInclude | null
    /**
     * Filter, which TagCodingProblem to fetch.
     */
    where: TagCodingProblemWhereUniqueInput
  }


  /**
   * TagCodingProblem base type for findFirst actions
   */
  export type TagCodingProblemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TagCodingProblem
     */
    select?: TagCodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagCodingProblemInclude | null
    /**
     * Filter, which TagCodingProblem to fetch.
     */
    where?: TagCodingProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagCodingProblems to fetch.
     */
    orderBy?: Enumerable<TagCodingProblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TagCodingProblems.
     */
    cursor?: TagCodingProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagCodingProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagCodingProblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TagCodingProblems.
     */
    distinct?: Enumerable<TagCodingProblemScalarFieldEnum>
  }

  /**
   * TagCodingProblem findFirst
   */
  export interface TagCodingProblemFindFirstArgs extends TagCodingProblemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TagCodingProblem findFirstOrThrow
   */
  export type TagCodingProblemFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TagCodingProblem
     */
    select?: TagCodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagCodingProblemInclude | null
    /**
     * Filter, which TagCodingProblem to fetch.
     */
    where?: TagCodingProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagCodingProblems to fetch.
     */
    orderBy?: Enumerable<TagCodingProblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TagCodingProblems.
     */
    cursor?: TagCodingProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagCodingProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagCodingProblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TagCodingProblems.
     */
    distinct?: Enumerable<TagCodingProblemScalarFieldEnum>
  }


  /**
   * TagCodingProblem findMany
   */
  export type TagCodingProblemFindManyArgs = {
    /**
     * Select specific fields to fetch from the TagCodingProblem
     */
    select?: TagCodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagCodingProblemInclude | null
    /**
     * Filter, which TagCodingProblems to fetch.
     */
    where?: TagCodingProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagCodingProblems to fetch.
     */
    orderBy?: Enumerable<TagCodingProblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TagCodingProblems.
     */
    cursor?: TagCodingProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagCodingProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagCodingProblems.
     */
    skip?: number
    distinct?: Enumerable<TagCodingProblemScalarFieldEnum>
  }


  /**
   * TagCodingProblem create
   */
  export type TagCodingProblemCreateArgs = {
    /**
     * Select specific fields to fetch from the TagCodingProblem
     */
    select?: TagCodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagCodingProblemInclude | null
    /**
     * The data needed to create a TagCodingProblem.
     */
    data: XOR<TagCodingProblemCreateInput, TagCodingProblemUncheckedCreateInput>
  }


  /**
   * TagCodingProblem createMany
   */
  export type TagCodingProblemCreateManyArgs = {
    /**
     * The data used to create many TagCodingProblems.
     */
    data: Enumerable<TagCodingProblemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TagCodingProblem update
   */
  export type TagCodingProblemUpdateArgs = {
    /**
     * Select specific fields to fetch from the TagCodingProblem
     */
    select?: TagCodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagCodingProblemInclude | null
    /**
     * The data needed to update a TagCodingProblem.
     */
    data: XOR<TagCodingProblemUpdateInput, TagCodingProblemUncheckedUpdateInput>
    /**
     * Choose, which TagCodingProblem to update.
     */
    where: TagCodingProblemWhereUniqueInput
  }


  /**
   * TagCodingProblem updateMany
   */
  export type TagCodingProblemUpdateManyArgs = {
    /**
     * The data used to update TagCodingProblems.
     */
    data: XOR<TagCodingProblemUpdateManyMutationInput, TagCodingProblemUncheckedUpdateManyInput>
    /**
     * Filter which TagCodingProblems to update
     */
    where?: TagCodingProblemWhereInput
  }


  /**
   * TagCodingProblem upsert
   */
  export type TagCodingProblemUpsertArgs = {
    /**
     * Select specific fields to fetch from the TagCodingProblem
     */
    select?: TagCodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagCodingProblemInclude | null
    /**
     * The filter to search for the TagCodingProblem to update in case it exists.
     */
    where: TagCodingProblemWhereUniqueInput
    /**
     * In case the TagCodingProblem found by the `where` argument doesn't exist, create a new TagCodingProblem with this data.
     */
    create: XOR<TagCodingProblemCreateInput, TagCodingProblemUncheckedCreateInput>
    /**
     * In case the TagCodingProblem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagCodingProblemUpdateInput, TagCodingProblemUncheckedUpdateInput>
  }


  /**
   * TagCodingProblem delete
   */
  export type TagCodingProblemDeleteArgs = {
    /**
     * Select specific fields to fetch from the TagCodingProblem
     */
    select?: TagCodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagCodingProblemInclude | null
    /**
     * Filter which TagCodingProblem to delete.
     */
    where: TagCodingProblemWhereUniqueInput
  }


  /**
   * TagCodingProblem deleteMany
   */
  export type TagCodingProblemDeleteManyArgs = {
    /**
     * Filter which TagCodingProblems to delete
     */
    where?: TagCodingProblemWhereInput
  }


  /**
   * TagCodingProblem without action
   */
  export type TagCodingProblemArgs = {
    /**
     * Select specific fields to fetch from the TagCodingProblem
     */
    select?: TagCodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagCodingProblemInclude | null
  }



  /**
   * Model Thread
   */


  export type AggregateThread = {
    _count: ThreadCountAggregateOutputType | null
    _avg: ThreadAvgAggregateOutputType | null
    _sum: ThreadSumAggregateOutputType | null
    _min: ThreadMinAggregateOutputType | null
    _max: ThreadMaxAggregateOutputType | null
  }

  export type ThreadAvgAggregateOutputType = {
    totalComments: number | null
    totalRootComments: number | null
    likes: number | null
    views: number | null
    categoryId: number | null
  }

  export type ThreadSumAggregateOutputType = {
    totalComments: number | null
    totalRootComments: number | null
    likes: number | null
    views: number | null
    categoryId: number | null
  }

  export type ThreadMinAggregateOutputType = {
    id: string | null
    authorId: string | null
    parentId: string | null
    title: string | null
    summary: string | null
    published: boolean | null
    createdAt: Date | null
    lastUpdateAt: Date | null
    publishedAt: Date | null
    content: string | null
    totalComments: number | null
    totalRootComments: number | null
    likes: number | null
    views: number | null
    categoryId: number | null
  }

  export type ThreadMaxAggregateOutputType = {
    id: string | null
    authorId: string | null
    parentId: string | null
    title: string | null
    summary: string | null
    published: boolean | null
    createdAt: Date | null
    lastUpdateAt: Date | null
    publishedAt: Date | null
    content: string | null
    totalComments: number | null
    totalRootComments: number | null
    likes: number | null
    views: number | null
    categoryId: number | null
  }

  export type ThreadCountAggregateOutputType = {
    id: number
    authorId: number
    parentId: number
    title: number
    summary: number
    published: number
    createdAt: number
    lastUpdateAt: number
    publishedAt: number
    content: number
    totalComments: number
    totalRootComments: number
    likes: number
    views: number
    categoryId: number
    _all: number
  }


  export type ThreadAvgAggregateInputType = {
    totalComments?: true
    totalRootComments?: true
    likes?: true
    views?: true
    categoryId?: true
  }

  export type ThreadSumAggregateInputType = {
    totalComments?: true
    totalRootComments?: true
    likes?: true
    views?: true
    categoryId?: true
  }

  export type ThreadMinAggregateInputType = {
    id?: true
    authorId?: true
    parentId?: true
    title?: true
    summary?: true
    published?: true
    createdAt?: true
    lastUpdateAt?: true
    publishedAt?: true
    content?: true
    totalComments?: true
    totalRootComments?: true
    likes?: true
    views?: true
    categoryId?: true
  }

  export type ThreadMaxAggregateInputType = {
    id?: true
    authorId?: true
    parentId?: true
    title?: true
    summary?: true
    published?: true
    createdAt?: true
    lastUpdateAt?: true
    publishedAt?: true
    content?: true
    totalComments?: true
    totalRootComments?: true
    likes?: true
    views?: true
    categoryId?: true
  }

  export type ThreadCountAggregateInputType = {
    id?: true
    authorId?: true
    parentId?: true
    title?: true
    summary?: true
    published?: true
    createdAt?: true
    lastUpdateAt?: true
    publishedAt?: true
    content?: true
    totalComments?: true
    totalRootComments?: true
    likes?: true
    views?: true
    categoryId?: true
    _all?: true
  }

  export type ThreadAggregateArgs = {
    /**
     * Filter which Thread to aggregate.
     */
    where?: ThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Threads to fetch.
     */
    orderBy?: Enumerable<ThreadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Threads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Threads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Threads
    **/
    _count?: true | ThreadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ThreadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ThreadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ThreadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ThreadMaxAggregateInputType
  }

  export type GetThreadAggregateType<T extends ThreadAggregateArgs> = {
        [P in keyof T & keyof AggregateThread]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThread[P]>
      : GetScalarType<T[P], AggregateThread[P]>
  }




  export type ThreadGroupByArgs = {
    where?: ThreadWhereInput
    orderBy?: Enumerable<ThreadOrderByWithAggregationInput>
    by: ThreadScalarFieldEnum[]
    having?: ThreadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ThreadCountAggregateInputType | true
    _avg?: ThreadAvgAggregateInputType
    _sum?: ThreadSumAggregateInputType
    _min?: ThreadMinAggregateInputType
    _max?: ThreadMaxAggregateInputType
  }


  export type ThreadGroupByOutputType = {
    id: string
    authorId: string
    parentId: string | null
    title: string
    summary: string
    published: boolean
    createdAt: Date
    lastUpdateAt: Date
    publishedAt: Date
    content: string
    totalComments: number
    totalRootComments: number
    likes: number
    views: number
    categoryId: number | null
    _count: ThreadCountAggregateOutputType | null
    _avg: ThreadAvgAggregateOutputType | null
    _sum: ThreadSumAggregateOutputType | null
    _min: ThreadMinAggregateOutputType | null
    _max: ThreadMaxAggregateOutputType | null
  }

  type GetThreadGroupByPayload<T extends ThreadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ThreadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ThreadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThreadGroupByOutputType[P]>
            : GetScalarType<T[P], ThreadGroupByOutputType[P]>
        }
      >
    >


  export type ThreadSelect = {
    id?: boolean
    authorId?: boolean
    parentId?: boolean
    title?: boolean
    summary?: boolean
    published?: boolean
    createdAt?: boolean
    lastUpdateAt?: boolean
    publishedAt?: boolean
    content?: boolean
    totalComments?: boolean
    totalRootComments?: boolean
    likes?: boolean
    views?: boolean
    categoryId?: boolean
    author?: boolean | UserArgs
    comments?: boolean | Thread$commentsArgs
    category?: boolean | ThreadCategoryArgs
    tags?: boolean | Thread$tagsArgs
    userLikes?: boolean | Thread$userLikesArgs
    _count?: boolean | ThreadCountOutputTypeArgs
  }


  export type ThreadInclude = {
    author?: boolean | UserArgs
    comments?: boolean | Thread$commentsArgs
    category?: boolean | ThreadCategoryArgs
    tags?: boolean | Thread$tagsArgs
    userLikes?: boolean | Thread$userLikesArgs
    _count?: boolean | ThreadCountOutputTypeArgs
  }

  export type ThreadGetPayload<S extends boolean | null | undefined | ThreadArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Thread :
    S extends undefined ? never :
    S extends { include: any } & (ThreadArgs | ThreadFindManyArgs)
    ? Thread  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'author' ? UserGetPayload<S['include'][P]> :
        P extends 'comments' ? Array < CommentGetPayload<S['include'][P]>>  :
        P extends 'category' ? ThreadCategoryGetPayload<S['include'][P]> | null :
        P extends 'tags' ? Array < ThreadTagRelGetPayload<S['include'][P]>>  :
        P extends 'userLikes' ? Array < UserLikeThreadGetPayload<S['include'][P]>>  :
        P extends '_count' ? ThreadCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ThreadArgs | ThreadFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'author' ? UserGetPayload<S['select'][P]> :
        P extends 'comments' ? Array < CommentGetPayload<S['select'][P]>>  :
        P extends 'category' ? ThreadCategoryGetPayload<S['select'][P]> | null :
        P extends 'tags' ? Array < ThreadTagRelGetPayload<S['select'][P]>>  :
        P extends 'userLikes' ? Array < UserLikeThreadGetPayload<S['select'][P]>>  :
        P extends '_count' ? ThreadCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Thread ? Thread[P] : never
  } 
      : Thread


  type ThreadCountArgs = 
    Omit<ThreadFindManyArgs, 'select' | 'include'> & {
      select?: ThreadCountAggregateInputType | true
    }

  export interface ThreadDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Thread that matches the filter.
     * @param {ThreadFindUniqueArgs} args - Arguments to find a Thread
     * @example
     * // Get one Thread
     * const thread = await prisma.thread.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ThreadFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ThreadFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Thread'> extends True ? Prisma__ThreadClient<ThreadGetPayload<T>> : Prisma__ThreadClient<ThreadGetPayload<T> | null, null>

    /**
     * Find one Thread that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ThreadFindUniqueOrThrowArgs} args - Arguments to find a Thread
     * @example
     * // Get one Thread
     * const thread = await prisma.thread.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ThreadFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ThreadFindUniqueOrThrowArgs>
    ): Prisma__ThreadClient<ThreadGetPayload<T>>

    /**
     * Find the first Thread that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadFindFirstArgs} args - Arguments to find a Thread
     * @example
     * // Get one Thread
     * const thread = await prisma.thread.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ThreadFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ThreadFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Thread'> extends True ? Prisma__ThreadClient<ThreadGetPayload<T>> : Prisma__ThreadClient<ThreadGetPayload<T> | null, null>

    /**
     * Find the first Thread that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadFindFirstOrThrowArgs} args - Arguments to find a Thread
     * @example
     * // Get one Thread
     * const thread = await prisma.thread.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ThreadFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ThreadFindFirstOrThrowArgs>
    ): Prisma__ThreadClient<ThreadGetPayload<T>>

    /**
     * Find zero or more Threads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Threads
     * const threads = await prisma.thread.findMany()
     * 
     * // Get first 10 Threads
     * const threads = await prisma.thread.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const threadWithIdOnly = await prisma.thread.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ThreadFindManyArgs>(
      args?: SelectSubset<T, ThreadFindManyArgs>
    ): Prisma.PrismaPromise<Array<ThreadGetPayload<T>>>

    /**
     * Create a Thread.
     * @param {ThreadCreateArgs} args - Arguments to create a Thread.
     * @example
     * // Create one Thread
     * const Thread = await prisma.thread.create({
     *   data: {
     *     // ... data to create a Thread
     *   }
     * })
     * 
    **/
    create<T extends ThreadCreateArgs>(
      args: SelectSubset<T, ThreadCreateArgs>
    ): Prisma__ThreadClient<ThreadGetPayload<T>>

    /**
     * Create many Threads.
     *     @param {ThreadCreateManyArgs} args - Arguments to create many Threads.
     *     @example
     *     // Create many Threads
     *     const thread = await prisma.thread.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ThreadCreateManyArgs>(
      args?: SelectSubset<T, ThreadCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Thread.
     * @param {ThreadDeleteArgs} args - Arguments to delete one Thread.
     * @example
     * // Delete one Thread
     * const Thread = await prisma.thread.delete({
     *   where: {
     *     // ... filter to delete one Thread
     *   }
     * })
     * 
    **/
    delete<T extends ThreadDeleteArgs>(
      args: SelectSubset<T, ThreadDeleteArgs>
    ): Prisma__ThreadClient<ThreadGetPayload<T>>

    /**
     * Update one Thread.
     * @param {ThreadUpdateArgs} args - Arguments to update one Thread.
     * @example
     * // Update one Thread
     * const thread = await prisma.thread.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ThreadUpdateArgs>(
      args: SelectSubset<T, ThreadUpdateArgs>
    ): Prisma__ThreadClient<ThreadGetPayload<T>>

    /**
     * Delete zero or more Threads.
     * @param {ThreadDeleteManyArgs} args - Arguments to filter Threads to delete.
     * @example
     * // Delete a few Threads
     * const { count } = await prisma.thread.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ThreadDeleteManyArgs>(
      args?: SelectSubset<T, ThreadDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Threads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Threads
     * const thread = await prisma.thread.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ThreadUpdateManyArgs>(
      args: SelectSubset<T, ThreadUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Thread.
     * @param {ThreadUpsertArgs} args - Arguments to update or create a Thread.
     * @example
     * // Update or create a Thread
     * const thread = await prisma.thread.upsert({
     *   create: {
     *     // ... data to create a Thread
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Thread we want to update
     *   }
     * })
    **/
    upsert<T extends ThreadUpsertArgs>(
      args: SelectSubset<T, ThreadUpsertArgs>
    ): Prisma__ThreadClient<ThreadGetPayload<T>>

    /**
     * Count the number of Threads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadCountArgs} args - Arguments to filter Threads to count.
     * @example
     * // Count the number of Threads
     * const count = await prisma.thread.count({
     *   where: {
     *     // ... the filter for the Threads we want to count
     *   }
     * })
    **/
    count<T extends ThreadCountArgs>(
      args?: Subset<T, ThreadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThreadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Thread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ThreadAggregateArgs>(args: Subset<T, ThreadAggregateArgs>): Prisma.PrismaPromise<GetThreadAggregateType<T>>

    /**
     * Group by Thread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ThreadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThreadGroupByArgs['orderBy'] }
        : { orderBy?: ThreadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ThreadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThreadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Thread.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ThreadClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    author<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    comments<T extends Thread$commentsArgs= {}>(args?: Subset<T, Thread$commentsArgs>): Prisma.PrismaPromise<Array<CommentGetPayload<T>>| Null>;

    category<T extends ThreadCategoryArgs= {}>(args?: Subset<T, ThreadCategoryArgs>): Prisma__ThreadCategoryClient<ThreadCategoryGetPayload<T> | Null>;

    tags<T extends Thread$tagsArgs= {}>(args?: Subset<T, Thread$tagsArgs>): Prisma.PrismaPromise<Array<ThreadTagRelGetPayload<T>>| Null>;

    userLikes<T extends Thread$userLikesArgs= {}>(args?: Subset<T, Thread$userLikesArgs>): Prisma.PrismaPromise<Array<UserLikeThreadGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Thread base type for findUnique actions
   */
  export type ThreadFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadInclude | null
    /**
     * Filter, which Thread to fetch.
     */
    where: ThreadWhereUniqueInput
  }

  /**
   * Thread findUnique
   */
  export interface ThreadFindUniqueArgs extends ThreadFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Thread findUniqueOrThrow
   */
  export type ThreadFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadInclude | null
    /**
     * Filter, which Thread to fetch.
     */
    where: ThreadWhereUniqueInput
  }


  /**
   * Thread base type for findFirst actions
   */
  export type ThreadFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadInclude | null
    /**
     * Filter, which Thread to fetch.
     */
    where?: ThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Threads to fetch.
     */
    orderBy?: Enumerable<ThreadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Threads.
     */
    cursor?: ThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Threads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Threads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Threads.
     */
    distinct?: Enumerable<ThreadScalarFieldEnum>
  }

  /**
   * Thread findFirst
   */
  export interface ThreadFindFirstArgs extends ThreadFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Thread findFirstOrThrow
   */
  export type ThreadFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadInclude | null
    /**
     * Filter, which Thread to fetch.
     */
    where?: ThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Threads to fetch.
     */
    orderBy?: Enumerable<ThreadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Threads.
     */
    cursor?: ThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Threads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Threads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Threads.
     */
    distinct?: Enumerable<ThreadScalarFieldEnum>
  }


  /**
   * Thread findMany
   */
  export type ThreadFindManyArgs = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadInclude | null
    /**
     * Filter, which Threads to fetch.
     */
    where?: ThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Threads to fetch.
     */
    orderBy?: Enumerable<ThreadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Threads.
     */
    cursor?: ThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Threads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Threads.
     */
    skip?: number
    distinct?: Enumerable<ThreadScalarFieldEnum>
  }


  /**
   * Thread create
   */
  export type ThreadCreateArgs = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadInclude | null
    /**
     * The data needed to create a Thread.
     */
    data: XOR<ThreadCreateInput, ThreadUncheckedCreateInput>
  }


  /**
   * Thread createMany
   */
  export type ThreadCreateManyArgs = {
    /**
     * The data used to create many Threads.
     */
    data: Enumerable<ThreadCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Thread update
   */
  export type ThreadUpdateArgs = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadInclude | null
    /**
     * The data needed to update a Thread.
     */
    data: XOR<ThreadUpdateInput, ThreadUncheckedUpdateInput>
    /**
     * Choose, which Thread to update.
     */
    where: ThreadWhereUniqueInput
  }


  /**
   * Thread updateMany
   */
  export type ThreadUpdateManyArgs = {
    /**
     * The data used to update Threads.
     */
    data: XOR<ThreadUpdateManyMutationInput, ThreadUncheckedUpdateManyInput>
    /**
     * Filter which Threads to update
     */
    where?: ThreadWhereInput
  }


  /**
   * Thread upsert
   */
  export type ThreadUpsertArgs = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadInclude | null
    /**
     * The filter to search for the Thread to update in case it exists.
     */
    where: ThreadWhereUniqueInput
    /**
     * In case the Thread found by the `where` argument doesn't exist, create a new Thread with this data.
     */
    create: XOR<ThreadCreateInput, ThreadUncheckedCreateInput>
    /**
     * In case the Thread was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThreadUpdateInput, ThreadUncheckedUpdateInput>
  }


  /**
   * Thread delete
   */
  export type ThreadDeleteArgs = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadInclude | null
    /**
     * Filter which Thread to delete.
     */
    where: ThreadWhereUniqueInput
  }


  /**
   * Thread deleteMany
   */
  export type ThreadDeleteManyArgs = {
    /**
     * Filter which Threads to delete
     */
    where?: ThreadWhereInput
  }


  /**
   * Thread.comments
   */
  export type Thread$commentsArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    where?: CommentWhereInput
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * Thread.tags
   */
  export type Thread$tagsArgs = {
    /**
     * Select specific fields to fetch from the ThreadTagRel
     */
    select?: ThreadTagRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadTagRelInclude | null
    where?: ThreadTagRelWhereInput
    orderBy?: Enumerable<ThreadTagRelOrderByWithRelationInput>
    cursor?: ThreadTagRelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ThreadTagRelScalarFieldEnum>
  }


  /**
   * Thread.userLikes
   */
  export type Thread$userLikesArgs = {
    /**
     * Select specific fields to fetch from the UserLikeThread
     */
    select?: UserLikeThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLikeThreadInclude | null
    where?: UserLikeThreadWhereInput
    orderBy?: Enumerable<UserLikeThreadOrderByWithRelationInput>
    cursor?: UserLikeThreadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserLikeThreadScalarFieldEnum>
  }


  /**
   * Thread without action
   */
  export type ThreadArgs = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadInclude | null
  }



  /**
   * Model ThreadCategory
   */


  export type AggregateThreadCategory = {
    _count: ThreadCategoryCountAggregateOutputType | null
    _avg: ThreadCategoryAvgAggregateOutputType | null
    _sum: ThreadCategorySumAggregateOutputType | null
    _min: ThreadCategoryMinAggregateOutputType | null
    _max: ThreadCategoryMaxAggregateOutputType | null
  }

  export type ThreadCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type ThreadCategorySumAggregateOutputType = {
    id: number | null
  }

  export type ThreadCategoryMinAggregateOutputType = {
    id: number | null
    parentId: string | null
    title: string | null
  }

  export type ThreadCategoryMaxAggregateOutputType = {
    id: number | null
    parentId: string | null
    title: string | null
  }

  export type ThreadCategoryCountAggregateOutputType = {
    id: number
    parentId: number
    title: number
    _all: number
  }


  export type ThreadCategoryAvgAggregateInputType = {
    id?: true
  }

  export type ThreadCategorySumAggregateInputType = {
    id?: true
  }

  export type ThreadCategoryMinAggregateInputType = {
    id?: true
    parentId?: true
    title?: true
  }

  export type ThreadCategoryMaxAggregateInputType = {
    id?: true
    parentId?: true
    title?: true
  }

  export type ThreadCategoryCountAggregateInputType = {
    id?: true
    parentId?: true
    title?: true
    _all?: true
  }

  export type ThreadCategoryAggregateArgs = {
    /**
     * Filter which ThreadCategory to aggregate.
     */
    where?: ThreadCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreadCategories to fetch.
     */
    orderBy?: Enumerable<ThreadCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ThreadCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreadCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreadCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ThreadCategories
    **/
    _count?: true | ThreadCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ThreadCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ThreadCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ThreadCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ThreadCategoryMaxAggregateInputType
  }

  export type GetThreadCategoryAggregateType<T extends ThreadCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateThreadCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThreadCategory[P]>
      : GetScalarType<T[P], AggregateThreadCategory[P]>
  }




  export type ThreadCategoryGroupByArgs = {
    where?: ThreadCategoryWhereInput
    orderBy?: Enumerable<ThreadCategoryOrderByWithAggregationInput>
    by: ThreadCategoryScalarFieldEnum[]
    having?: ThreadCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ThreadCategoryCountAggregateInputType | true
    _avg?: ThreadCategoryAvgAggregateInputType
    _sum?: ThreadCategorySumAggregateInputType
    _min?: ThreadCategoryMinAggregateInputType
    _max?: ThreadCategoryMaxAggregateInputType
  }


  export type ThreadCategoryGroupByOutputType = {
    id: number
    parentId: string | null
    title: string
    _count: ThreadCategoryCountAggregateOutputType | null
    _avg: ThreadCategoryAvgAggregateOutputType | null
    _sum: ThreadCategorySumAggregateOutputType | null
    _min: ThreadCategoryMinAggregateOutputType | null
    _max: ThreadCategoryMaxAggregateOutputType | null
  }

  type GetThreadCategoryGroupByPayload<T extends ThreadCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ThreadCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ThreadCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThreadCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ThreadCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ThreadCategorySelect = {
    id?: boolean
    parentId?: boolean
    title?: boolean
    threads?: boolean | ThreadCategory$threadsArgs
    _count?: boolean | ThreadCategoryCountOutputTypeArgs
  }


  export type ThreadCategoryInclude = {
    threads?: boolean | ThreadCategory$threadsArgs
    _count?: boolean | ThreadCategoryCountOutputTypeArgs
  }

  export type ThreadCategoryGetPayload<S extends boolean | null | undefined | ThreadCategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ThreadCategory :
    S extends undefined ? never :
    S extends { include: any } & (ThreadCategoryArgs | ThreadCategoryFindManyArgs)
    ? ThreadCategory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'threads' ? Array < ThreadGetPayload<S['include'][P]>>  :
        P extends '_count' ? ThreadCategoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ThreadCategoryArgs | ThreadCategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'threads' ? Array < ThreadGetPayload<S['select'][P]>>  :
        P extends '_count' ? ThreadCategoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ThreadCategory ? ThreadCategory[P] : never
  } 
      : ThreadCategory


  type ThreadCategoryCountArgs = 
    Omit<ThreadCategoryFindManyArgs, 'select' | 'include'> & {
      select?: ThreadCategoryCountAggregateInputType | true
    }

  export interface ThreadCategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ThreadCategory that matches the filter.
     * @param {ThreadCategoryFindUniqueArgs} args - Arguments to find a ThreadCategory
     * @example
     * // Get one ThreadCategory
     * const threadCategory = await prisma.threadCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ThreadCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ThreadCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ThreadCategory'> extends True ? Prisma__ThreadCategoryClient<ThreadCategoryGetPayload<T>> : Prisma__ThreadCategoryClient<ThreadCategoryGetPayload<T> | null, null>

    /**
     * Find one ThreadCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ThreadCategoryFindUniqueOrThrowArgs} args - Arguments to find a ThreadCategory
     * @example
     * // Get one ThreadCategory
     * const threadCategory = await prisma.threadCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ThreadCategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ThreadCategoryFindUniqueOrThrowArgs>
    ): Prisma__ThreadCategoryClient<ThreadCategoryGetPayload<T>>

    /**
     * Find the first ThreadCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadCategoryFindFirstArgs} args - Arguments to find a ThreadCategory
     * @example
     * // Get one ThreadCategory
     * const threadCategory = await prisma.threadCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ThreadCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ThreadCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ThreadCategory'> extends True ? Prisma__ThreadCategoryClient<ThreadCategoryGetPayload<T>> : Prisma__ThreadCategoryClient<ThreadCategoryGetPayload<T> | null, null>

    /**
     * Find the first ThreadCategory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadCategoryFindFirstOrThrowArgs} args - Arguments to find a ThreadCategory
     * @example
     * // Get one ThreadCategory
     * const threadCategory = await prisma.threadCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ThreadCategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ThreadCategoryFindFirstOrThrowArgs>
    ): Prisma__ThreadCategoryClient<ThreadCategoryGetPayload<T>>

    /**
     * Find zero or more ThreadCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ThreadCategories
     * const threadCategories = await prisma.threadCategory.findMany()
     * 
     * // Get first 10 ThreadCategories
     * const threadCategories = await prisma.threadCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const threadCategoryWithIdOnly = await prisma.threadCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ThreadCategoryFindManyArgs>(
      args?: SelectSubset<T, ThreadCategoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<ThreadCategoryGetPayload<T>>>

    /**
     * Create a ThreadCategory.
     * @param {ThreadCategoryCreateArgs} args - Arguments to create a ThreadCategory.
     * @example
     * // Create one ThreadCategory
     * const ThreadCategory = await prisma.threadCategory.create({
     *   data: {
     *     // ... data to create a ThreadCategory
     *   }
     * })
     * 
    **/
    create<T extends ThreadCategoryCreateArgs>(
      args: SelectSubset<T, ThreadCategoryCreateArgs>
    ): Prisma__ThreadCategoryClient<ThreadCategoryGetPayload<T>>

    /**
     * Create many ThreadCategories.
     *     @param {ThreadCategoryCreateManyArgs} args - Arguments to create many ThreadCategories.
     *     @example
     *     // Create many ThreadCategories
     *     const threadCategory = await prisma.threadCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ThreadCategoryCreateManyArgs>(
      args?: SelectSubset<T, ThreadCategoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ThreadCategory.
     * @param {ThreadCategoryDeleteArgs} args - Arguments to delete one ThreadCategory.
     * @example
     * // Delete one ThreadCategory
     * const ThreadCategory = await prisma.threadCategory.delete({
     *   where: {
     *     // ... filter to delete one ThreadCategory
     *   }
     * })
     * 
    **/
    delete<T extends ThreadCategoryDeleteArgs>(
      args: SelectSubset<T, ThreadCategoryDeleteArgs>
    ): Prisma__ThreadCategoryClient<ThreadCategoryGetPayload<T>>

    /**
     * Update one ThreadCategory.
     * @param {ThreadCategoryUpdateArgs} args - Arguments to update one ThreadCategory.
     * @example
     * // Update one ThreadCategory
     * const threadCategory = await prisma.threadCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ThreadCategoryUpdateArgs>(
      args: SelectSubset<T, ThreadCategoryUpdateArgs>
    ): Prisma__ThreadCategoryClient<ThreadCategoryGetPayload<T>>

    /**
     * Delete zero or more ThreadCategories.
     * @param {ThreadCategoryDeleteManyArgs} args - Arguments to filter ThreadCategories to delete.
     * @example
     * // Delete a few ThreadCategories
     * const { count } = await prisma.threadCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ThreadCategoryDeleteManyArgs>(
      args?: SelectSubset<T, ThreadCategoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ThreadCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ThreadCategories
     * const threadCategory = await prisma.threadCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ThreadCategoryUpdateManyArgs>(
      args: SelectSubset<T, ThreadCategoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ThreadCategory.
     * @param {ThreadCategoryUpsertArgs} args - Arguments to update or create a ThreadCategory.
     * @example
     * // Update or create a ThreadCategory
     * const threadCategory = await prisma.threadCategory.upsert({
     *   create: {
     *     // ... data to create a ThreadCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ThreadCategory we want to update
     *   }
     * })
    **/
    upsert<T extends ThreadCategoryUpsertArgs>(
      args: SelectSubset<T, ThreadCategoryUpsertArgs>
    ): Prisma__ThreadCategoryClient<ThreadCategoryGetPayload<T>>

    /**
     * Count the number of ThreadCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadCategoryCountArgs} args - Arguments to filter ThreadCategories to count.
     * @example
     * // Count the number of ThreadCategories
     * const count = await prisma.threadCategory.count({
     *   where: {
     *     // ... the filter for the ThreadCategories we want to count
     *   }
     * })
    **/
    count<T extends ThreadCategoryCountArgs>(
      args?: Subset<T, ThreadCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThreadCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ThreadCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ThreadCategoryAggregateArgs>(args: Subset<T, ThreadCategoryAggregateArgs>): Prisma.PrismaPromise<GetThreadCategoryAggregateType<T>>

    /**
     * Group by ThreadCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ThreadCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThreadCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ThreadCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ThreadCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThreadCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ThreadCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ThreadCategoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    threads<T extends ThreadCategory$threadsArgs= {}>(args?: Subset<T, ThreadCategory$threadsArgs>): Prisma.PrismaPromise<Array<ThreadGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ThreadCategory base type for findUnique actions
   */
  export type ThreadCategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ThreadCategory
     */
    select?: ThreadCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadCategoryInclude | null
    /**
     * Filter, which ThreadCategory to fetch.
     */
    where: ThreadCategoryWhereUniqueInput
  }

  /**
   * ThreadCategory findUnique
   */
  export interface ThreadCategoryFindUniqueArgs extends ThreadCategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ThreadCategory findUniqueOrThrow
   */
  export type ThreadCategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ThreadCategory
     */
    select?: ThreadCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadCategoryInclude | null
    /**
     * Filter, which ThreadCategory to fetch.
     */
    where: ThreadCategoryWhereUniqueInput
  }


  /**
   * ThreadCategory base type for findFirst actions
   */
  export type ThreadCategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ThreadCategory
     */
    select?: ThreadCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadCategoryInclude | null
    /**
     * Filter, which ThreadCategory to fetch.
     */
    where?: ThreadCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreadCategories to fetch.
     */
    orderBy?: Enumerable<ThreadCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ThreadCategories.
     */
    cursor?: ThreadCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreadCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreadCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ThreadCategories.
     */
    distinct?: Enumerable<ThreadCategoryScalarFieldEnum>
  }

  /**
   * ThreadCategory findFirst
   */
  export interface ThreadCategoryFindFirstArgs extends ThreadCategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ThreadCategory findFirstOrThrow
   */
  export type ThreadCategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ThreadCategory
     */
    select?: ThreadCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadCategoryInclude | null
    /**
     * Filter, which ThreadCategory to fetch.
     */
    where?: ThreadCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreadCategories to fetch.
     */
    orderBy?: Enumerable<ThreadCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ThreadCategories.
     */
    cursor?: ThreadCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreadCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreadCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ThreadCategories.
     */
    distinct?: Enumerable<ThreadCategoryScalarFieldEnum>
  }


  /**
   * ThreadCategory findMany
   */
  export type ThreadCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the ThreadCategory
     */
    select?: ThreadCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadCategoryInclude | null
    /**
     * Filter, which ThreadCategories to fetch.
     */
    where?: ThreadCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreadCategories to fetch.
     */
    orderBy?: Enumerable<ThreadCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ThreadCategories.
     */
    cursor?: ThreadCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreadCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreadCategories.
     */
    skip?: number
    distinct?: Enumerable<ThreadCategoryScalarFieldEnum>
  }


  /**
   * ThreadCategory create
   */
  export type ThreadCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the ThreadCategory
     */
    select?: ThreadCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadCategoryInclude | null
    /**
     * The data needed to create a ThreadCategory.
     */
    data: XOR<ThreadCategoryCreateInput, ThreadCategoryUncheckedCreateInput>
  }


  /**
   * ThreadCategory createMany
   */
  export type ThreadCategoryCreateManyArgs = {
    /**
     * The data used to create many ThreadCategories.
     */
    data: Enumerable<ThreadCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ThreadCategory update
   */
  export type ThreadCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the ThreadCategory
     */
    select?: ThreadCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadCategoryInclude | null
    /**
     * The data needed to update a ThreadCategory.
     */
    data: XOR<ThreadCategoryUpdateInput, ThreadCategoryUncheckedUpdateInput>
    /**
     * Choose, which ThreadCategory to update.
     */
    where: ThreadCategoryWhereUniqueInput
  }


  /**
   * ThreadCategory updateMany
   */
  export type ThreadCategoryUpdateManyArgs = {
    /**
     * The data used to update ThreadCategories.
     */
    data: XOR<ThreadCategoryUpdateManyMutationInput, ThreadCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ThreadCategories to update
     */
    where?: ThreadCategoryWhereInput
  }


  /**
   * ThreadCategory upsert
   */
  export type ThreadCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the ThreadCategory
     */
    select?: ThreadCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadCategoryInclude | null
    /**
     * The filter to search for the ThreadCategory to update in case it exists.
     */
    where: ThreadCategoryWhereUniqueInput
    /**
     * In case the ThreadCategory found by the `where` argument doesn't exist, create a new ThreadCategory with this data.
     */
    create: XOR<ThreadCategoryCreateInput, ThreadCategoryUncheckedCreateInput>
    /**
     * In case the ThreadCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThreadCategoryUpdateInput, ThreadCategoryUncheckedUpdateInput>
  }


  /**
   * ThreadCategory delete
   */
  export type ThreadCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the ThreadCategory
     */
    select?: ThreadCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadCategoryInclude | null
    /**
     * Filter which ThreadCategory to delete.
     */
    where: ThreadCategoryWhereUniqueInput
  }


  /**
   * ThreadCategory deleteMany
   */
  export type ThreadCategoryDeleteManyArgs = {
    /**
     * Filter which ThreadCategories to delete
     */
    where?: ThreadCategoryWhereInput
  }


  /**
   * ThreadCategory.threads
   */
  export type ThreadCategory$threadsArgs = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadInclude | null
    where?: ThreadWhereInput
    orderBy?: Enumerable<ThreadOrderByWithRelationInput>
    cursor?: ThreadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ThreadScalarFieldEnum>
  }


  /**
   * ThreadCategory without action
   */
  export type ThreadCategoryArgs = {
    /**
     * Select specific fields to fetch from the ThreadCategory
     */
    select?: ThreadCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadCategoryInclude | null
  }



  /**
   * Model ThreadTag
   */


  export type AggregateThreadTag = {
    _count: ThreadTagCountAggregateOutputType | null
    _min: ThreadTagMinAggregateOutputType | null
    _max: ThreadTagMaxAggregateOutputType | null
  }

  export type ThreadTagMinAggregateOutputType = {
    id: string | null
    title: string | null
  }

  export type ThreadTagMaxAggregateOutputType = {
    id: string | null
    title: string | null
  }

  export type ThreadTagCountAggregateOutputType = {
    id: number
    title: number
    _all: number
  }


  export type ThreadTagMinAggregateInputType = {
    id?: true
    title?: true
  }

  export type ThreadTagMaxAggregateInputType = {
    id?: true
    title?: true
  }

  export type ThreadTagCountAggregateInputType = {
    id?: true
    title?: true
    _all?: true
  }

  export type ThreadTagAggregateArgs = {
    /**
     * Filter which ThreadTag to aggregate.
     */
    where?: ThreadTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreadTags to fetch.
     */
    orderBy?: Enumerable<ThreadTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ThreadTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreadTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreadTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ThreadTags
    **/
    _count?: true | ThreadTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ThreadTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ThreadTagMaxAggregateInputType
  }

  export type GetThreadTagAggregateType<T extends ThreadTagAggregateArgs> = {
        [P in keyof T & keyof AggregateThreadTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThreadTag[P]>
      : GetScalarType<T[P], AggregateThreadTag[P]>
  }




  export type ThreadTagGroupByArgs = {
    where?: ThreadTagWhereInput
    orderBy?: Enumerable<ThreadTagOrderByWithAggregationInput>
    by: ThreadTagScalarFieldEnum[]
    having?: ThreadTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ThreadTagCountAggregateInputType | true
    _min?: ThreadTagMinAggregateInputType
    _max?: ThreadTagMaxAggregateInputType
  }


  export type ThreadTagGroupByOutputType = {
    id: string
    title: string
    _count: ThreadTagCountAggregateOutputType | null
    _min: ThreadTagMinAggregateOutputType | null
    _max: ThreadTagMaxAggregateOutputType | null
  }

  type GetThreadTagGroupByPayload<T extends ThreadTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ThreadTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ThreadTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThreadTagGroupByOutputType[P]>
            : GetScalarType<T[P], ThreadTagGroupByOutputType[P]>
        }
      >
    >


  export type ThreadTagSelect = {
    id?: boolean
    title?: boolean
    threads?: boolean | ThreadTag$threadsArgs
    _count?: boolean | ThreadTagCountOutputTypeArgs
  }


  export type ThreadTagInclude = {
    threads?: boolean | ThreadTag$threadsArgs
    _count?: boolean | ThreadTagCountOutputTypeArgs
  }

  export type ThreadTagGetPayload<S extends boolean | null | undefined | ThreadTagArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ThreadTag :
    S extends undefined ? never :
    S extends { include: any } & (ThreadTagArgs | ThreadTagFindManyArgs)
    ? ThreadTag  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'threads' ? Array < ThreadTagRelGetPayload<S['include'][P]>>  :
        P extends '_count' ? ThreadTagCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ThreadTagArgs | ThreadTagFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'threads' ? Array < ThreadTagRelGetPayload<S['select'][P]>>  :
        P extends '_count' ? ThreadTagCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ThreadTag ? ThreadTag[P] : never
  } 
      : ThreadTag


  type ThreadTagCountArgs = 
    Omit<ThreadTagFindManyArgs, 'select' | 'include'> & {
      select?: ThreadTagCountAggregateInputType | true
    }

  export interface ThreadTagDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ThreadTag that matches the filter.
     * @param {ThreadTagFindUniqueArgs} args - Arguments to find a ThreadTag
     * @example
     * // Get one ThreadTag
     * const threadTag = await prisma.threadTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ThreadTagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ThreadTagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ThreadTag'> extends True ? Prisma__ThreadTagClient<ThreadTagGetPayload<T>> : Prisma__ThreadTagClient<ThreadTagGetPayload<T> | null, null>

    /**
     * Find one ThreadTag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ThreadTagFindUniqueOrThrowArgs} args - Arguments to find a ThreadTag
     * @example
     * // Get one ThreadTag
     * const threadTag = await prisma.threadTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ThreadTagFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ThreadTagFindUniqueOrThrowArgs>
    ): Prisma__ThreadTagClient<ThreadTagGetPayload<T>>

    /**
     * Find the first ThreadTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadTagFindFirstArgs} args - Arguments to find a ThreadTag
     * @example
     * // Get one ThreadTag
     * const threadTag = await prisma.threadTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ThreadTagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ThreadTagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ThreadTag'> extends True ? Prisma__ThreadTagClient<ThreadTagGetPayload<T>> : Prisma__ThreadTagClient<ThreadTagGetPayload<T> | null, null>

    /**
     * Find the first ThreadTag that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadTagFindFirstOrThrowArgs} args - Arguments to find a ThreadTag
     * @example
     * // Get one ThreadTag
     * const threadTag = await prisma.threadTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ThreadTagFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ThreadTagFindFirstOrThrowArgs>
    ): Prisma__ThreadTagClient<ThreadTagGetPayload<T>>

    /**
     * Find zero or more ThreadTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadTagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ThreadTags
     * const threadTags = await prisma.threadTag.findMany()
     * 
     * // Get first 10 ThreadTags
     * const threadTags = await prisma.threadTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const threadTagWithIdOnly = await prisma.threadTag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ThreadTagFindManyArgs>(
      args?: SelectSubset<T, ThreadTagFindManyArgs>
    ): Prisma.PrismaPromise<Array<ThreadTagGetPayload<T>>>

    /**
     * Create a ThreadTag.
     * @param {ThreadTagCreateArgs} args - Arguments to create a ThreadTag.
     * @example
     * // Create one ThreadTag
     * const ThreadTag = await prisma.threadTag.create({
     *   data: {
     *     // ... data to create a ThreadTag
     *   }
     * })
     * 
    **/
    create<T extends ThreadTagCreateArgs>(
      args: SelectSubset<T, ThreadTagCreateArgs>
    ): Prisma__ThreadTagClient<ThreadTagGetPayload<T>>

    /**
     * Create many ThreadTags.
     *     @param {ThreadTagCreateManyArgs} args - Arguments to create many ThreadTags.
     *     @example
     *     // Create many ThreadTags
     *     const threadTag = await prisma.threadTag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ThreadTagCreateManyArgs>(
      args?: SelectSubset<T, ThreadTagCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ThreadTag.
     * @param {ThreadTagDeleteArgs} args - Arguments to delete one ThreadTag.
     * @example
     * // Delete one ThreadTag
     * const ThreadTag = await prisma.threadTag.delete({
     *   where: {
     *     // ... filter to delete one ThreadTag
     *   }
     * })
     * 
    **/
    delete<T extends ThreadTagDeleteArgs>(
      args: SelectSubset<T, ThreadTagDeleteArgs>
    ): Prisma__ThreadTagClient<ThreadTagGetPayload<T>>

    /**
     * Update one ThreadTag.
     * @param {ThreadTagUpdateArgs} args - Arguments to update one ThreadTag.
     * @example
     * // Update one ThreadTag
     * const threadTag = await prisma.threadTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ThreadTagUpdateArgs>(
      args: SelectSubset<T, ThreadTagUpdateArgs>
    ): Prisma__ThreadTagClient<ThreadTagGetPayload<T>>

    /**
     * Delete zero or more ThreadTags.
     * @param {ThreadTagDeleteManyArgs} args - Arguments to filter ThreadTags to delete.
     * @example
     * // Delete a few ThreadTags
     * const { count } = await prisma.threadTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ThreadTagDeleteManyArgs>(
      args?: SelectSubset<T, ThreadTagDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ThreadTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ThreadTags
     * const threadTag = await prisma.threadTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ThreadTagUpdateManyArgs>(
      args: SelectSubset<T, ThreadTagUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ThreadTag.
     * @param {ThreadTagUpsertArgs} args - Arguments to update or create a ThreadTag.
     * @example
     * // Update or create a ThreadTag
     * const threadTag = await prisma.threadTag.upsert({
     *   create: {
     *     // ... data to create a ThreadTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ThreadTag we want to update
     *   }
     * })
    **/
    upsert<T extends ThreadTagUpsertArgs>(
      args: SelectSubset<T, ThreadTagUpsertArgs>
    ): Prisma__ThreadTagClient<ThreadTagGetPayload<T>>

    /**
     * Count the number of ThreadTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadTagCountArgs} args - Arguments to filter ThreadTags to count.
     * @example
     * // Count the number of ThreadTags
     * const count = await prisma.threadTag.count({
     *   where: {
     *     // ... the filter for the ThreadTags we want to count
     *   }
     * })
    **/
    count<T extends ThreadTagCountArgs>(
      args?: Subset<T, ThreadTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThreadTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ThreadTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ThreadTagAggregateArgs>(args: Subset<T, ThreadTagAggregateArgs>): Prisma.PrismaPromise<GetThreadTagAggregateType<T>>

    /**
     * Group by ThreadTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ThreadTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThreadTagGroupByArgs['orderBy'] }
        : { orderBy?: ThreadTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ThreadTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThreadTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ThreadTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ThreadTagClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    threads<T extends ThreadTag$threadsArgs= {}>(args?: Subset<T, ThreadTag$threadsArgs>): Prisma.PrismaPromise<Array<ThreadTagRelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ThreadTag base type for findUnique actions
   */
  export type ThreadTagFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ThreadTag
     */
    select?: ThreadTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadTagInclude | null
    /**
     * Filter, which ThreadTag to fetch.
     */
    where: ThreadTagWhereUniqueInput
  }

  /**
   * ThreadTag findUnique
   */
  export interface ThreadTagFindUniqueArgs extends ThreadTagFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ThreadTag findUniqueOrThrow
   */
  export type ThreadTagFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ThreadTag
     */
    select?: ThreadTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadTagInclude | null
    /**
     * Filter, which ThreadTag to fetch.
     */
    where: ThreadTagWhereUniqueInput
  }


  /**
   * ThreadTag base type for findFirst actions
   */
  export type ThreadTagFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ThreadTag
     */
    select?: ThreadTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadTagInclude | null
    /**
     * Filter, which ThreadTag to fetch.
     */
    where?: ThreadTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreadTags to fetch.
     */
    orderBy?: Enumerable<ThreadTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ThreadTags.
     */
    cursor?: ThreadTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreadTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreadTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ThreadTags.
     */
    distinct?: Enumerable<ThreadTagScalarFieldEnum>
  }

  /**
   * ThreadTag findFirst
   */
  export interface ThreadTagFindFirstArgs extends ThreadTagFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ThreadTag findFirstOrThrow
   */
  export type ThreadTagFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ThreadTag
     */
    select?: ThreadTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadTagInclude | null
    /**
     * Filter, which ThreadTag to fetch.
     */
    where?: ThreadTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreadTags to fetch.
     */
    orderBy?: Enumerable<ThreadTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ThreadTags.
     */
    cursor?: ThreadTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreadTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreadTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ThreadTags.
     */
    distinct?: Enumerable<ThreadTagScalarFieldEnum>
  }


  /**
   * ThreadTag findMany
   */
  export type ThreadTagFindManyArgs = {
    /**
     * Select specific fields to fetch from the ThreadTag
     */
    select?: ThreadTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadTagInclude | null
    /**
     * Filter, which ThreadTags to fetch.
     */
    where?: ThreadTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreadTags to fetch.
     */
    orderBy?: Enumerable<ThreadTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ThreadTags.
     */
    cursor?: ThreadTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreadTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreadTags.
     */
    skip?: number
    distinct?: Enumerable<ThreadTagScalarFieldEnum>
  }


  /**
   * ThreadTag create
   */
  export type ThreadTagCreateArgs = {
    /**
     * Select specific fields to fetch from the ThreadTag
     */
    select?: ThreadTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadTagInclude | null
    /**
     * The data needed to create a ThreadTag.
     */
    data: XOR<ThreadTagCreateInput, ThreadTagUncheckedCreateInput>
  }


  /**
   * ThreadTag createMany
   */
  export type ThreadTagCreateManyArgs = {
    /**
     * The data used to create many ThreadTags.
     */
    data: Enumerable<ThreadTagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ThreadTag update
   */
  export type ThreadTagUpdateArgs = {
    /**
     * Select specific fields to fetch from the ThreadTag
     */
    select?: ThreadTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadTagInclude | null
    /**
     * The data needed to update a ThreadTag.
     */
    data: XOR<ThreadTagUpdateInput, ThreadTagUncheckedUpdateInput>
    /**
     * Choose, which ThreadTag to update.
     */
    where: ThreadTagWhereUniqueInput
  }


  /**
   * ThreadTag updateMany
   */
  export type ThreadTagUpdateManyArgs = {
    /**
     * The data used to update ThreadTags.
     */
    data: XOR<ThreadTagUpdateManyMutationInput, ThreadTagUncheckedUpdateManyInput>
    /**
     * Filter which ThreadTags to update
     */
    where?: ThreadTagWhereInput
  }


  /**
   * ThreadTag upsert
   */
  export type ThreadTagUpsertArgs = {
    /**
     * Select specific fields to fetch from the ThreadTag
     */
    select?: ThreadTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadTagInclude | null
    /**
     * The filter to search for the ThreadTag to update in case it exists.
     */
    where: ThreadTagWhereUniqueInput
    /**
     * In case the ThreadTag found by the `where` argument doesn't exist, create a new ThreadTag with this data.
     */
    create: XOR<ThreadTagCreateInput, ThreadTagUncheckedCreateInput>
    /**
     * In case the ThreadTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThreadTagUpdateInput, ThreadTagUncheckedUpdateInput>
  }


  /**
   * ThreadTag delete
   */
  export type ThreadTagDeleteArgs = {
    /**
     * Select specific fields to fetch from the ThreadTag
     */
    select?: ThreadTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadTagInclude | null
    /**
     * Filter which ThreadTag to delete.
     */
    where: ThreadTagWhereUniqueInput
  }


  /**
   * ThreadTag deleteMany
   */
  export type ThreadTagDeleteManyArgs = {
    /**
     * Filter which ThreadTags to delete
     */
    where?: ThreadTagWhereInput
  }


  /**
   * ThreadTag.threads
   */
  export type ThreadTag$threadsArgs = {
    /**
     * Select specific fields to fetch from the ThreadTagRel
     */
    select?: ThreadTagRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadTagRelInclude | null
    where?: ThreadTagRelWhereInput
    orderBy?: Enumerable<ThreadTagRelOrderByWithRelationInput>
    cursor?: ThreadTagRelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ThreadTagRelScalarFieldEnum>
  }


  /**
   * ThreadTag without action
   */
  export type ThreadTagArgs = {
    /**
     * Select specific fields to fetch from the ThreadTag
     */
    select?: ThreadTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadTagInclude | null
  }



  /**
   * Model ThreadTagRel
   */


  export type AggregateThreadTagRel = {
    _count: ThreadTagRelCountAggregateOutputType | null
    _min: ThreadTagRelMinAggregateOutputType | null
    _max: ThreadTagRelMaxAggregateOutputType | null
  }

  export type ThreadTagRelMinAggregateOutputType = {
    threadId: string | null
    tagId: string | null
  }

  export type ThreadTagRelMaxAggregateOutputType = {
    threadId: string | null
    tagId: string | null
  }

  export type ThreadTagRelCountAggregateOutputType = {
    threadId: number
    tagId: number
    _all: number
  }


  export type ThreadTagRelMinAggregateInputType = {
    threadId?: true
    tagId?: true
  }

  export type ThreadTagRelMaxAggregateInputType = {
    threadId?: true
    tagId?: true
  }

  export type ThreadTagRelCountAggregateInputType = {
    threadId?: true
    tagId?: true
    _all?: true
  }

  export type ThreadTagRelAggregateArgs = {
    /**
     * Filter which ThreadTagRel to aggregate.
     */
    where?: ThreadTagRelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreadTagRels to fetch.
     */
    orderBy?: Enumerable<ThreadTagRelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ThreadTagRelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreadTagRels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreadTagRels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ThreadTagRels
    **/
    _count?: true | ThreadTagRelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ThreadTagRelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ThreadTagRelMaxAggregateInputType
  }

  export type GetThreadTagRelAggregateType<T extends ThreadTagRelAggregateArgs> = {
        [P in keyof T & keyof AggregateThreadTagRel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThreadTagRel[P]>
      : GetScalarType<T[P], AggregateThreadTagRel[P]>
  }




  export type ThreadTagRelGroupByArgs = {
    where?: ThreadTagRelWhereInput
    orderBy?: Enumerable<ThreadTagRelOrderByWithAggregationInput>
    by: ThreadTagRelScalarFieldEnum[]
    having?: ThreadTagRelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ThreadTagRelCountAggregateInputType | true
    _min?: ThreadTagRelMinAggregateInputType
    _max?: ThreadTagRelMaxAggregateInputType
  }


  export type ThreadTagRelGroupByOutputType = {
    threadId: string
    tagId: string
    _count: ThreadTagRelCountAggregateOutputType | null
    _min: ThreadTagRelMinAggregateOutputType | null
    _max: ThreadTagRelMaxAggregateOutputType | null
  }

  type GetThreadTagRelGroupByPayload<T extends ThreadTagRelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ThreadTagRelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ThreadTagRelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThreadTagRelGroupByOutputType[P]>
            : GetScalarType<T[P], ThreadTagRelGroupByOutputType[P]>
        }
      >
    >


  export type ThreadTagRelSelect = {
    threadId?: boolean
    tagId?: boolean
    thread?: boolean | ThreadArgs
    tag?: boolean | ThreadTagArgs
  }


  export type ThreadTagRelInclude = {
    thread?: boolean | ThreadArgs
    tag?: boolean | ThreadTagArgs
  }

  export type ThreadTagRelGetPayload<S extends boolean | null | undefined | ThreadTagRelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ThreadTagRel :
    S extends undefined ? never :
    S extends { include: any } & (ThreadTagRelArgs | ThreadTagRelFindManyArgs)
    ? ThreadTagRel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'thread' ? ThreadGetPayload<S['include'][P]> :
        P extends 'tag' ? ThreadTagGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ThreadTagRelArgs | ThreadTagRelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'thread' ? ThreadGetPayload<S['select'][P]> :
        P extends 'tag' ? ThreadTagGetPayload<S['select'][P]> :  P extends keyof ThreadTagRel ? ThreadTagRel[P] : never
  } 
      : ThreadTagRel


  type ThreadTagRelCountArgs = 
    Omit<ThreadTagRelFindManyArgs, 'select' | 'include'> & {
      select?: ThreadTagRelCountAggregateInputType | true
    }

  export interface ThreadTagRelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ThreadTagRel that matches the filter.
     * @param {ThreadTagRelFindUniqueArgs} args - Arguments to find a ThreadTagRel
     * @example
     * // Get one ThreadTagRel
     * const threadTagRel = await prisma.threadTagRel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ThreadTagRelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ThreadTagRelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ThreadTagRel'> extends True ? Prisma__ThreadTagRelClient<ThreadTagRelGetPayload<T>> : Prisma__ThreadTagRelClient<ThreadTagRelGetPayload<T> | null, null>

    /**
     * Find one ThreadTagRel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ThreadTagRelFindUniqueOrThrowArgs} args - Arguments to find a ThreadTagRel
     * @example
     * // Get one ThreadTagRel
     * const threadTagRel = await prisma.threadTagRel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ThreadTagRelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ThreadTagRelFindUniqueOrThrowArgs>
    ): Prisma__ThreadTagRelClient<ThreadTagRelGetPayload<T>>

    /**
     * Find the first ThreadTagRel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadTagRelFindFirstArgs} args - Arguments to find a ThreadTagRel
     * @example
     * // Get one ThreadTagRel
     * const threadTagRel = await prisma.threadTagRel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ThreadTagRelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ThreadTagRelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ThreadTagRel'> extends True ? Prisma__ThreadTagRelClient<ThreadTagRelGetPayload<T>> : Prisma__ThreadTagRelClient<ThreadTagRelGetPayload<T> | null, null>

    /**
     * Find the first ThreadTagRel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadTagRelFindFirstOrThrowArgs} args - Arguments to find a ThreadTagRel
     * @example
     * // Get one ThreadTagRel
     * const threadTagRel = await prisma.threadTagRel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ThreadTagRelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ThreadTagRelFindFirstOrThrowArgs>
    ): Prisma__ThreadTagRelClient<ThreadTagRelGetPayload<T>>

    /**
     * Find zero or more ThreadTagRels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadTagRelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ThreadTagRels
     * const threadTagRels = await prisma.threadTagRel.findMany()
     * 
     * // Get first 10 ThreadTagRels
     * const threadTagRels = await prisma.threadTagRel.findMany({ take: 10 })
     * 
     * // Only select the `threadId`
     * const threadTagRelWithThreadIdOnly = await prisma.threadTagRel.findMany({ select: { threadId: true } })
     * 
    **/
    findMany<T extends ThreadTagRelFindManyArgs>(
      args?: SelectSubset<T, ThreadTagRelFindManyArgs>
    ): Prisma.PrismaPromise<Array<ThreadTagRelGetPayload<T>>>

    /**
     * Create a ThreadTagRel.
     * @param {ThreadTagRelCreateArgs} args - Arguments to create a ThreadTagRel.
     * @example
     * // Create one ThreadTagRel
     * const ThreadTagRel = await prisma.threadTagRel.create({
     *   data: {
     *     // ... data to create a ThreadTagRel
     *   }
     * })
     * 
    **/
    create<T extends ThreadTagRelCreateArgs>(
      args: SelectSubset<T, ThreadTagRelCreateArgs>
    ): Prisma__ThreadTagRelClient<ThreadTagRelGetPayload<T>>

    /**
     * Create many ThreadTagRels.
     *     @param {ThreadTagRelCreateManyArgs} args - Arguments to create many ThreadTagRels.
     *     @example
     *     // Create many ThreadTagRels
     *     const threadTagRel = await prisma.threadTagRel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ThreadTagRelCreateManyArgs>(
      args?: SelectSubset<T, ThreadTagRelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ThreadTagRel.
     * @param {ThreadTagRelDeleteArgs} args - Arguments to delete one ThreadTagRel.
     * @example
     * // Delete one ThreadTagRel
     * const ThreadTagRel = await prisma.threadTagRel.delete({
     *   where: {
     *     // ... filter to delete one ThreadTagRel
     *   }
     * })
     * 
    **/
    delete<T extends ThreadTagRelDeleteArgs>(
      args: SelectSubset<T, ThreadTagRelDeleteArgs>
    ): Prisma__ThreadTagRelClient<ThreadTagRelGetPayload<T>>

    /**
     * Update one ThreadTagRel.
     * @param {ThreadTagRelUpdateArgs} args - Arguments to update one ThreadTagRel.
     * @example
     * // Update one ThreadTagRel
     * const threadTagRel = await prisma.threadTagRel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ThreadTagRelUpdateArgs>(
      args: SelectSubset<T, ThreadTagRelUpdateArgs>
    ): Prisma__ThreadTagRelClient<ThreadTagRelGetPayload<T>>

    /**
     * Delete zero or more ThreadTagRels.
     * @param {ThreadTagRelDeleteManyArgs} args - Arguments to filter ThreadTagRels to delete.
     * @example
     * // Delete a few ThreadTagRels
     * const { count } = await prisma.threadTagRel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ThreadTagRelDeleteManyArgs>(
      args?: SelectSubset<T, ThreadTagRelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ThreadTagRels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadTagRelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ThreadTagRels
     * const threadTagRel = await prisma.threadTagRel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ThreadTagRelUpdateManyArgs>(
      args: SelectSubset<T, ThreadTagRelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ThreadTagRel.
     * @param {ThreadTagRelUpsertArgs} args - Arguments to update or create a ThreadTagRel.
     * @example
     * // Update or create a ThreadTagRel
     * const threadTagRel = await prisma.threadTagRel.upsert({
     *   create: {
     *     // ... data to create a ThreadTagRel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ThreadTagRel we want to update
     *   }
     * })
    **/
    upsert<T extends ThreadTagRelUpsertArgs>(
      args: SelectSubset<T, ThreadTagRelUpsertArgs>
    ): Prisma__ThreadTagRelClient<ThreadTagRelGetPayload<T>>

    /**
     * Count the number of ThreadTagRels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadTagRelCountArgs} args - Arguments to filter ThreadTagRels to count.
     * @example
     * // Count the number of ThreadTagRels
     * const count = await prisma.threadTagRel.count({
     *   where: {
     *     // ... the filter for the ThreadTagRels we want to count
     *   }
     * })
    **/
    count<T extends ThreadTagRelCountArgs>(
      args?: Subset<T, ThreadTagRelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThreadTagRelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ThreadTagRel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadTagRelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ThreadTagRelAggregateArgs>(args: Subset<T, ThreadTagRelAggregateArgs>): Prisma.PrismaPromise<GetThreadTagRelAggregateType<T>>

    /**
     * Group by ThreadTagRel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadTagRelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ThreadTagRelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThreadTagRelGroupByArgs['orderBy'] }
        : { orderBy?: ThreadTagRelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ThreadTagRelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThreadTagRelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ThreadTagRel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ThreadTagRelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    thread<T extends ThreadArgs= {}>(args?: Subset<T, ThreadArgs>): Prisma__ThreadClient<ThreadGetPayload<T> | Null>;

    tag<T extends ThreadTagArgs= {}>(args?: Subset<T, ThreadTagArgs>): Prisma__ThreadTagClient<ThreadTagGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ThreadTagRel base type for findUnique actions
   */
  export type ThreadTagRelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ThreadTagRel
     */
    select?: ThreadTagRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadTagRelInclude | null
    /**
     * Filter, which ThreadTagRel to fetch.
     */
    where: ThreadTagRelWhereUniqueInput
  }

  /**
   * ThreadTagRel findUnique
   */
  export interface ThreadTagRelFindUniqueArgs extends ThreadTagRelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ThreadTagRel findUniqueOrThrow
   */
  export type ThreadTagRelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ThreadTagRel
     */
    select?: ThreadTagRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadTagRelInclude | null
    /**
     * Filter, which ThreadTagRel to fetch.
     */
    where: ThreadTagRelWhereUniqueInput
  }


  /**
   * ThreadTagRel base type for findFirst actions
   */
  export type ThreadTagRelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ThreadTagRel
     */
    select?: ThreadTagRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadTagRelInclude | null
    /**
     * Filter, which ThreadTagRel to fetch.
     */
    where?: ThreadTagRelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreadTagRels to fetch.
     */
    orderBy?: Enumerable<ThreadTagRelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ThreadTagRels.
     */
    cursor?: ThreadTagRelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreadTagRels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreadTagRels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ThreadTagRels.
     */
    distinct?: Enumerable<ThreadTagRelScalarFieldEnum>
  }

  /**
   * ThreadTagRel findFirst
   */
  export interface ThreadTagRelFindFirstArgs extends ThreadTagRelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ThreadTagRel findFirstOrThrow
   */
  export type ThreadTagRelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ThreadTagRel
     */
    select?: ThreadTagRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadTagRelInclude | null
    /**
     * Filter, which ThreadTagRel to fetch.
     */
    where?: ThreadTagRelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreadTagRels to fetch.
     */
    orderBy?: Enumerable<ThreadTagRelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ThreadTagRels.
     */
    cursor?: ThreadTagRelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreadTagRels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreadTagRels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ThreadTagRels.
     */
    distinct?: Enumerable<ThreadTagRelScalarFieldEnum>
  }


  /**
   * ThreadTagRel findMany
   */
  export type ThreadTagRelFindManyArgs = {
    /**
     * Select specific fields to fetch from the ThreadTagRel
     */
    select?: ThreadTagRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadTagRelInclude | null
    /**
     * Filter, which ThreadTagRels to fetch.
     */
    where?: ThreadTagRelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreadTagRels to fetch.
     */
    orderBy?: Enumerable<ThreadTagRelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ThreadTagRels.
     */
    cursor?: ThreadTagRelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreadTagRels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreadTagRels.
     */
    skip?: number
    distinct?: Enumerable<ThreadTagRelScalarFieldEnum>
  }


  /**
   * ThreadTagRel create
   */
  export type ThreadTagRelCreateArgs = {
    /**
     * Select specific fields to fetch from the ThreadTagRel
     */
    select?: ThreadTagRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadTagRelInclude | null
    /**
     * The data needed to create a ThreadTagRel.
     */
    data: XOR<ThreadTagRelCreateInput, ThreadTagRelUncheckedCreateInput>
  }


  /**
   * ThreadTagRel createMany
   */
  export type ThreadTagRelCreateManyArgs = {
    /**
     * The data used to create many ThreadTagRels.
     */
    data: Enumerable<ThreadTagRelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ThreadTagRel update
   */
  export type ThreadTagRelUpdateArgs = {
    /**
     * Select specific fields to fetch from the ThreadTagRel
     */
    select?: ThreadTagRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadTagRelInclude | null
    /**
     * The data needed to update a ThreadTagRel.
     */
    data: XOR<ThreadTagRelUpdateInput, ThreadTagRelUncheckedUpdateInput>
    /**
     * Choose, which ThreadTagRel to update.
     */
    where: ThreadTagRelWhereUniqueInput
  }


  /**
   * ThreadTagRel updateMany
   */
  export type ThreadTagRelUpdateManyArgs = {
    /**
     * The data used to update ThreadTagRels.
     */
    data: XOR<ThreadTagRelUpdateManyMutationInput, ThreadTagRelUncheckedUpdateManyInput>
    /**
     * Filter which ThreadTagRels to update
     */
    where?: ThreadTagRelWhereInput
  }


  /**
   * ThreadTagRel upsert
   */
  export type ThreadTagRelUpsertArgs = {
    /**
     * Select specific fields to fetch from the ThreadTagRel
     */
    select?: ThreadTagRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadTagRelInclude | null
    /**
     * The filter to search for the ThreadTagRel to update in case it exists.
     */
    where: ThreadTagRelWhereUniqueInput
    /**
     * In case the ThreadTagRel found by the `where` argument doesn't exist, create a new ThreadTagRel with this data.
     */
    create: XOR<ThreadTagRelCreateInput, ThreadTagRelUncheckedCreateInput>
    /**
     * In case the ThreadTagRel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThreadTagRelUpdateInput, ThreadTagRelUncheckedUpdateInput>
  }


  /**
   * ThreadTagRel delete
   */
  export type ThreadTagRelDeleteArgs = {
    /**
     * Select specific fields to fetch from the ThreadTagRel
     */
    select?: ThreadTagRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadTagRelInclude | null
    /**
     * Filter which ThreadTagRel to delete.
     */
    where: ThreadTagRelWhereUniqueInput
  }


  /**
   * ThreadTagRel deleteMany
   */
  export type ThreadTagRelDeleteManyArgs = {
    /**
     * Filter which ThreadTagRels to delete
     */
    where?: ThreadTagRelWhereInput
  }


  /**
   * ThreadTagRel without action
   */
  export type ThreadTagRelArgs = {
    /**
     * Select specific fields to fetch from the ThreadTagRel
     */
    select?: ThreadTagRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadTagRelInclude | null
  }



  /**
   * Model UserLikeThread
   */


  export type AggregateUserLikeThread = {
    _count: UserLikeThreadCountAggregateOutputType | null
    _min: UserLikeThreadMinAggregateOutputType | null
    _max: UserLikeThreadMaxAggregateOutputType | null
  }

  export type UserLikeThreadMinAggregateOutputType = {
    username: string | null
    threadId: string | null
    disable: boolean | null
  }

  export type UserLikeThreadMaxAggregateOutputType = {
    username: string | null
    threadId: string | null
    disable: boolean | null
  }

  export type UserLikeThreadCountAggregateOutputType = {
    username: number
    threadId: number
    disable: number
    _all: number
  }


  export type UserLikeThreadMinAggregateInputType = {
    username?: true
    threadId?: true
    disable?: true
  }

  export type UserLikeThreadMaxAggregateInputType = {
    username?: true
    threadId?: true
    disable?: true
  }

  export type UserLikeThreadCountAggregateInputType = {
    username?: true
    threadId?: true
    disable?: true
    _all?: true
  }

  export type UserLikeThreadAggregateArgs = {
    /**
     * Filter which UserLikeThread to aggregate.
     */
    where?: UserLikeThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLikeThreads to fetch.
     */
    orderBy?: Enumerable<UserLikeThreadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserLikeThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLikeThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLikeThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserLikeThreads
    **/
    _count?: true | UserLikeThreadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserLikeThreadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserLikeThreadMaxAggregateInputType
  }

  export type GetUserLikeThreadAggregateType<T extends UserLikeThreadAggregateArgs> = {
        [P in keyof T & keyof AggregateUserLikeThread]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLikeThread[P]>
      : GetScalarType<T[P], AggregateUserLikeThread[P]>
  }




  export type UserLikeThreadGroupByArgs = {
    where?: UserLikeThreadWhereInput
    orderBy?: Enumerable<UserLikeThreadOrderByWithAggregationInput>
    by: UserLikeThreadScalarFieldEnum[]
    having?: UserLikeThreadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserLikeThreadCountAggregateInputType | true
    _min?: UserLikeThreadMinAggregateInputType
    _max?: UserLikeThreadMaxAggregateInputType
  }


  export type UserLikeThreadGroupByOutputType = {
    username: string
    threadId: string
    disable: boolean
    _count: UserLikeThreadCountAggregateOutputType | null
    _min: UserLikeThreadMinAggregateOutputType | null
    _max: UserLikeThreadMaxAggregateOutputType | null
  }

  type GetUserLikeThreadGroupByPayload<T extends UserLikeThreadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserLikeThreadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserLikeThreadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLikeThreadGroupByOutputType[P]>
            : GetScalarType<T[P], UserLikeThreadGroupByOutputType[P]>
        }
      >
    >


  export type UserLikeThreadSelect = {
    username?: boolean
    threadId?: boolean
    disable?: boolean
    user?: boolean | UserArgs
    thread?: boolean | ThreadArgs
  }


  export type UserLikeThreadInclude = {
    user?: boolean | UserArgs
    thread?: boolean | ThreadArgs
  }

  export type UserLikeThreadGetPayload<S extends boolean | null | undefined | UserLikeThreadArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserLikeThread :
    S extends undefined ? never :
    S extends { include: any } & (UserLikeThreadArgs | UserLikeThreadFindManyArgs)
    ? UserLikeThread  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'thread' ? ThreadGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserLikeThreadArgs | UserLikeThreadFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'thread' ? ThreadGetPayload<S['select'][P]> :  P extends keyof UserLikeThread ? UserLikeThread[P] : never
  } 
      : UserLikeThread


  type UserLikeThreadCountArgs = 
    Omit<UserLikeThreadFindManyArgs, 'select' | 'include'> & {
      select?: UserLikeThreadCountAggregateInputType | true
    }

  export interface UserLikeThreadDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UserLikeThread that matches the filter.
     * @param {UserLikeThreadFindUniqueArgs} args - Arguments to find a UserLikeThread
     * @example
     * // Get one UserLikeThread
     * const userLikeThread = await prisma.userLikeThread.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserLikeThreadFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserLikeThreadFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserLikeThread'> extends True ? Prisma__UserLikeThreadClient<UserLikeThreadGetPayload<T>> : Prisma__UserLikeThreadClient<UserLikeThreadGetPayload<T> | null, null>

    /**
     * Find one UserLikeThread that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserLikeThreadFindUniqueOrThrowArgs} args - Arguments to find a UserLikeThread
     * @example
     * // Get one UserLikeThread
     * const userLikeThread = await prisma.userLikeThread.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserLikeThreadFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserLikeThreadFindUniqueOrThrowArgs>
    ): Prisma__UserLikeThreadClient<UserLikeThreadGetPayload<T>>

    /**
     * Find the first UserLikeThread that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikeThreadFindFirstArgs} args - Arguments to find a UserLikeThread
     * @example
     * // Get one UserLikeThread
     * const userLikeThread = await prisma.userLikeThread.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserLikeThreadFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserLikeThreadFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserLikeThread'> extends True ? Prisma__UserLikeThreadClient<UserLikeThreadGetPayload<T>> : Prisma__UserLikeThreadClient<UserLikeThreadGetPayload<T> | null, null>

    /**
     * Find the first UserLikeThread that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikeThreadFindFirstOrThrowArgs} args - Arguments to find a UserLikeThread
     * @example
     * // Get one UserLikeThread
     * const userLikeThread = await prisma.userLikeThread.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserLikeThreadFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserLikeThreadFindFirstOrThrowArgs>
    ): Prisma__UserLikeThreadClient<UserLikeThreadGetPayload<T>>

    /**
     * Find zero or more UserLikeThreads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikeThreadFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLikeThreads
     * const userLikeThreads = await prisma.userLikeThread.findMany()
     * 
     * // Get first 10 UserLikeThreads
     * const userLikeThreads = await prisma.userLikeThread.findMany({ take: 10 })
     * 
     * // Only select the `username`
     * const userLikeThreadWithUsernameOnly = await prisma.userLikeThread.findMany({ select: { username: true } })
     * 
    **/
    findMany<T extends UserLikeThreadFindManyArgs>(
      args?: SelectSubset<T, UserLikeThreadFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserLikeThreadGetPayload<T>>>

    /**
     * Create a UserLikeThread.
     * @param {UserLikeThreadCreateArgs} args - Arguments to create a UserLikeThread.
     * @example
     * // Create one UserLikeThread
     * const UserLikeThread = await prisma.userLikeThread.create({
     *   data: {
     *     // ... data to create a UserLikeThread
     *   }
     * })
     * 
    **/
    create<T extends UserLikeThreadCreateArgs>(
      args: SelectSubset<T, UserLikeThreadCreateArgs>
    ): Prisma__UserLikeThreadClient<UserLikeThreadGetPayload<T>>

    /**
     * Create many UserLikeThreads.
     *     @param {UserLikeThreadCreateManyArgs} args - Arguments to create many UserLikeThreads.
     *     @example
     *     // Create many UserLikeThreads
     *     const userLikeThread = await prisma.userLikeThread.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserLikeThreadCreateManyArgs>(
      args?: SelectSubset<T, UserLikeThreadCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserLikeThread.
     * @param {UserLikeThreadDeleteArgs} args - Arguments to delete one UserLikeThread.
     * @example
     * // Delete one UserLikeThread
     * const UserLikeThread = await prisma.userLikeThread.delete({
     *   where: {
     *     // ... filter to delete one UserLikeThread
     *   }
     * })
     * 
    **/
    delete<T extends UserLikeThreadDeleteArgs>(
      args: SelectSubset<T, UserLikeThreadDeleteArgs>
    ): Prisma__UserLikeThreadClient<UserLikeThreadGetPayload<T>>

    /**
     * Update one UserLikeThread.
     * @param {UserLikeThreadUpdateArgs} args - Arguments to update one UserLikeThread.
     * @example
     * // Update one UserLikeThread
     * const userLikeThread = await prisma.userLikeThread.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserLikeThreadUpdateArgs>(
      args: SelectSubset<T, UserLikeThreadUpdateArgs>
    ): Prisma__UserLikeThreadClient<UserLikeThreadGetPayload<T>>

    /**
     * Delete zero or more UserLikeThreads.
     * @param {UserLikeThreadDeleteManyArgs} args - Arguments to filter UserLikeThreads to delete.
     * @example
     * // Delete a few UserLikeThreads
     * const { count } = await prisma.userLikeThread.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserLikeThreadDeleteManyArgs>(
      args?: SelectSubset<T, UserLikeThreadDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLikeThreads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikeThreadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLikeThreads
     * const userLikeThread = await prisma.userLikeThread.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserLikeThreadUpdateManyArgs>(
      args: SelectSubset<T, UserLikeThreadUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserLikeThread.
     * @param {UserLikeThreadUpsertArgs} args - Arguments to update or create a UserLikeThread.
     * @example
     * // Update or create a UserLikeThread
     * const userLikeThread = await prisma.userLikeThread.upsert({
     *   create: {
     *     // ... data to create a UserLikeThread
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLikeThread we want to update
     *   }
     * })
    **/
    upsert<T extends UserLikeThreadUpsertArgs>(
      args: SelectSubset<T, UserLikeThreadUpsertArgs>
    ): Prisma__UserLikeThreadClient<UserLikeThreadGetPayload<T>>

    /**
     * Count the number of UserLikeThreads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikeThreadCountArgs} args - Arguments to filter UserLikeThreads to count.
     * @example
     * // Count the number of UserLikeThreads
     * const count = await prisma.userLikeThread.count({
     *   where: {
     *     // ... the filter for the UserLikeThreads we want to count
     *   }
     * })
    **/
    count<T extends UserLikeThreadCountArgs>(
      args?: Subset<T, UserLikeThreadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLikeThreadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserLikeThread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikeThreadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserLikeThreadAggregateArgs>(args: Subset<T, UserLikeThreadAggregateArgs>): Prisma.PrismaPromise<GetUserLikeThreadAggregateType<T>>

    /**
     * Group by UserLikeThread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikeThreadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserLikeThreadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLikeThreadGroupByArgs['orderBy'] }
        : { orderBy?: UserLikeThreadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserLikeThreadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserLikeThreadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLikeThread.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserLikeThreadClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    thread<T extends ThreadArgs= {}>(args?: Subset<T, ThreadArgs>): Prisma__ThreadClient<ThreadGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserLikeThread base type for findUnique actions
   */
  export type UserLikeThreadFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserLikeThread
     */
    select?: UserLikeThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLikeThreadInclude | null
    /**
     * Filter, which UserLikeThread to fetch.
     */
    where: UserLikeThreadWhereUniqueInput
  }

  /**
   * UserLikeThread findUnique
   */
  export interface UserLikeThreadFindUniqueArgs extends UserLikeThreadFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserLikeThread findUniqueOrThrow
   */
  export type UserLikeThreadFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserLikeThread
     */
    select?: UserLikeThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLikeThreadInclude | null
    /**
     * Filter, which UserLikeThread to fetch.
     */
    where: UserLikeThreadWhereUniqueInput
  }


  /**
   * UserLikeThread base type for findFirst actions
   */
  export type UserLikeThreadFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserLikeThread
     */
    select?: UserLikeThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLikeThreadInclude | null
    /**
     * Filter, which UserLikeThread to fetch.
     */
    where?: UserLikeThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLikeThreads to fetch.
     */
    orderBy?: Enumerable<UserLikeThreadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLikeThreads.
     */
    cursor?: UserLikeThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLikeThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLikeThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLikeThreads.
     */
    distinct?: Enumerable<UserLikeThreadScalarFieldEnum>
  }

  /**
   * UserLikeThread findFirst
   */
  export interface UserLikeThreadFindFirstArgs extends UserLikeThreadFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserLikeThread findFirstOrThrow
   */
  export type UserLikeThreadFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserLikeThread
     */
    select?: UserLikeThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLikeThreadInclude | null
    /**
     * Filter, which UserLikeThread to fetch.
     */
    where?: UserLikeThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLikeThreads to fetch.
     */
    orderBy?: Enumerable<UserLikeThreadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLikeThreads.
     */
    cursor?: UserLikeThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLikeThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLikeThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLikeThreads.
     */
    distinct?: Enumerable<UserLikeThreadScalarFieldEnum>
  }


  /**
   * UserLikeThread findMany
   */
  export type UserLikeThreadFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserLikeThread
     */
    select?: UserLikeThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLikeThreadInclude | null
    /**
     * Filter, which UserLikeThreads to fetch.
     */
    where?: UserLikeThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLikeThreads to fetch.
     */
    orderBy?: Enumerable<UserLikeThreadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserLikeThreads.
     */
    cursor?: UserLikeThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLikeThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLikeThreads.
     */
    skip?: number
    distinct?: Enumerable<UserLikeThreadScalarFieldEnum>
  }


  /**
   * UserLikeThread create
   */
  export type UserLikeThreadCreateArgs = {
    /**
     * Select specific fields to fetch from the UserLikeThread
     */
    select?: UserLikeThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLikeThreadInclude | null
    /**
     * The data needed to create a UserLikeThread.
     */
    data: XOR<UserLikeThreadCreateInput, UserLikeThreadUncheckedCreateInput>
  }


  /**
   * UserLikeThread createMany
   */
  export type UserLikeThreadCreateManyArgs = {
    /**
     * The data used to create many UserLikeThreads.
     */
    data: Enumerable<UserLikeThreadCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserLikeThread update
   */
  export type UserLikeThreadUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserLikeThread
     */
    select?: UserLikeThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLikeThreadInclude | null
    /**
     * The data needed to update a UserLikeThread.
     */
    data: XOR<UserLikeThreadUpdateInput, UserLikeThreadUncheckedUpdateInput>
    /**
     * Choose, which UserLikeThread to update.
     */
    where: UserLikeThreadWhereUniqueInput
  }


  /**
   * UserLikeThread updateMany
   */
  export type UserLikeThreadUpdateManyArgs = {
    /**
     * The data used to update UserLikeThreads.
     */
    data: XOR<UserLikeThreadUpdateManyMutationInput, UserLikeThreadUncheckedUpdateManyInput>
    /**
     * Filter which UserLikeThreads to update
     */
    where?: UserLikeThreadWhereInput
  }


  /**
   * UserLikeThread upsert
   */
  export type UserLikeThreadUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserLikeThread
     */
    select?: UserLikeThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLikeThreadInclude | null
    /**
     * The filter to search for the UserLikeThread to update in case it exists.
     */
    where: UserLikeThreadWhereUniqueInput
    /**
     * In case the UserLikeThread found by the `where` argument doesn't exist, create a new UserLikeThread with this data.
     */
    create: XOR<UserLikeThreadCreateInput, UserLikeThreadUncheckedCreateInput>
    /**
     * In case the UserLikeThread was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLikeThreadUpdateInput, UserLikeThreadUncheckedUpdateInput>
  }


  /**
   * UserLikeThread delete
   */
  export type UserLikeThreadDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserLikeThread
     */
    select?: UserLikeThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLikeThreadInclude | null
    /**
     * Filter which UserLikeThread to delete.
     */
    where: UserLikeThreadWhereUniqueInput
  }


  /**
   * UserLikeThread deleteMany
   */
  export type UserLikeThreadDeleteManyArgs = {
    /**
     * Filter which UserLikeThreads to delete
     */
    where?: UserLikeThreadWhereInput
  }


  /**
   * UserLikeThread without action
   */
  export type UserLikeThreadArgs = {
    /**
     * Select specific fields to fetch from the UserLikeThread
     */
    select?: UserLikeThreadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLikeThreadInclude | null
  }



  /**
   * Model UserLikeComment
   */


  export type AggregateUserLikeComment = {
    _count: UserLikeCommentCountAggregateOutputType | null
    _min: UserLikeCommentMinAggregateOutputType | null
    _max: UserLikeCommentMaxAggregateOutputType | null
  }

  export type UserLikeCommentMinAggregateOutputType = {
    username: string | null
    commentId: string | null
    disable: boolean | null
  }

  export type UserLikeCommentMaxAggregateOutputType = {
    username: string | null
    commentId: string | null
    disable: boolean | null
  }

  export type UserLikeCommentCountAggregateOutputType = {
    username: number
    commentId: number
    disable: number
    _all: number
  }


  export type UserLikeCommentMinAggregateInputType = {
    username?: true
    commentId?: true
    disable?: true
  }

  export type UserLikeCommentMaxAggregateInputType = {
    username?: true
    commentId?: true
    disable?: true
  }

  export type UserLikeCommentCountAggregateInputType = {
    username?: true
    commentId?: true
    disable?: true
    _all?: true
  }

  export type UserLikeCommentAggregateArgs = {
    /**
     * Filter which UserLikeComment to aggregate.
     */
    where?: UserLikeCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLikeComments to fetch.
     */
    orderBy?: Enumerable<UserLikeCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserLikeCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLikeComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLikeComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserLikeComments
    **/
    _count?: true | UserLikeCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserLikeCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserLikeCommentMaxAggregateInputType
  }

  export type GetUserLikeCommentAggregateType<T extends UserLikeCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateUserLikeComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLikeComment[P]>
      : GetScalarType<T[P], AggregateUserLikeComment[P]>
  }




  export type UserLikeCommentGroupByArgs = {
    where?: UserLikeCommentWhereInput
    orderBy?: Enumerable<UserLikeCommentOrderByWithAggregationInput>
    by: UserLikeCommentScalarFieldEnum[]
    having?: UserLikeCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserLikeCommentCountAggregateInputType | true
    _min?: UserLikeCommentMinAggregateInputType
    _max?: UserLikeCommentMaxAggregateInputType
  }


  export type UserLikeCommentGroupByOutputType = {
    username: string
    commentId: string
    disable: boolean
    _count: UserLikeCommentCountAggregateOutputType | null
    _min: UserLikeCommentMinAggregateOutputType | null
    _max: UserLikeCommentMaxAggregateOutputType | null
  }

  type GetUserLikeCommentGroupByPayload<T extends UserLikeCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserLikeCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserLikeCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLikeCommentGroupByOutputType[P]>
            : GetScalarType<T[P], UserLikeCommentGroupByOutputType[P]>
        }
      >
    >


  export type UserLikeCommentSelect = {
    username?: boolean
    commentId?: boolean
    disable?: boolean
    user?: boolean | UserArgs
    comment?: boolean | CommentArgs
  }


  export type UserLikeCommentInclude = {
    user?: boolean | UserArgs
    comment?: boolean | CommentArgs
  }

  export type UserLikeCommentGetPayload<S extends boolean | null | undefined | UserLikeCommentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserLikeComment :
    S extends undefined ? never :
    S extends { include: any } & (UserLikeCommentArgs | UserLikeCommentFindManyArgs)
    ? UserLikeComment  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'comment' ? CommentGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserLikeCommentArgs | UserLikeCommentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'comment' ? CommentGetPayload<S['select'][P]> :  P extends keyof UserLikeComment ? UserLikeComment[P] : never
  } 
      : UserLikeComment


  type UserLikeCommentCountArgs = 
    Omit<UserLikeCommentFindManyArgs, 'select' | 'include'> & {
      select?: UserLikeCommentCountAggregateInputType | true
    }

  export interface UserLikeCommentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UserLikeComment that matches the filter.
     * @param {UserLikeCommentFindUniqueArgs} args - Arguments to find a UserLikeComment
     * @example
     * // Get one UserLikeComment
     * const userLikeComment = await prisma.userLikeComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserLikeCommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserLikeCommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserLikeComment'> extends True ? Prisma__UserLikeCommentClient<UserLikeCommentGetPayload<T>> : Prisma__UserLikeCommentClient<UserLikeCommentGetPayload<T> | null, null>

    /**
     * Find one UserLikeComment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserLikeCommentFindUniqueOrThrowArgs} args - Arguments to find a UserLikeComment
     * @example
     * // Get one UserLikeComment
     * const userLikeComment = await prisma.userLikeComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserLikeCommentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserLikeCommentFindUniqueOrThrowArgs>
    ): Prisma__UserLikeCommentClient<UserLikeCommentGetPayload<T>>

    /**
     * Find the first UserLikeComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikeCommentFindFirstArgs} args - Arguments to find a UserLikeComment
     * @example
     * // Get one UserLikeComment
     * const userLikeComment = await prisma.userLikeComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserLikeCommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserLikeCommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserLikeComment'> extends True ? Prisma__UserLikeCommentClient<UserLikeCommentGetPayload<T>> : Prisma__UserLikeCommentClient<UserLikeCommentGetPayload<T> | null, null>

    /**
     * Find the first UserLikeComment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikeCommentFindFirstOrThrowArgs} args - Arguments to find a UserLikeComment
     * @example
     * // Get one UserLikeComment
     * const userLikeComment = await prisma.userLikeComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserLikeCommentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserLikeCommentFindFirstOrThrowArgs>
    ): Prisma__UserLikeCommentClient<UserLikeCommentGetPayload<T>>

    /**
     * Find zero or more UserLikeComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikeCommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLikeComments
     * const userLikeComments = await prisma.userLikeComment.findMany()
     * 
     * // Get first 10 UserLikeComments
     * const userLikeComments = await prisma.userLikeComment.findMany({ take: 10 })
     * 
     * // Only select the `username`
     * const userLikeCommentWithUsernameOnly = await prisma.userLikeComment.findMany({ select: { username: true } })
     * 
    **/
    findMany<T extends UserLikeCommentFindManyArgs>(
      args?: SelectSubset<T, UserLikeCommentFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserLikeCommentGetPayload<T>>>

    /**
     * Create a UserLikeComment.
     * @param {UserLikeCommentCreateArgs} args - Arguments to create a UserLikeComment.
     * @example
     * // Create one UserLikeComment
     * const UserLikeComment = await prisma.userLikeComment.create({
     *   data: {
     *     // ... data to create a UserLikeComment
     *   }
     * })
     * 
    **/
    create<T extends UserLikeCommentCreateArgs>(
      args: SelectSubset<T, UserLikeCommentCreateArgs>
    ): Prisma__UserLikeCommentClient<UserLikeCommentGetPayload<T>>

    /**
     * Create many UserLikeComments.
     *     @param {UserLikeCommentCreateManyArgs} args - Arguments to create many UserLikeComments.
     *     @example
     *     // Create many UserLikeComments
     *     const userLikeComment = await prisma.userLikeComment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserLikeCommentCreateManyArgs>(
      args?: SelectSubset<T, UserLikeCommentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserLikeComment.
     * @param {UserLikeCommentDeleteArgs} args - Arguments to delete one UserLikeComment.
     * @example
     * // Delete one UserLikeComment
     * const UserLikeComment = await prisma.userLikeComment.delete({
     *   where: {
     *     // ... filter to delete one UserLikeComment
     *   }
     * })
     * 
    **/
    delete<T extends UserLikeCommentDeleteArgs>(
      args: SelectSubset<T, UserLikeCommentDeleteArgs>
    ): Prisma__UserLikeCommentClient<UserLikeCommentGetPayload<T>>

    /**
     * Update one UserLikeComment.
     * @param {UserLikeCommentUpdateArgs} args - Arguments to update one UserLikeComment.
     * @example
     * // Update one UserLikeComment
     * const userLikeComment = await prisma.userLikeComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserLikeCommentUpdateArgs>(
      args: SelectSubset<T, UserLikeCommentUpdateArgs>
    ): Prisma__UserLikeCommentClient<UserLikeCommentGetPayload<T>>

    /**
     * Delete zero or more UserLikeComments.
     * @param {UserLikeCommentDeleteManyArgs} args - Arguments to filter UserLikeComments to delete.
     * @example
     * // Delete a few UserLikeComments
     * const { count } = await prisma.userLikeComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserLikeCommentDeleteManyArgs>(
      args?: SelectSubset<T, UserLikeCommentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLikeComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikeCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLikeComments
     * const userLikeComment = await prisma.userLikeComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserLikeCommentUpdateManyArgs>(
      args: SelectSubset<T, UserLikeCommentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserLikeComment.
     * @param {UserLikeCommentUpsertArgs} args - Arguments to update or create a UserLikeComment.
     * @example
     * // Update or create a UserLikeComment
     * const userLikeComment = await prisma.userLikeComment.upsert({
     *   create: {
     *     // ... data to create a UserLikeComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLikeComment we want to update
     *   }
     * })
    **/
    upsert<T extends UserLikeCommentUpsertArgs>(
      args: SelectSubset<T, UserLikeCommentUpsertArgs>
    ): Prisma__UserLikeCommentClient<UserLikeCommentGetPayload<T>>

    /**
     * Count the number of UserLikeComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikeCommentCountArgs} args - Arguments to filter UserLikeComments to count.
     * @example
     * // Count the number of UserLikeComments
     * const count = await prisma.userLikeComment.count({
     *   where: {
     *     // ... the filter for the UserLikeComments we want to count
     *   }
     * })
    **/
    count<T extends UserLikeCommentCountArgs>(
      args?: Subset<T, UserLikeCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLikeCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserLikeComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikeCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserLikeCommentAggregateArgs>(args: Subset<T, UserLikeCommentAggregateArgs>): Prisma.PrismaPromise<GetUserLikeCommentAggregateType<T>>

    /**
     * Group by UserLikeComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLikeCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserLikeCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLikeCommentGroupByArgs['orderBy'] }
        : { orderBy?: UserLikeCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserLikeCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserLikeCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLikeComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserLikeCommentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    comment<T extends CommentArgs= {}>(args?: Subset<T, CommentArgs>): Prisma__CommentClient<CommentGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserLikeComment base type for findUnique actions
   */
  export type UserLikeCommentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserLikeComment
     */
    select?: UserLikeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLikeCommentInclude | null
    /**
     * Filter, which UserLikeComment to fetch.
     */
    where: UserLikeCommentWhereUniqueInput
  }

  /**
   * UserLikeComment findUnique
   */
  export interface UserLikeCommentFindUniqueArgs extends UserLikeCommentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserLikeComment findUniqueOrThrow
   */
  export type UserLikeCommentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserLikeComment
     */
    select?: UserLikeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLikeCommentInclude | null
    /**
     * Filter, which UserLikeComment to fetch.
     */
    where: UserLikeCommentWhereUniqueInput
  }


  /**
   * UserLikeComment base type for findFirst actions
   */
  export type UserLikeCommentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserLikeComment
     */
    select?: UserLikeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLikeCommentInclude | null
    /**
     * Filter, which UserLikeComment to fetch.
     */
    where?: UserLikeCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLikeComments to fetch.
     */
    orderBy?: Enumerable<UserLikeCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLikeComments.
     */
    cursor?: UserLikeCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLikeComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLikeComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLikeComments.
     */
    distinct?: Enumerable<UserLikeCommentScalarFieldEnum>
  }

  /**
   * UserLikeComment findFirst
   */
  export interface UserLikeCommentFindFirstArgs extends UserLikeCommentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserLikeComment findFirstOrThrow
   */
  export type UserLikeCommentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserLikeComment
     */
    select?: UserLikeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLikeCommentInclude | null
    /**
     * Filter, which UserLikeComment to fetch.
     */
    where?: UserLikeCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLikeComments to fetch.
     */
    orderBy?: Enumerable<UserLikeCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLikeComments.
     */
    cursor?: UserLikeCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLikeComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLikeComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLikeComments.
     */
    distinct?: Enumerable<UserLikeCommentScalarFieldEnum>
  }


  /**
   * UserLikeComment findMany
   */
  export type UserLikeCommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserLikeComment
     */
    select?: UserLikeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLikeCommentInclude | null
    /**
     * Filter, which UserLikeComments to fetch.
     */
    where?: UserLikeCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLikeComments to fetch.
     */
    orderBy?: Enumerable<UserLikeCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserLikeComments.
     */
    cursor?: UserLikeCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLikeComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLikeComments.
     */
    skip?: number
    distinct?: Enumerable<UserLikeCommentScalarFieldEnum>
  }


  /**
   * UserLikeComment create
   */
  export type UserLikeCommentCreateArgs = {
    /**
     * Select specific fields to fetch from the UserLikeComment
     */
    select?: UserLikeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLikeCommentInclude | null
    /**
     * The data needed to create a UserLikeComment.
     */
    data: XOR<UserLikeCommentCreateInput, UserLikeCommentUncheckedCreateInput>
  }


  /**
   * UserLikeComment createMany
   */
  export type UserLikeCommentCreateManyArgs = {
    /**
     * The data used to create many UserLikeComments.
     */
    data: Enumerable<UserLikeCommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserLikeComment update
   */
  export type UserLikeCommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserLikeComment
     */
    select?: UserLikeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLikeCommentInclude | null
    /**
     * The data needed to update a UserLikeComment.
     */
    data: XOR<UserLikeCommentUpdateInput, UserLikeCommentUncheckedUpdateInput>
    /**
     * Choose, which UserLikeComment to update.
     */
    where: UserLikeCommentWhereUniqueInput
  }


  /**
   * UserLikeComment updateMany
   */
  export type UserLikeCommentUpdateManyArgs = {
    /**
     * The data used to update UserLikeComments.
     */
    data: XOR<UserLikeCommentUpdateManyMutationInput, UserLikeCommentUncheckedUpdateManyInput>
    /**
     * Filter which UserLikeComments to update
     */
    where?: UserLikeCommentWhereInput
  }


  /**
   * UserLikeComment upsert
   */
  export type UserLikeCommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserLikeComment
     */
    select?: UserLikeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLikeCommentInclude | null
    /**
     * The filter to search for the UserLikeComment to update in case it exists.
     */
    where: UserLikeCommentWhereUniqueInput
    /**
     * In case the UserLikeComment found by the `where` argument doesn't exist, create a new UserLikeComment with this data.
     */
    create: XOR<UserLikeCommentCreateInput, UserLikeCommentUncheckedCreateInput>
    /**
     * In case the UserLikeComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLikeCommentUpdateInput, UserLikeCommentUncheckedUpdateInput>
  }


  /**
   * UserLikeComment delete
   */
  export type UserLikeCommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserLikeComment
     */
    select?: UserLikeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLikeCommentInclude | null
    /**
     * Filter which UserLikeComment to delete.
     */
    where: UserLikeCommentWhereUniqueInput
  }


  /**
   * UserLikeComment deleteMany
   */
  export type UserLikeCommentDeleteManyArgs = {
    /**
     * Filter which UserLikeComments to delete
     */
    where?: UserLikeCommentWhereInput
  }


  /**
   * UserLikeComment without action
   */
  export type UserLikeCommentArgs = {
    /**
     * Select specific fields to fetch from the UserLikeComment
     */
    select?: UserLikeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLikeCommentInclude | null
  }



  /**
   * Model Comment
   */


  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    totalChildren: number | null
    depth: number | null
    likes: number | null
  }

  export type CommentSumAggregateOutputType = {
    totalChildren: number | null
    depth: number | null
    likes: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    threadId: string | null
    parentId: string | null
    rootId: string | null
    totalChildren: number | null
    depth: number | null
    likes: number | null
    parentUsername: string | null
    creatorId: string | null
    published: boolean | null
    createdAt: Date | null
    content: string | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    threadId: string | null
    parentId: string | null
    rootId: string | null
    totalChildren: number | null
    depth: number | null
    likes: number | null
    parentUsername: string | null
    creatorId: string | null
    published: boolean | null
    createdAt: Date | null
    content: string | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    threadId: number
    parentId: number
    rootId: number
    totalChildren: number
    depth: number
    likes: number
    parentUsername: number
    creatorId: number
    published: number
    createdAt: number
    content: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    totalChildren?: true
    depth?: true
    likes?: true
  }

  export type CommentSumAggregateInputType = {
    totalChildren?: true
    depth?: true
    likes?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    threadId?: true
    parentId?: true
    rootId?: true
    totalChildren?: true
    depth?: true
    likes?: true
    parentUsername?: true
    creatorId?: true
    published?: true
    createdAt?: true
    content?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    threadId?: true
    parentId?: true
    rootId?: true
    totalChildren?: true
    depth?: true
    likes?: true
    parentUsername?: true
    creatorId?: true
    published?: true
    createdAt?: true
    content?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    threadId?: true
    parentId?: true
    rootId?: true
    totalChildren?: true
    depth?: true
    likes?: true
    parentUsername?: true
    creatorId?: true
    published?: true
    createdAt?: true
    content?: true
    _all?: true
  }

  export type CommentAggregateArgs = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs = {
    where?: CommentWhereInput
    orderBy?: Enumerable<CommentOrderByWithAggregationInput>
    by: CommentScalarFieldEnum[]
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }


  export type CommentGroupByOutputType = {
    id: string
    threadId: string
    parentId: string | null
    rootId: string
    totalChildren: number
    depth: number
    likes: number
    parentUsername: string | null
    creatorId: string
    published: boolean
    createdAt: Date
    content: string
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect = {
    id?: boolean
    threadId?: boolean
    parentId?: boolean
    rootId?: boolean
    totalChildren?: boolean
    depth?: boolean
    likes?: boolean
    parentUsername?: boolean
    creatorId?: boolean
    published?: boolean
    createdAt?: boolean
    content?: boolean
    thread?: boolean | ThreadArgs
    creator?: boolean | UserArgs
    usersLiked?: boolean | Comment$usersLikedArgs
    _count?: boolean | CommentCountOutputTypeArgs
  }


  export type CommentInclude = {
    thread?: boolean | ThreadArgs
    creator?: boolean | UserArgs
    usersLiked?: boolean | Comment$usersLikedArgs
    _count?: boolean | CommentCountOutputTypeArgs
  }

  export type CommentGetPayload<S extends boolean | null | undefined | CommentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Comment :
    S extends undefined ? never :
    S extends { include: any } & (CommentArgs | CommentFindManyArgs)
    ? Comment  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'thread' ? ThreadGetPayload<S['include'][P]> :
        P extends 'creator' ? UserGetPayload<S['include'][P]> :
        P extends 'usersLiked' ? Array < UserLikeCommentGetPayload<S['include'][P]>>  :
        P extends '_count' ? CommentCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CommentArgs | CommentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'thread' ? ThreadGetPayload<S['select'][P]> :
        P extends 'creator' ? UserGetPayload<S['select'][P]> :
        P extends 'usersLiked' ? Array < UserLikeCommentGetPayload<S['select'][P]>>  :
        P extends '_count' ? CommentCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Comment ? Comment[P] : never
  } 
      : Comment


  type CommentCountArgs = 
    Omit<CommentFindManyArgs, 'select' | 'include'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Comment'> extends True ? Prisma__CommentClient<CommentGetPayload<T>> : Prisma__CommentClient<CommentGetPayload<T> | null, null>

    /**
     * Find one Comment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CommentFindUniqueOrThrowArgs>
    ): Prisma__CommentClient<CommentGetPayload<T>>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Comment'> extends True ? Prisma__CommentClient<CommentGetPayload<T>> : Prisma__CommentClient<CommentGetPayload<T> | null, null>

    /**
     * Find the first Comment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CommentFindFirstOrThrowArgs>
    ): Prisma__CommentClient<CommentGetPayload<T>>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommentFindManyArgs>(
      args?: SelectSubset<T, CommentFindManyArgs>
    ): Prisma.PrismaPromise<Array<CommentGetPayload<T>>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
    **/
    create<T extends CommentCreateArgs>(
      args: SelectSubset<T, CommentCreateArgs>
    ): Prisma__CommentClient<CommentGetPayload<T>>

    /**
     * Create many Comments.
     *     @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     *     @example
     *     // Create many Comments
     *     const comment = await prisma.comment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommentCreateManyArgs>(
      args?: SelectSubset<T, CommentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
    **/
    delete<T extends CommentDeleteArgs>(
      args: SelectSubset<T, CommentDeleteArgs>
    ): Prisma__CommentClient<CommentGetPayload<T>>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentUpdateArgs>(
      args: SelectSubset<T, CommentUpdateArgs>
    ): Prisma__CommentClient<CommentGetPayload<T>>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentDeleteManyArgs>(
      args?: SelectSubset<T, CommentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentUpdateManyArgs>(
      args: SelectSubset<T, CommentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
    **/
    upsert<T extends CommentUpsertArgs>(
      args: SelectSubset<T, CommentUpsertArgs>
    ): Prisma__CommentClient<CommentGetPayload<T>>

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    thread<T extends ThreadArgs= {}>(args?: Subset<T, ThreadArgs>): Prisma__ThreadClient<ThreadGetPayload<T> | Null>;

    creator<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    usersLiked<T extends Comment$usersLikedArgs= {}>(args?: Subset<T, Comment$usersLikedArgs>): Prisma.PrismaPromise<Array<UserLikeCommentGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Comment base type for findUnique actions
   */
  export type CommentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUnique
   */
  export interface CommentFindUniqueArgs extends CommentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment base type for findFirst actions
   */
  export type CommentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: Enumerable<CommentScalarFieldEnum>
  }

  /**
   * Comment findFirst
   */
  export interface CommentFindFirstArgs extends CommentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * Comment findMany
   */
  export type CommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * Comment create
   */
  export type CommentCreateArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }


  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs = {
    /**
     * The data used to create many Comments.
     */
    data: Enumerable<CommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Comment update
   */
  export type CommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }


  /**
   * Comment upsert
   */
  export type CommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }


  /**
   * Comment delete
   */
  export type CommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }


  /**
   * Comment.usersLiked
   */
  export type Comment$usersLikedArgs = {
    /**
     * Select specific fields to fetch from the UserLikeComment
     */
    select?: UserLikeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLikeCommentInclude | null
    where?: UserLikeCommentWhereInput
    orderBy?: Enumerable<UserLikeCommentOrderByWithRelationInput>
    cursor?: UserLikeCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserLikeCommentScalarFieldEnum>
  }


  /**
   * Comment without action
   */
  export type CommentArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
  }



  /**
   * Model MathProblemCategory
   */


  export type AggregateMathProblemCategory = {
    _count: MathProblemCategoryCountAggregateOutputType | null
    _avg: MathProblemCategoryAvgAggregateOutputType | null
    _sum: MathProblemCategorySumAggregateOutputType | null
    _min: MathProblemCategoryMinAggregateOutputType | null
    _max: MathProblemCategoryMaxAggregateOutputType | null
  }

  export type MathProblemCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type MathProblemCategorySumAggregateOutputType = {
    id: number | null
  }

  export type MathProblemCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type MathProblemCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type MathProblemCategoryCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type MathProblemCategoryAvgAggregateInputType = {
    id?: true
  }

  export type MathProblemCategorySumAggregateInputType = {
    id?: true
  }

  export type MathProblemCategoryMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type MathProblemCategoryMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type MathProblemCategoryCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type MathProblemCategoryAggregateArgs = {
    /**
     * Filter which MathProblemCategory to aggregate.
     */
    where?: MathProblemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MathProblemCategories to fetch.
     */
    orderBy?: Enumerable<MathProblemCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MathProblemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MathProblemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MathProblemCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MathProblemCategories
    **/
    _count?: true | MathProblemCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MathProblemCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MathProblemCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MathProblemCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MathProblemCategoryMaxAggregateInputType
  }

  export type GetMathProblemCategoryAggregateType<T extends MathProblemCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateMathProblemCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMathProblemCategory[P]>
      : GetScalarType<T[P], AggregateMathProblemCategory[P]>
  }




  export type MathProblemCategoryGroupByArgs = {
    where?: MathProblemCategoryWhereInput
    orderBy?: Enumerable<MathProblemCategoryOrderByWithAggregationInput>
    by: MathProblemCategoryScalarFieldEnum[]
    having?: MathProblemCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MathProblemCategoryCountAggregateInputType | true
    _avg?: MathProblemCategoryAvgAggregateInputType
    _sum?: MathProblemCategorySumAggregateInputType
    _min?: MathProblemCategoryMinAggregateInputType
    _max?: MathProblemCategoryMaxAggregateInputType
  }


  export type MathProblemCategoryGroupByOutputType = {
    id: number
    name: string
    _count: MathProblemCategoryCountAggregateOutputType | null
    _avg: MathProblemCategoryAvgAggregateOutputType | null
    _sum: MathProblemCategorySumAggregateOutputType | null
    _min: MathProblemCategoryMinAggregateOutputType | null
    _max: MathProblemCategoryMaxAggregateOutputType | null
  }

  type GetMathProblemCategoryGroupByPayload<T extends MathProblemCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MathProblemCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MathProblemCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MathProblemCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], MathProblemCategoryGroupByOutputType[P]>
        }
      >
    >


  export type MathProblemCategorySelect = {
    id?: boolean
    name?: boolean
    mathProblems?: boolean | MathProblemCategory$mathProblemsArgs
    _count?: boolean | MathProblemCategoryCountOutputTypeArgs
  }


  export type MathProblemCategoryInclude = {
    mathProblems?: boolean | MathProblemCategory$mathProblemsArgs
    _count?: boolean | MathProblemCategoryCountOutputTypeArgs
  }

  export type MathProblemCategoryGetPayload<S extends boolean | null | undefined | MathProblemCategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MathProblemCategory :
    S extends undefined ? never :
    S extends { include: any } & (MathProblemCategoryArgs | MathProblemCategoryFindManyArgs)
    ? MathProblemCategory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'mathProblems' ? Array < MathProblemGetPayload<S['include'][P]>>  :
        P extends '_count' ? MathProblemCategoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MathProblemCategoryArgs | MathProblemCategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'mathProblems' ? Array < MathProblemGetPayload<S['select'][P]>>  :
        P extends '_count' ? MathProblemCategoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof MathProblemCategory ? MathProblemCategory[P] : never
  } 
      : MathProblemCategory


  type MathProblemCategoryCountArgs = 
    Omit<MathProblemCategoryFindManyArgs, 'select' | 'include'> & {
      select?: MathProblemCategoryCountAggregateInputType | true
    }

  export interface MathProblemCategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MathProblemCategory that matches the filter.
     * @param {MathProblemCategoryFindUniqueArgs} args - Arguments to find a MathProblemCategory
     * @example
     * // Get one MathProblemCategory
     * const mathProblemCategory = await prisma.mathProblemCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MathProblemCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MathProblemCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MathProblemCategory'> extends True ? Prisma__MathProblemCategoryClient<MathProblemCategoryGetPayload<T>> : Prisma__MathProblemCategoryClient<MathProblemCategoryGetPayload<T> | null, null>

    /**
     * Find one MathProblemCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MathProblemCategoryFindUniqueOrThrowArgs} args - Arguments to find a MathProblemCategory
     * @example
     * // Get one MathProblemCategory
     * const mathProblemCategory = await prisma.mathProblemCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MathProblemCategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MathProblemCategoryFindUniqueOrThrowArgs>
    ): Prisma__MathProblemCategoryClient<MathProblemCategoryGetPayload<T>>

    /**
     * Find the first MathProblemCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathProblemCategoryFindFirstArgs} args - Arguments to find a MathProblemCategory
     * @example
     * // Get one MathProblemCategory
     * const mathProblemCategory = await prisma.mathProblemCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MathProblemCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MathProblemCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MathProblemCategory'> extends True ? Prisma__MathProblemCategoryClient<MathProblemCategoryGetPayload<T>> : Prisma__MathProblemCategoryClient<MathProblemCategoryGetPayload<T> | null, null>

    /**
     * Find the first MathProblemCategory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathProblemCategoryFindFirstOrThrowArgs} args - Arguments to find a MathProblemCategory
     * @example
     * // Get one MathProblemCategory
     * const mathProblemCategory = await prisma.mathProblemCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MathProblemCategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MathProblemCategoryFindFirstOrThrowArgs>
    ): Prisma__MathProblemCategoryClient<MathProblemCategoryGetPayload<T>>

    /**
     * Find zero or more MathProblemCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathProblemCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MathProblemCategories
     * const mathProblemCategories = await prisma.mathProblemCategory.findMany()
     * 
     * // Get first 10 MathProblemCategories
     * const mathProblemCategories = await prisma.mathProblemCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mathProblemCategoryWithIdOnly = await prisma.mathProblemCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MathProblemCategoryFindManyArgs>(
      args?: SelectSubset<T, MathProblemCategoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<MathProblemCategoryGetPayload<T>>>

    /**
     * Create a MathProblemCategory.
     * @param {MathProblemCategoryCreateArgs} args - Arguments to create a MathProblemCategory.
     * @example
     * // Create one MathProblemCategory
     * const MathProblemCategory = await prisma.mathProblemCategory.create({
     *   data: {
     *     // ... data to create a MathProblemCategory
     *   }
     * })
     * 
    **/
    create<T extends MathProblemCategoryCreateArgs>(
      args: SelectSubset<T, MathProblemCategoryCreateArgs>
    ): Prisma__MathProblemCategoryClient<MathProblemCategoryGetPayload<T>>

    /**
     * Create many MathProblemCategories.
     *     @param {MathProblemCategoryCreateManyArgs} args - Arguments to create many MathProblemCategories.
     *     @example
     *     // Create many MathProblemCategories
     *     const mathProblemCategory = await prisma.mathProblemCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MathProblemCategoryCreateManyArgs>(
      args?: SelectSubset<T, MathProblemCategoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MathProblemCategory.
     * @param {MathProblemCategoryDeleteArgs} args - Arguments to delete one MathProblemCategory.
     * @example
     * // Delete one MathProblemCategory
     * const MathProblemCategory = await prisma.mathProblemCategory.delete({
     *   where: {
     *     // ... filter to delete one MathProblemCategory
     *   }
     * })
     * 
    **/
    delete<T extends MathProblemCategoryDeleteArgs>(
      args: SelectSubset<T, MathProblemCategoryDeleteArgs>
    ): Prisma__MathProblemCategoryClient<MathProblemCategoryGetPayload<T>>

    /**
     * Update one MathProblemCategory.
     * @param {MathProblemCategoryUpdateArgs} args - Arguments to update one MathProblemCategory.
     * @example
     * // Update one MathProblemCategory
     * const mathProblemCategory = await prisma.mathProblemCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MathProblemCategoryUpdateArgs>(
      args: SelectSubset<T, MathProblemCategoryUpdateArgs>
    ): Prisma__MathProblemCategoryClient<MathProblemCategoryGetPayload<T>>

    /**
     * Delete zero or more MathProblemCategories.
     * @param {MathProblemCategoryDeleteManyArgs} args - Arguments to filter MathProblemCategories to delete.
     * @example
     * // Delete a few MathProblemCategories
     * const { count } = await prisma.mathProblemCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MathProblemCategoryDeleteManyArgs>(
      args?: SelectSubset<T, MathProblemCategoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MathProblemCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathProblemCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MathProblemCategories
     * const mathProblemCategory = await prisma.mathProblemCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MathProblemCategoryUpdateManyArgs>(
      args: SelectSubset<T, MathProblemCategoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MathProblemCategory.
     * @param {MathProblemCategoryUpsertArgs} args - Arguments to update or create a MathProblemCategory.
     * @example
     * // Update or create a MathProblemCategory
     * const mathProblemCategory = await prisma.mathProblemCategory.upsert({
     *   create: {
     *     // ... data to create a MathProblemCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MathProblemCategory we want to update
     *   }
     * })
    **/
    upsert<T extends MathProblemCategoryUpsertArgs>(
      args: SelectSubset<T, MathProblemCategoryUpsertArgs>
    ): Prisma__MathProblemCategoryClient<MathProblemCategoryGetPayload<T>>

    /**
     * Count the number of MathProblemCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathProblemCategoryCountArgs} args - Arguments to filter MathProblemCategories to count.
     * @example
     * // Count the number of MathProblemCategories
     * const count = await prisma.mathProblemCategory.count({
     *   where: {
     *     // ... the filter for the MathProblemCategories we want to count
     *   }
     * })
    **/
    count<T extends MathProblemCategoryCountArgs>(
      args?: Subset<T, MathProblemCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MathProblemCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MathProblemCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathProblemCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MathProblemCategoryAggregateArgs>(args: Subset<T, MathProblemCategoryAggregateArgs>): Prisma.PrismaPromise<GetMathProblemCategoryAggregateType<T>>

    /**
     * Group by MathProblemCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathProblemCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MathProblemCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MathProblemCategoryGroupByArgs['orderBy'] }
        : { orderBy?: MathProblemCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MathProblemCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMathProblemCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MathProblemCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MathProblemCategoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    mathProblems<T extends MathProblemCategory$mathProblemsArgs= {}>(args?: Subset<T, MathProblemCategory$mathProblemsArgs>): Prisma.PrismaPromise<Array<MathProblemGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MathProblemCategory base type for findUnique actions
   */
  export type MathProblemCategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MathProblemCategory
     */
    select?: MathProblemCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemCategoryInclude | null
    /**
     * Filter, which MathProblemCategory to fetch.
     */
    where: MathProblemCategoryWhereUniqueInput
  }

  /**
   * MathProblemCategory findUnique
   */
  export interface MathProblemCategoryFindUniqueArgs extends MathProblemCategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MathProblemCategory findUniqueOrThrow
   */
  export type MathProblemCategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MathProblemCategory
     */
    select?: MathProblemCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemCategoryInclude | null
    /**
     * Filter, which MathProblemCategory to fetch.
     */
    where: MathProblemCategoryWhereUniqueInput
  }


  /**
   * MathProblemCategory base type for findFirst actions
   */
  export type MathProblemCategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MathProblemCategory
     */
    select?: MathProblemCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemCategoryInclude | null
    /**
     * Filter, which MathProblemCategory to fetch.
     */
    where?: MathProblemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MathProblemCategories to fetch.
     */
    orderBy?: Enumerable<MathProblemCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MathProblemCategories.
     */
    cursor?: MathProblemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MathProblemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MathProblemCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MathProblemCategories.
     */
    distinct?: Enumerable<MathProblemCategoryScalarFieldEnum>
  }

  /**
   * MathProblemCategory findFirst
   */
  export interface MathProblemCategoryFindFirstArgs extends MathProblemCategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MathProblemCategory findFirstOrThrow
   */
  export type MathProblemCategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MathProblemCategory
     */
    select?: MathProblemCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemCategoryInclude | null
    /**
     * Filter, which MathProblemCategory to fetch.
     */
    where?: MathProblemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MathProblemCategories to fetch.
     */
    orderBy?: Enumerable<MathProblemCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MathProblemCategories.
     */
    cursor?: MathProblemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MathProblemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MathProblemCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MathProblemCategories.
     */
    distinct?: Enumerable<MathProblemCategoryScalarFieldEnum>
  }


  /**
   * MathProblemCategory findMany
   */
  export type MathProblemCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the MathProblemCategory
     */
    select?: MathProblemCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemCategoryInclude | null
    /**
     * Filter, which MathProblemCategories to fetch.
     */
    where?: MathProblemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MathProblemCategories to fetch.
     */
    orderBy?: Enumerable<MathProblemCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MathProblemCategories.
     */
    cursor?: MathProblemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MathProblemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MathProblemCategories.
     */
    skip?: number
    distinct?: Enumerable<MathProblemCategoryScalarFieldEnum>
  }


  /**
   * MathProblemCategory create
   */
  export type MathProblemCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the MathProblemCategory
     */
    select?: MathProblemCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemCategoryInclude | null
    /**
     * The data needed to create a MathProblemCategory.
     */
    data: XOR<MathProblemCategoryCreateInput, MathProblemCategoryUncheckedCreateInput>
  }


  /**
   * MathProblemCategory createMany
   */
  export type MathProblemCategoryCreateManyArgs = {
    /**
     * The data used to create many MathProblemCategories.
     */
    data: Enumerable<MathProblemCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MathProblemCategory update
   */
  export type MathProblemCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the MathProblemCategory
     */
    select?: MathProblemCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemCategoryInclude | null
    /**
     * The data needed to update a MathProblemCategory.
     */
    data: XOR<MathProblemCategoryUpdateInput, MathProblemCategoryUncheckedUpdateInput>
    /**
     * Choose, which MathProblemCategory to update.
     */
    where: MathProblemCategoryWhereUniqueInput
  }


  /**
   * MathProblemCategory updateMany
   */
  export type MathProblemCategoryUpdateManyArgs = {
    /**
     * The data used to update MathProblemCategories.
     */
    data: XOR<MathProblemCategoryUpdateManyMutationInput, MathProblemCategoryUncheckedUpdateManyInput>
    /**
     * Filter which MathProblemCategories to update
     */
    where?: MathProblemCategoryWhereInput
  }


  /**
   * MathProblemCategory upsert
   */
  export type MathProblemCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the MathProblemCategory
     */
    select?: MathProblemCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemCategoryInclude | null
    /**
     * The filter to search for the MathProblemCategory to update in case it exists.
     */
    where: MathProblemCategoryWhereUniqueInput
    /**
     * In case the MathProblemCategory found by the `where` argument doesn't exist, create a new MathProblemCategory with this data.
     */
    create: XOR<MathProblemCategoryCreateInput, MathProblemCategoryUncheckedCreateInput>
    /**
     * In case the MathProblemCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MathProblemCategoryUpdateInput, MathProblemCategoryUncheckedUpdateInput>
  }


  /**
   * MathProblemCategory delete
   */
  export type MathProblemCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the MathProblemCategory
     */
    select?: MathProblemCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemCategoryInclude | null
    /**
     * Filter which MathProblemCategory to delete.
     */
    where: MathProblemCategoryWhereUniqueInput
  }


  /**
   * MathProblemCategory deleteMany
   */
  export type MathProblemCategoryDeleteManyArgs = {
    /**
     * Filter which MathProblemCategories to delete
     */
    where?: MathProblemCategoryWhereInput
  }


  /**
   * MathProblemCategory.mathProblems
   */
  export type MathProblemCategory$mathProblemsArgs = {
    /**
     * Select specific fields to fetch from the MathProblem
     */
    select?: MathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemInclude | null
    where?: MathProblemWhereInput
    orderBy?: Enumerable<MathProblemOrderByWithRelationInput>
    cursor?: MathProblemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MathProblemScalarFieldEnum>
  }


  /**
   * MathProblemCategory without action
   */
  export type MathProblemCategoryArgs = {
    /**
     * Select specific fields to fetch from the MathProblemCategory
     */
    select?: MathProblemCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemCategoryInclude | null
  }



  /**
   * Model MathProblemTag
   */


  export type AggregateMathProblemTag = {
    _count: MathProblemTagCountAggregateOutputType | null
    _avg: MathProblemTagAvgAggregateOutputType | null
    _sum: MathProblemTagSumAggregateOutputType | null
    _min: MathProblemTagMinAggregateOutputType | null
    _max: MathProblemTagMaxAggregateOutputType | null
  }

  export type MathProblemTagAvgAggregateOutputType = {
    id: number | null
    parentId: number | null
    nextSibling: number | null
    prevSibling: number | null
  }

  export type MathProblemTagSumAggregateOutputType = {
    id: number | null
    parentId: number | null
    nextSibling: number | null
    prevSibling: number | null
  }

  export type MathProblemTagMinAggregateOutputType = {
    id: number | null
    name: string | null
    parentId: number | null
    nextSibling: number | null
    prevSibling: number | null
  }

  export type MathProblemTagMaxAggregateOutputType = {
    id: number | null
    name: string | null
    parentId: number | null
    nextSibling: number | null
    prevSibling: number | null
  }

  export type MathProblemTagCountAggregateOutputType = {
    id: number
    name: number
    parentId: number
    nextSibling: number
    prevSibling: number
    _all: number
  }


  export type MathProblemTagAvgAggregateInputType = {
    id?: true
    parentId?: true
    nextSibling?: true
    prevSibling?: true
  }

  export type MathProblemTagSumAggregateInputType = {
    id?: true
    parentId?: true
    nextSibling?: true
    prevSibling?: true
  }

  export type MathProblemTagMinAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    nextSibling?: true
    prevSibling?: true
  }

  export type MathProblemTagMaxAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    nextSibling?: true
    prevSibling?: true
  }

  export type MathProblemTagCountAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    nextSibling?: true
    prevSibling?: true
    _all?: true
  }

  export type MathProblemTagAggregateArgs = {
    /**
     * Filter which MathProblemTag to aggregate.
     */
    where?: MathProblemTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MathProblemTags to fetch.
     */
    orderBy?: Enumerable<MathProblemTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MathProblemTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MathProblemTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MathProblemTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MathProblemTags
    **/
    _count?: true | MathProblemTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MathProblemTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MathProblemTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MathProblemTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MathProblemTagMaxAggregateInputType
  }

  export type GetMathProblemTagAggregateType<T extends MathProblemTagAggregateArgs> = {
        [P in keyof T & keyof AggregateMathProblemTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMathProblemTag[P]>
      : GetScalarType<T[P], AggregateMathProblemTag[P]>
  }




  export type MathProblemTagGroupByArgs = {
    where?: MathProblemTagWhereInput
    orderBy?: Enumerable<MathProblemTagOrderByWithAggregationInput>
    by: MathProblemTagScalarFieldEnum[]
    having?: MathProblemTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MathProblemTagCountAggregateInputType | true
    _avg?: MathProblemTagAvgAggregateInputType
    _sum?: MathProblemTagSumAggregateInputType
    _min?: MathProblemTagMinAggregateInputType
    _max?: MathProblemTagMaxAggregateInputType
  }


  export type MathProblemTagGroupByOutputType = {
    id: number
    name: string
    parentId: number | null
    nextSibling: number | null
    prevSibling: number | null
    _count: MathProblemTagCountAggregateOutputType | null
    _avg: MathProblemTagAvgAggregateOutputType | null
    _sum: MathProblemTagSumAggregateOutputType | null
    _min: MathProblemTagMinAggregateOutputType | null
    _max: MathProblemTagMaxAggregateOutputType | null
  }

  type GetMathProblemTagGroupByPayload<T extends MathProblemTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MathProblemTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MathProblemTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MathProblemTagGroupByOutputType[P]>
            : GetScalarType<T[P], MathProblemTagGroupByOutputType[P]>
        }
      >
    >


  export type MathProblemTagSelect = {
    id?: boolean
    name?: boolean
    parentId?: boolean
    nextSibling?: boolean
    prevSibling?: boolean
    mathProblems?: boolean | MathProblemTag$mathProblemsArgs
    _count?: boolean | MathProblemTagCountOutputTypeArgs
  }


  export type MathProblemTagInclude = {
    mathProblems?: boolean | MathProblemTag$mathProblemsArgs
    _count?: boolean | MathProblemTagCountOutputTypeArgs
  }

  export type MathProblemTagGetPayload<S extends boolean | null | undefined | MathProblemTagArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MathProblemTag :
    S extends undefined ? never :
    S extends { include: any } & (MathProblemTagArgs | MathProblemTagFindManyArgs)
    ? MathProblemTag  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'mathProblems' ? Array < TagMathProblemGetPayload<S['include'][P]>>  :
        P extends '_count' ? MathProblemTagCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MathProblemTagArgs | MathProblemTagFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'mathProblems' ? Array < TagMathProblemGetPayload<S['select'][P]>>  :
        P extends '_count' ? MathProblemTagCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof MathProblemTag ? MathProblemTag[P] : never
  } 
      : MathProblemTag


  type MathProblemTagCountArgs = 
    Omit<MathProblemTagFindManyArgs, 'select' | 'include'> & {
      select?: MathProblemTagCountAggregateInputType | true
    }

  export interface MathProblemTagDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MathProblemTag that matches the filter.
     * @param {MathProblemTagFindUniqueArgs} args - Arguments to find a MathProblemTag
     * @example
     * // Get one MathProblemTag
     * const mathProblemTag = await prisma.mathProblemTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MathProblemTagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MathProblemTagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MathProblemTag'> extends True ? Prisma__MathProblemTagClient<MathProblemTagGetPayload<T>> : Prisma__MathProblemTagClient<MathProblemTagGetPayload<T> | null, null>

    /**
     * Find one MathProblemTag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MathProblemTagFindUniqueOrThrowArgs} args - Arguments to find a MathProblemTag
     * @example
     * // Get one MathProblemTag
     * const mathProblemTag = await prisma.mathProblemTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MathProblemTagFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MathProblemTagFindUniqueOrThrowArgs>
    ): Prisma__MathProblemTagClient<MathProblemTagGetPayload<T>>

    /**
     * Find the first MathProblemTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathProblemTagFindFirstArgs} args - Arguments to find a MathProblemTag
     * @example
     * // Get one MathProblemTag
     * const mathProblemTag = await prisma.mathProblemTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MathProblemTagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MathProblemTagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MathProblemTag'> extends True ? Prisma__MathProblemTagClient<MathProblemTagGetPayload<T>> : Prisma__MathProblemTagClient<MathProblemTagGetPayload<T> | null, null>

    /**
     * Find the first MathProblemTag that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathProblemTagFindFirstOrThrowArgs} args - Arguments to find a MathProblemTag
     * @example
     * // Get one MathProblemTag
     * const mathProblemTag = await prisma.mathProblemTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MathProblemTagFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MathProblemTagFindFirstOrThrowArgs>
    ): Prisma__MathProblemTagClient<MathProblemTagGetPayload<T>>

    /**
     * Find zero or more MathProblemTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathProblemTagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MathProblemTags
     * const mathProblemTags = await prisma.mathProblemTag.findMany()
     * 
     * // Get first 10 MathProblemTags
     * const mathProblemTags = await prisma.mathProblemTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mathProblemTagWithIdOnly = await prisma.mathProblemTag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MathProblemTagFindManyArgs>(
      args?: SelectSubset<T, MathProblemTagFindManyArgs>
    ): Prisma.PrismaPromise<Array<MathProblemTagGetPayload<T>>>

    /**
     * Create a MathProblemTag.
     * @param {MathProblemTagCreateArgs} args - Arguments to create a MathProblemTag.
     * @example
     * // Create one MathProblemTag
     * const MathProblemTag = await prisma.mathProblemTag.create({
     *   data: {
     *     // ... data to create a MathProblemTag
     *   }
     * })
     * 
    **/
    create<T extends MathProblemTagCreateArgs>(
      args: SelectSubset<T, MathProblemTagCreateArgs>
    ): Prisma__MathProblemTagClient<MathProblemTagGetPayload<T>>

    /**
     * Create many MathProblemTags.
     *     @param {MathProblemTagCreateManyArgs} args - Arguments to create many MathProblemTags.
     *     @example
     *     // Create many MathProblemTags
     *     const mathProblemTag = await prisma.mathProblemTag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MathProblemTagCreateManyArgs>(
      args?: SelectSubset<T, MathProblemTagCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MathProblemTag.
     * @param {MathProblemTagDeleteArgs} args - Arguments to delete one MathProblemTag.
     * @example
     * // Delete one MathProblemTag
     * const MathProblemTag = await prisma.mathProblemTag.delete({
     *   where: {
     *     // ... filter to delete one MathProblemTag
     *   }
     * })
     * 
    **/
    delete<T extends MathProblemTagDeleteArgs>(
      args: SelectSubset<T, MathProblemTagDeleteArgs>
    ): Prisma__MathProblemTagClient<MathProblemTagGetPayload<T>>

    /**
     * Update one MathProblemTag.
     * @param {MathProblemTagUpdateArgs} args - Arguments to update one MathProblemTag.
     * @example
     * // Update one MathProblemTag
     * const mathProblemTag = await prisma.mathProblemTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MathProblemTagUpdateArgs>(
      args: SelectSubset<T, MathProblemTagUpdateArgs>
    ): Prisma__MathProblemTagClient<MathProblemTagGetPayload<T>>

    /**
     * Delete zero or more MathProblemTags.
     * @param {MathProblemTagDeleteManyArgs} args - Arguments to filter MathProblemTags to delete.
     * @example
     * // Delete a few MathProblemTags
     * const { count } = await prisma.mathProblemTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MathProblemTagDeleteManyArgs>(
      args?: SelectSubset<T, MathProblemTagDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MathProblemTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathProblemTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MathProblemTags
     * const mathProblemTag = await prisma.mathProblemTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MathProblemTagUpdateManyArgs>(
      args: SelectSubset<T, MathProblemTagUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MathProblemTag.
     * @param {MathProblemTagUpsertArgs} args - Arguments to update or create a MathProblemTag.
     * @example
     * // Update or create a MathProblemTag
     * const mathProblemTag = await prisma.mathProblemTag.upsert({
     *   create: {
     *     // ... data to create a MathProblemTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MathProblemTag we want to update
     *   }
     * })
    **/
    upsert<T extends MathProblemTagUpsertArgs>(
      args: SelectSubset<T, MathProblemTagUpsertArgs>
    ): Prisma__MathProblemTagClient<MathProblemTagGetPayload<T>>

    /**
     * Count the number of MathProblemTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathProblemTagCountArgs} args - Arguments to filter MathProblemTags to count.
     * @example
     * // Count the number of MathProblemTags
     * const count = await prisma.mathProblemTag.count({
     *   where: {
     *     // ... the filter for the MathProblemTags we want to count
     *   }
     * })
    **/
    count<T extends MathProblemTagCountArgs>(
      args?: Subset<T, MathProblemTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MathProblemTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MathProblemTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathProblemTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MathProblemTagAggregateArgs>(args: Subset<T, MathProblemTagAggregateArgs>): Prisma.PrismaPromise<GetMathProblemTagAggregateType<T>>

    /**
     * Group by MathProblemTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathProblemTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MathProblemTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MathProblemTagGroupByArgs['orderBy'] }
        : { orderBy?: MathProblemTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MathProblemTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMathProblemTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MathProblemTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MathProblemTagClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    mathProblems<T extends MathProblemTag$mathProblemsArgs= {}>(args?: Subset<T, MathProblemTag$mathProblemsArgs>): Prisma.PrismaPromise<Array<TagMathProblemGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MathProblemTag base type for findUnique actions
   */
  export type MathProblemTagFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MathProblemTag
     */
    select?: MathProblemTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemTagInclude | null
    /**
     * Filter, which MathProblemTag to fetch.
     */
    where: MathProblemTagWhereUniqueInput
  }

  /**
   * MathProblemTag findUnique
   */
  export interface MathProblemTagFindUniqueArgs extends MathProblemTagFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MathProblemTag findUniqueOrThrow
   */
  export type MathProblemTagFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MathProblemTag
     */
    select?: MathProblemTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemTagInclude | null
    /**
     * Filter, which MathProblemTag to fetch.
     */
    where: MathProblemTagWhereUniqueInput
  }


  /**
   * MathProblemTag base type for findFirst actions
   */
  export type MathProblemTagFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MathProblemTag
     */
    select?: MathProblemTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemTagInclude | null
    /**
     * Filter, which MathProblemTag to fetch.
     */
    where?: MathProblemTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MathProblemTags to fetch.
     */
    orderBy?: Enumerable<MathProblemTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MathProblemTags.
     */
    cursor?: MathProblemTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MathProblemTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MathProblemTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MathProblemTags.
     */
    distinct?: Enumerable<MathProblemTagScalarFieldEnum>
  }

  /**
   * MathProblemTag findFirst
   */
  export interface MathProblemTagFindFirstArgs extends MathProblemTagFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MathProblemTag findFirstOrThrow
   */
  export type MathProblemTagFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MathProblemTag
     */
    select?: MathProblemTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemTagInclude | null
    /**
     * Filter, which MathProblemTag to fetch.
     */
    where?: MathProblemTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MathProblemTags to fetch.
     */
    orderBy?: Enumerable<MathProblemTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MathProblemTags.
     */
    cursor?: MathProblemTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MathProblemTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MathProblemTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MathProblemTags.
     */
    distinct?: Enumerable<MathProblemTagScalarFieldEnum>
  }


  /**
   * MathProblemTag findMany
   */
  export type MathProblemTagFindManyArgs = {
    /**
     * Select specific fields to fetch from the MathProblemTag
     */
    select?: MathProblemTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemTagInclude | null
    /**
     * Filter, which MathProblemTags to fetch.
     */
    where?: MathProblemTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MathProblemTags to fetch.
     */
    orderBy?: Enumerable<MathProblemTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MathProblemTags.
     */
    cursor?: MathProblemTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MathProblemTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MathProblemTags.
     */
    skip?: number
    distinct?: Enumerable<MathProblemTagScalarFieldEnum>
  }


  /**
   * MathProblemTag create
   */
  export type MathProblemTagCreateArgs = {
    /**
     * Select specific fields to fetch from the MathProblemTag
     */
    select?: MathProblemTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemTagInclude | null
    /**
     * The data needed to create a MathProblemTag.
     */
    data: XOR<MathProblemTagCreateInput, MathProblemTagUncheckedCreateInput>
  }


  /**
   * MathProblemTag createMany
   */
  export type MathProblemTagCreateManyArgs = {
    /**
     * The data used to create many MathProblemTags.
     */
    data: Enumerable<MathProblemTagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MathProblemTag update
   */
  export type MathProblemTagUpdateArgs = {
    /**
     * Select specific fields to fetch from the MathProblemTag
     */
    select?: MathProblemTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemTagInclude | null
    /**
     * The data needed to update a MathProblemTag.
     */
    data: XOR<MathProblemTagUpdateInput, MathProblemTagUncheckedUpdateInput>
    /**
     * Choose, which MathProblemTag to update.
     */
    where: MathProblemTagWhereUniqueInput
  }


  /**
   * MathProblemTag updateMany
   */
  export type MathProblemTagUpdateManyArgs = {
    /**
     * The data used to update MathProblemTags.
     */
    data: XOR<MathProblemTagUpdateManyMutationInput, MathProblemTagUncheckedUpdateManyInput>
    /**
     * Filter which MathProblemTags to update
     */
    where?: MathProblemTagWhereInput
  }


  /**
   * MathProblemTag upsert
   */
  export type MathProblemTagUpsertArgs = {
    /**
     * Select specific fields to fetch from the MathProblemTag
     */
    select?: MathProblemTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemTagInclude | null
    /**
     * The filter to search for the MathProblemTag to update in case it exists.
     */
    where: MathProblemTagWhereUniqueInput
    /**
     * In case the MathProblemTag found by the `where` argument doesn't exist, create a new MathProblemTag with this data.
     */
    create: XOR<MathProblemTagCreateInput, MathProblemTagUncheckedCreateInput>
    /**
     * In case the MathProblemTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MathProblemTagUpdateInput, MathProblemTagUncheckedUpdateInput>
  }


  /**
   * MathProblemTag delete
   */
  export type MathProblemTagDeleteArgs = {
    /**
     * Select specific fields to fetch from the MathProblemTag
     */
    select?: MathProblemTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemTagInclude | null
    /**
     * Filter which MathProblemTag to delete.
     */
    where: MathProblemTagWhereUniqueInput
  }


  /**
   * MathProblemTag deleteMany
   */
  export type MathProblemTagDeleteManyArgs = {
    /**
     * Filter which MathProblemTags to delete
     */
    where?: MathProblemTagWhereInput
  }


  /**
   * MathProblemTag.mathProblems
   */
  export type MathProblemTag$mathProblemsArgs = {
    /**
     * Select specific fields to fetch from the TagMathProblem
     */
    select?: TagMathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagMathProblemInclude | null
    where?: TagMathProblemWhereInput
    orderBy?: Enumerable<TagMathProblemOrderByWithRelationInput>
    cursor?: TagMathProblemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TagMathProblemScalarFieldEnum>
  }


  /**
   * MathProblemTag without action
   */
  export type MathProblemTagArgs = {
    /**
     * Select specific fields to fetch from the MathProblemTag
     */
    select?: MathProblemTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemTagInclude | null
  }



  /**
   * Model MathProblem
   */


  export type AggregateMathProblem = {
    _count: MathProblemCountAggregateOutputType | null
    _avg: MathProblemAvgAggregateOutputType | null
    _sum: MathProblemSumAggregateOutputType | null
    _min: MathProblemMinAggregateOutputType | null
    _max: MathProblemMaxAggregateOutputType | null
  }

  export type MathProblemAvgAggregateOutputType = {
    categoryId: number | null
    difficulty: number | null
    practicePoint: number | null
    totalPoint: number | null
    numSolution: number | null
    numCheckedSolution: number | null
  }

  export type MathProblemSumAggregateOutputType = {
    categoryId: number | null
    difficulty: number | null
    practicePoint: number | null
    totalPoint: number | null
    numSolution: number | null
    numCheckedSolution: number | null
  }

  export type MathProblemMinAggregateOutputType = {
    id: string | null
    title: string | null
    categoryId: number | null
    link: string | null
    description: string | null
    hint: string | null
    difficulty: number | null
    practicePoint: number | null
    totalPoint: number | null
    prevProblems: string | null
    nextProblems: string | null
    numSolution: number | null
    numCheckedSolution: number | null
  }

  export type MathProblemMaxAggregateOutputType = {
    id: string | null
    title: string | null
    categoryId: number | null
    link: string | null
    description: string | null
    hint: string | null
    difficulty: number | null
    practicePoint: number | null
    totalPoint: number | null
    prevProblems: string | null
    nextProblems: string | null
    numSolution: number | null
    numCheckedSolution: number | null
  }

  export type MathProblemCountAggregateOutputType = {
    id: number
    title: number
    categoryId: number
    link: number
    description: number
    hint: number
    difficulty: number
    practicePoint: number
    totalPoint: number
    prevProblems: number
    nextProblems: number
    numSolution: number
    numCheckedSolution: number
    _all: number
  }


  export type MathProblemAvgAggregateInputType = {
    categoryId?: true
    difficulty?: true
    practicePoint?: true
    totalPoint?: true
    numSolution?: true
    numCheckedSolution?: true
  }

  export type MathProblemSumAggregateInputType = {
    categoryId?: true
    difficulty?: true
    practicePoint?: true
    totalPoint?: true
    numSolution?: true
    numCheckedSolution?: true
  }

  export type MathProblemMinAggregateInputType = {
    id?: true
    title?: true
    categoryId?: true
    link?: true
    description?: true
    hint?: true
    difficulty?: true
    practicePoint?: true
    totalPoint?: true
    prevProblems?: true
    nextProblems?: true
    numSolution?: true
    numCheckedSolution?: true
  }

  export type MathProblemMaxAggregateInputType = {
    id?: true
    title?: true
    categoryId?: true
    link?: true
    description?: true
    hint?: true
    difficulty?: true
    practicePoint?: true
    totalPoint?: true
    prevProblems?: true
    nextProblems?: true
    numSolution?: true
    numCheckedSolution?: true
  }

  export type MathProblemCountAggregateInputType = {
    id?: true
    title?: true
    categoryId?: true
    link?: true
    description?: true
    hint?: true
    difficulty?: true
    practicePoint?: true
    totalPoint?: true
    prevProblems?: true
    nextProblems?: true
    numSolution?: true
    numCheckedSolution?: true
    _all?: true
  }

  export type MathProblemAggregateArgs = {
    /**
     * Filter which MathProblem to aggregate.
     */
    where?: MathProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MathProblems to fetch.
     */
    orderBy?: Enumerable<MathProblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MathProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MathProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MathProblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MathProblems
    **/
    _count?: true | MathProblemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MathProblemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MathProblemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MathProblemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MathProblemMaxAggregateInputType
  }

  export type GetMathProblemAggregateType<T extends MathProblemAggregateArgs> = {
        [P in keyof T & keyof AggregateMathProblem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMathProblem[P]>
      : GetScalarType<T[P], AggregateMathProblem[P]>
  }




  export type MathProblemGroupByArgs = {
    where?: MathProblemWhereInput
    orderBy?: Enumerable<MathProblemOrderByWithAggregationInput>
    by: MathProblemScalarFieldEnum[]
    having?: MathProblemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MathProblemCountAggregateInputType | true
    _avg?: MathProblemAvgAggregateInputType
    _sum?: MathProblemSumAggregateInputType
    _min?: MathProblemMinAggregateInputType
    _max?: MathProblemMaxAggregateInputType
  }


  export type MathProblemGroupByOutputType = {
    id: string
    title: string
    categoryId: number
    link: string | null
    description: string | null
    hint: string | null
    difficulty: number
    practicePoint: number | null
    totalPoint: number | null
    prevProblems: string | null
    nextProblems: string | null
    numSolution: number
    numCheckedSolution: number
    _count: MathProblemCountAggregateOutputType | null
    _avg: MathProblemAvgAggregateOutputType | null
    _sum: MathProblemSumAggregateOutputType | null
    _min: MathProblemMinAggregateOutputType | null
    _max: MathProblemMaxAggregateOutputType | null
  }

  type GetMathProblemGroupByPayload<T extends MathProblemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MathProblemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MathProblemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MathProblemGroupByOutputType[P]>
            : GetScalarType<T[P], MathProblemGroupByOutputType[P]>
        }
      >
    >


  export type MathProblemSelect = {
    id?: boolean
    title?: boolean
    categoryId?: boolean
    link?: boolean
    description?: boolean
    hint?: boolean
    difficulty?: boolean
    practicePoint?: boolean
    totalPoint?: boolean
    prevProblems?: boolean
    nextProblems?: boolean
    numSolution?: boolean
    numCheckedSolution?: boolean
    category?: boolean | MathProblemCategoryArgs
    authors?: boolean | MathProblem$authorsArgs
    tags?: boolean | MathProblem$tagsArgs
    mathNotes?: boolean | MathProblem$mathNotesArgs
    mathSolutions?: boolean | MathProblem$mathSolutionsArgs
    problemSet?: boolean | MathProblem$problemSetArgs
    _count?: boolean | MathProblemCountOutputTypeArgs
  }


  export type MathProblemInclude = {
    category?: boolean | MathProblemCategoryArgs
    authors?: boolean | MathProblem$authorsArgs
    tags?: boolean | MathProblem$tagsArgs
    mathNotes?: boolean | MathProblem$mathNotesArgs
    mathSolutions?: boolean | MathProblem$mathSolutionsArgs
    problemSet?: boolean | MathProblem$problemSetArgs
    _count?: boolean | MathProblemCountOutputTypeArgs
  }

  export type MathProblemGetPayload<S extends boolean | null | undefined | MathProblemArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MathProblem :
    S extends undefined ? never :
    S extends { include: any } & (MathProblemArgs | MathProblemFindManyArgs)
    ? MathProblem  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'category' ? MathProblemCategoryGetPayload<S['include'][P]> :
        P extends 'authors' ? Array < AuthorMathProblemGetPayload<S['include'][P]>>  :
        P extends 'tags' ? Array < TagMathProblemGetPayload<S['include'][P]>>  :
        P extends 'mathNotes' ? Array < MathNoteGetPayload<S['include'][P]>>  :
        P extends 'mathSolutions' ? Array < MathSolutionGetPayload<S['include'][P]>>  :
        P extends 'problemSet' ? Array < MathSetProbRelGetPayload<S['include'][P]>>  :
        P extends '_count' ? MathProblemCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MathProblemArgs | MathProblemFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'category' ? MathProblemCategoryGetPayload<S['select'][P]> :
        P extends 'authors' ? Array < AuthorMathProblemGetPayload<S['select'][P]>>  :
        P extends 'tags' ? Array < TagMathProblemGetPayload<S['select'][P]>>  :
        P extends 'mathNotes' ? Array < MathNoteGetPayload<S['select'][P]>>  :
        P extends 'mathSolutions' ? Array < MathSolutionGetPayload<S['select'][P]>>  :
        P extends 'problemSet' ? Array < MathSetProbRelGetPayload<S['select'][P]>>  :
        P extends '_count' ? MathProblemCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof MathProblem ? MathProblem[P] : never
  } 
      : MathProblem


  type MathProblemCountArgs = 
    Omit<MathProblemFindManyArgs, 'select' | 'include'> & {
      select?: MathProblemCountAggregateInputType | true
    }

  export interface MathProblemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MathProblem that matches the filter.
     * @param {MathProblemFindUniqueArgs} args - Arguments to find a MathProblem
     * @example
     * // Get one MathProblem
     * const mathProblem = await prisma.mathProblem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MathProblemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MathProblemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MathProblem'> extends True ? Prisma__MathProblemClient<MathProblemGetPayload<T>> : Prisma__MathProblemClient<MathProblemGetPayload<T> | null, null>

    /**
     * Find one MathProblem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MathProblemFindUniqueOrThrowArgs} args - Arguments to find a MathProblem
     * @example
     * // Get one MathProblem
     * const mathProblem = await prisma.mathProblem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MathProblemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MathProblemFindUniqueOrThrowArgs>
    ): Prisma__MathProblemClient<MathProblemGetPayload<T>>

    /**
     * Find the first MathProblem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathProblemFindFirstArgs} args - Arguments to find a MathProblem
     * @example
     * // Get one MathProblem
     * const mathProblem = await prisma.mathProblem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MathProblemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MathProblemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MathProblem'> extends True ? Prisma__MathProblemClient<MathProblemGetPayload<T>> : Prisma__MathProblemClient<MathProblemGetPayload<T> | null, null>

    /**
     * Find the first MathProblem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathProblemFindFirstOrThrowArgs} args - Arguments to find a MathProblem
     * @example
     * // Get one MathProblem
     * const mathProblem = await prisma.mathProblem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MathProblemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MathProblemFindFirstOrThrowArgs>
    ): Prisma__MathProblemClient<MathProblemGetPayload<T>>

    /**
     * Find zero or more MathProblems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathProblemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MathProblems
     * const mathProblems = await prisma.mathProblem.findMany()
     * 
     * // Get first 10 MathProblems
     * const mathProblems = await prisma.mathProblem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mathProblemWithIdOnly = await prisma.mathProblem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MathProblemFindManyArgs>(
      args?: SelectSubset<T, MathProblemFindManyArgs>
    ): Prisma.PrismaPromise<Array<MathProblemGetPayload<T>>>

    /**
     * Create a MathProblem.
     * @param {MathProblemCreateArgs} args - Arguments to create a MathProblem.
     * @example
     * // Create one MathProblem
     * const MathProblem = await prisma.mathProblem.create({
     *   data: {
     *     // ... data to create a MathProblem
     *   }
     * })
     * 
    **/
    create<T extends MathProblemCreateArgs>(
      args: SelectSubset<T, MathProblemCreateArgs>
    ): Prisma__MathProblemClient<MathProblemGetPayload<T>>

    /**
     * Create many MathProblems.
     *     @param {MathProblemCreateManyArgs} args - Arguments to create many MathProblems.
     *     @example
     *     // Create many MathProblems
     *     const mathProblem = await prisma.mathProblem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MathProblemCreateManyArgs>(
      args?: SelectSubset<T, MathProblemCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MathProblem.
     * @param {MathProblemDeleteArgs} args - Arguments to delete one MathProblem.
     * @example
     * // Delete one MathProblem
     * const MathProblem = await prisma.mathProblem.delete({
     *   where: {
     *     // ... filter to delete one MathProblem
     *   }
     * })
     * 
    **/
    delete<T extends MathProblemDeleteArgs>(
      args: SelectSubset<T, MathProblemDeleteArgs>
    ): Prisma__MathProblemClient<MathProblemGetPayload<T>>

    /**
     * Update one MathProblem.
     * @param {MathProblemUpdateArgs} args - Arguments to update one MathProblem.
     * @example
     * // Update one MathProblem
     * const mathProblem = await prisma.mathProblem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MathProblemUpdateArgs>(
      args: SelectSubset<T, MathProblemUpdateArgs>
    ): Prisma__MathProblemClient<MathProblemGetPayload<T>>

    /**
     * Delete zero or more MathProblems.
     * @param {MathProblemDeleteManyArgs} args - Arguments to filter MathProblems to delete.
     * @example
     * // Delete a few MathProblems
     * const { count } = await prisma.mathProblem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MathProblemDeleteManyArgs>(
      args?: SelectSubset<T, MathProblemDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MathProblems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathProblemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MathProblems
     * const mathProblem = await prisma.mathProblem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MathProblemUpdateManyArgs>(
      args: SelectSubset<T, MathProblemUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MathProblem.
     * @param {MathProblemUpsertArgs} args - Arguments to update or create a MathProblem.
     * @example
     * // Update or create a MathProblem
     * const mathProblem = await prisma.mathProblem.upsert({
     *   create: {
     *     // ... data to create a MathProblem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MathProblem we want to update
     *   }
     * })
    **/
    upsert<T extends MathProblemUpsertArgs>(
      args: SelectSubset<T, MathProblemUpsertArgs>
    ): Prisma__MathProblemClient<MathProblemGetPayload<T>>

    /**
     * Count the number of MathProblems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathProblemCountArgs} args - Arguments to filter MathProblems to count.
     * @example
     * // Count the number of MathProblems
     * const count = await prisma.mathProblem.count({
     *   where: {
     *     // ... the filter for the MathProblems we want to count
     *   }
     * })
    **/
    count<T extends MathProblemCountArgs>(
      args?: Subset<T, MathProblemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MathProblemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MathProblem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathProblemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MathProblemAggregateArgs>(args: Subset<T, MathProblemAggregateArgs>): Prisma.PrismaPromise<GetMathProblemAggregateType<T>>

    /**
     * Group by MathProblem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathProblemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MathProblemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MathProblemGroupByArgs['orderBy'] }
        : { orderBy?: MathProblemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MathProblemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMathProblemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MathProblem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MathProblemClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    category<T extends MathProblemCategoryArgs= {}>(args?: Subset<T, MathProblemCategoryArgs>): Prisma__MathProblemCategoryClient<MathProblemCategoryGetPayload<T> | Null>;

    authors<T extends MathProblem$authorsArgs= {}>(args?: Subset<T, MathProblem$authorsArgs>): Prisma.PrismaPromise<Array<AuthorMathProblemGetPayload<T>>| Null>;

    tags<T extends MathProblem$tagsArgs= {}>(args?: Subset<T, MathProblem$tagsArgs>): Prisma.PrismaPromise<Array<TagMathProblemGetPayload<T>>| Null>;

    mathNotes<T extends MathProblem$mathNotesArgs= {}>(args?: Subset<T, MathProblem$mathNotesArgs>): Prisma.PrismaPromise<Array<MathNoteGetPayload<T>>| Null>;

    mathSolutions<T extends MathProblem$mathSolutionsArgs= {}>(args?: Subset<T, MathProblem$mathSolutionsArgs>): Prisma.PrismaPromise<Array<MathSolutionGetPayload<T>>| Null>;

    problemSet<T extends MathProblem$problemSetArgs= {}>(args?: Subset<T, MathProblem$problemSetArgs>): Prisma.PrismaPromise<Array<MathSetProbRelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MathProblem base type for findUnique actions
   */
  export type MathProblemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MathProblem
     */
    select?: MathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemInclude | null
    /**
     * Filter, which MathProblem to fetch.
     */
    where: MathProblemWhereUniqueInput
  }

  /**
   * MathProblem findUnique
   */
  export interface MathProblemFindUniqueArgs extends MathProblemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MathProblem findUniqueOrThrow
   */
  export type MathProblemFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MathProblem
     */
    select?: MathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemInclude | null
    /**
     * Filter, which MathProblem to fetch.
     */
    where: MathProblemWhereUniqueInput
  }


  /**
   * MathProblem base type for findFirst actions
   */
  export type MathProblemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MathProblem
     */
    select?: MathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemInclude | null
    /**
     * Filter, which MathProblem to fetch.
     */
    where?: MathProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MathProblems to fetch.
     */
    orderBy?: Enumerable<MathProblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MathProblems.
     */
    cursor?: MathProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MathProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MathProblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MathProblems.
     */
    distinct?: Enumerable<MathProblemScalarFieldEnum>
  }

  /**
   * MathProblem findFirst
   */
  export interface MathProblemFindFirstArgs extends MathProblemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MathProblem findFirstOrThrow
   */
  export type MathProblemFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MathProblem
     */
    select?: MathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemInclude | null
    /**
     * Filter, which MathProblem to fetch.
     */
    where?: MathProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MathProblems to fetch.
     */
    orderBy?: Enumerable<MathProblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MathProblems.
     */
    cursor?: MathProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MathProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MathProblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MathProblems.
     */
    distinct?: Enumerable<MathProblemScalarFieldEnum>
  }


  /**
   * MathProblem findMany
   */
  export type MathProblemFindManyArgs = {
    /**
     * Select specific fields to fetch from the MathProblem
     */
    select?: MathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemInclude | null
    /**
     * Filter, which MathProblems to fetch.
     */
    where?: MathProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MathProblems to fetch.
     */
    orderBy?: Enumerable<MathProblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MathProblems.
     */
    cursor?: MathProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MathProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MathProblems.
     */
    skip?: number
    distinct?: Enumerable<MathProblemScalarFieldEnum>
  }


  /**
   * MathProblem create
   */
  export type MathProblemCreateArgs = {
    /**
     * Select specific fields to fetch from the MathProblem
     */
    select?: MathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemInclude | null
    /**
     * The data needed to create a MathProblem.
     */
    data: XOR<MathProblemCreateInput, MathProblemUncheckedCreateInput>
  }


  /**
   * MathProblem createMany
   */
  export type MathProblemCreateManyArgs = {
    /**
     * The data used to create many MathProblems.
     */
    data: Enumerable<MathProblemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MathProblem update
   */
  export type MathProblemUpdateArgs = {
    /**
     * Select specific fields to fetch from the MathProblem
     */
    select?: MathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemInclude | null
    /**
     * The data needed to update a MathProblem.
     */
    data: XOR<MathProblemUpdateInput, MathProblemUncheckedUpdateInput>
    /**
     * Choose, which MathProblem to update.
     */
    where: MathProblemWhereUniqueInput
  }


  /**
   * MathProblem updateMany
   */
  export type MathProblemUpdateManyArgs = {
    /**
     * The data used to update MathProblems.
     */
    data: XOR<MathProblemUpdateManyMutationInput, MathProblemUncheckedUpdateManyInput>
    /**
     * Filter which MathProblems to update
     */
    where?: MathProblemWhereInput
  }


  /**
   * MathProblem upsert
   */
  export type MathProblemUpsertArgs = {
    /**
     * Select specific fields to fetch from the MathProblem
     */
    select?: MathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemInclude | null
    /**
     * The filter to search for the MathProblem to update in case it exists.
     */
    where: MathProblemWhereUniqueInput
    /**
     * In case the MathProblem found by the `where` argument doesn't exist, create a new MathProblem with this data.
     */
    create: XOR<MathProblemCreateInput, MathProblemUncheckedCreateInput>
    /**
     * In case the MathProblem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MathProblemUpdateInput, MathProblemUncheckedUpdateInput>
  }


  /**
   * MathProblem delete
   */
  export type MathProblemDeleteArgs = {
    /**
     * Select specific fields to fetch from the MathProblem
     */
    select?: MathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemInclude | null
    /**
     * Filter which MathProblem to delete.
     */
    where: MathProblemWhereUniqueInput
  }


  /**
   * MathProblem deleteMany
   */
  export type MathProblemDeleteManyArgs = {
    /**
     * Filter which MathProblems to delete
     */
    where?: MathProblemWhereInput
  }


  /**
   * MathProblem.authors
   */
  export type MathProblem$authorsArgs = {
    /**
     * Select specific fields to fetch from the AuthorMathProblem
     */
    select?: AuthorMathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorMathProblemInclude | null
    where?: AuthorMathProblemWhereInput
    orderBy?: Enumerable<AuthorMathProblemOrderByWithRelationInput>
    cursor?: AuthorMathProblemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AuthorMathProblemScalarFieldEnum>
  }


  /**
   * MathProblem.tags
   */
  export type MathProblem$tagsArgs = {
    /**
     * Select specific fields to fetch from the TagMathProblem
     */
    select?: TagMathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagMathProblemInclude | null
    where?: TagMathProblemWhereInput
    orderBy?: Enumerable<TagMathProblemOrderByWithRelationInput>
    cursor?: TagMathProblemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TagMathProblemScalarFieldEnum>
  }


  /**
   * MathProblem.mathNotes
   */
  export type MathProblem$mathNotesArgs = {
    /**
     * Select specific fields to fetch from the MathNote
     */
    select?: MathNoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathNoteInclude | null
    where?: MathNoteWhereInput
    orderBy?: Enumerable<MathNoteOrderByWithRelationInput>
    cursor?: MathNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MathNoteScalarFieldEnum>
  }


  /**
   * MathProblem.mathSolutions
   */
  export type MathProblem$mathSolutionsArgs = {
    /**
     * Select specific fields to fetch from the MathSolution
     */
    select?: MathSolutionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathSolutionInclude | null
    where?: MathSolutionWhereInput
    orderBy?: Enumerable<MathSolutionOrderByWithRelationInput>
    cursor?: MathSolutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MathSolutionScalarFieldEnum>
  }


  /**
   * MathProblem.problemSet
   */
  export type MathProblem$problemSetArgs = {
    /**
     * Select specific fields to fetch from the MathSetProbRel
     */
    select?: MathSetProbRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathSetProbRelInclude | null
    where?: MathSetProbRelWhereInput
    orderBy?: Enumerable<MathSetProbRelOrderByWithRelationInput>
    cursor?: MathSetProbRelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MathSetProbRelScalarFieldEnum>
  }


  /**
   * MathProblem without action
   */
  export type MathProblemArgs = {
    /**
     * Select specific fields to fetch from the MathProblem
     */
    select?: MathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemInclude | null
  }



  /**
   * Model MathProblemSet
   */


  export type AggregateMathProblemSet = {
    _count: MathProblemSetCountAggregateOutputType | null
    _avg: MathProblemSetAvgAggregateOutputType | null
    _sum: MathProblemSetSumAggregateOutputType | null
    _min: MathProblemSetMinAggregateOutputType | null
    _max: MathProblemSetMaxAggregateOutputType | null
  }

  export type MathProblemSetAvgAggregateOutputType = {
    numberProb: number | null
  }

  export type MathProblemSetSumAggregateOutputType = {
    numberProb: number | null
  }

  export type MathProblemSetMinAggregateOutputType = {
    id: string | null
    title: string | null
    creatorId: string | null
    numberProb: number | null
  }

  export type MathProblemSetMaxAggregateOutputType = {
    id: string | null
    title: string | null
    creatorId: string | null
    numberProb: number | null
  }

  export type MathProblemSetCountAggregateOutputType = {
    id: number
    title: number
    creatorId: number
    numberProb: number
    _all: number
  }


  export type MathProblemSetAvgAggregateInputType = {
    numberProb?: true
  }

  export type MathProblemSetSumAggregateInputType = {
    numberProb?: true
  }

  export type MathProblemSetMinAggregateInputType = {
    id?: true
    title?: true
    creatorId?: true
    numberProb?: true
  }

  export type MathProblemSetMaxAggregateInputType = {
    id?: true
    title?: true
    creatorId?: true
    numberProb?: true
  }

  export type MathProblemSetCountAggregateInputType = {
    id?: true
    title?: true
    creatorId?: true
    numberProb?: true
    _all?: true
  }

  export type MathProblemSetAggregateArgs = {
    /**
     * Filter which MathProblemSet to aggregate.
     */
    where?: MathProblemSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MathProblemSets to fetch.
     */
    orderBy?: Enumerable<MathProblemSetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MathProblemSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MathProblemSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MathProblemSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MathProblemSets
    **/
    _count?: true | MathProblemSetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MathProblemSetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MathProblemSetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MathProblemSetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MathProblemSetMaxAggregateInputType
  }

  export type GetMathProblemSetAggregateType<T extends MathProblemSetAggregateArgs> = {
        [P in keyof T & keyof AggregateMathProblemSet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMathProblemSet[P]>
      : GetScalarType<T[P], AggregateMathProblemSet[P]>
  }




  export type MathProblemSetGroupByArgs = {
    where?: MathProblemSetWhereInput
    orderBy?: Enumerable<MathProblemSetOrderByWithAggregationInput>
    by: MathProblemSetScalarFieldEnum[]
    having?: MathProblemSetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MathProblemSetCountAggregateInputType | true
    _avg?: MathProblemSetAvgAggregateInputType
    _sum?: MathProblemSetSumAggregateInputType
    _min?: MathProblemSetMinAggregateInputType
    _max?: MathProblemSetMaxAggregateInputType
  }


  export type MathProblemSetGroupByOutputType = {
    id: string
    title: string
    creatorId: string
    numberProb: number
    _count: MathProblemSetCountAggregateOutputType | null
    _avg: MathProblemSetAvgAggregateOutputType | null
    _sum: MathProblemSetSumAggregateOutputType | null
    _min: MathProblemSetMinAggregateOutputType | null
    _max: MathProblemSetMaxAggregateOutputType | null
  }

  type GetMathProblemSetGroupByPayload<T extends MathProblemSetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MathProblemSetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MathProblemSetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MathProblemSetGroupByOutputType[P]>
            : GetScalarType<T[P], MathProblemSetGroupByOutputType[P]>
        }
      >
    >


  export type MathProblemSetSelect = {
    id?: boolean
    title?: boolean
    creatorId?: boolean
    numberProb?: boolean
    creator?: boolean | UserArgs
    problems?: boolean | MathProblemSet$problemsArgs
    _count?: boolean | MathProblemSetCountOutputTypeArgs
  }


  export type MathProblemSetInclude = {
    creator?: boolean | UserArgs
    problems?: boolean | MathProblemSet$problemsArgs
    _count?: boolean | MathProblemSetCountOutputTypeArgs
  }

  export type MathProblemSetGetPayload<S extends boolean | null | undefined | MathProblemSetArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MathProblemSet :
    S extends undefined ? never :
    S extends { include: any } & (MathProblemSetArgs | MathProblemSetFindManyArgs)
    ? MathProblemSet  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'creator' ? UserGetPayload<S['include'][P]> :
        P extends 'problems' ? Array < MathSetProbRelGetPayload<S['include'][P]>>  :
        P extends '_count' ? MathProblemSetCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MathProblemSetArgs | MathProblemSetFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'creator' ? UserGetPayload<S['select'][P]> :
        P extends 'problems' ? Array < MathSetProbRelGetPayload<S['select'][P]>>  :
        P extends '_count' ? MathProblemSetCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof MathProblemSet ? MathProblemSet[P] : never
  } 
      : MathProblemSet


  type MathProblemSetCountArgs = 
    Omit<MathProblemSetFindManyArgs, 'select' | 'include'> & {
      select?: MathProblemSetCountAggregateInputType | true
    }

  export interface MathProblemSetDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MathProblemSet that matches the filter.
     * @param {MathProblemSetFindUniqueArgs} args - Arguments to find a MathProblemSet
     * @example
     * // Get one MathProblemSet
     * const mathProblemSet = await prisma.mathProblemSet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MathProblemSetFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MathProblemSetFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MathProblemSet'> extends True ? Prisma__MathProblemSetClient<MathProblemSetGetPayload<T>> : Prisma__MathProblemSetClient<MathProblemSetGetPayload<T> | null, null>

    /**
     * Find one MathProblemSet that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MathProblemSetFindUniqueOrThrowArgs} args - Arguments to find a MathProblemSet
     * @example
     * // Get one MathProblemSet
     * const mathProblemSet = await prisma.mathProblemSet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MathProblemSetFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MathProblemSetFindUniqueOrThrowArgs>
    ): Prisma__MathProblemSetClient<MathProblemSetGetPayload<T>>

    /**
     * Find the first MathProblemSet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathProblemSetFindFirstArgs} args - Arguments to find a MathProblemSet
     * @example
     * // Get one MathProblemSet
     * const mathProblemSet = await prisma.mathProblemSet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MathProblemSetFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MathProblemSetFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MathProblemSet'> extends True ? Prisma__MathProblemSetClient<MathProblemSetGetPayload<T>> : Prisma__MathProblemSetClient<MathProblemSetGetPayload<T> | null, null>

    /**
     * Find the first MathProblemSet that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathProblemSetFindFirstOrThrowArgs} args - Arguments to find a MathProblemSet
     * @example
     * // Get one MathProblemSet
     * const mathProblemSet = await prisma.mathProblemSet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MathProblemSetFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MathProblemSetFindFirstOrThrowArgs>
    ): Prisma__MathProblemSetClient<MathProblemSetGetPayload<T>>

    /**
     * Find zero or more MathProblemSets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathProblemSetFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MathProblemSets
     * const mathProblemSets = await prisma.mathProblemSet.findMany()
     * 
     * // Get first 10 MathProblemSets
     * const mathProblemSets = await prisma.mathProblemSet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mathProblemSetWithIdOnly = await prisma.mathProblemSet.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MathProblemSetFindManyArgs>(
      args?: SelectSubset<T, MathProblemSetFindManyArgs>
    ): Prisma.PrismaPromise<Array<MathProblemSetGetPayload<T>>>

    /**
     * Create a MathProblemSet.
     * @param {MathProblemSetCreateArgs} args - Arguments to create a MathProblemSet.
     * @example
     * // Create one MathProblemSet
     * const MathProblemSet = await prisma.mathProblemSet.create({
     *   data: {
     *     // ... data to create a MathProblemSet
     *   }
     * })
     * 
    **/
    create<T extends MathProblemSetCreateArgs>(
      args: SelectSubset<T, MathProblemSetCreateArgs>
    ): Prisma__MathProblemSetClient<MathProblemSetGetPayload<T>>

    /**
     * Create many MathProblemSets.
     *     @param {MathProblemSetCreateManyArgs} args - Arguments to create many MathProblemSets.
     *     @example
     *     // Create many MathProblemSets
     *     const mathProblemSet = await prisma.mathProblemSet.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MathProblemSetCreateManyArgs>(
      args?: SelectSubset<T, MathProblemSetCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MathProblemSet.
     * @param {MathProblemSetDeleteArgs} args - Arguments to delete one MathProblemSet.
     * @example
     * // Delete one MathProblemSet
     * const MathProblemSet = await prisma.mathProblemSet.delete({
     *   where: {
     *     // ... filter to delete one MathProblemSet
     *   }
     * })
     * 
    **/
    delete<T extends MathProblemSetDeleteArgs>(
      args: SelectSubset<T, MathProblemSetDeleteArgs>
    ): Prisma__MathProblemSetClient<MathProblemSetGetPayload<T>>

    /**
     * Update one MathProblemSet.
     * @param {MathProblemSetUpdateArgs} args - Arguments to update one MathProblemSet.
     * @example
     * // Update one MathProblemSet
     * const mathProblemSet = await prisma.mathProblemSet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MathProblemSetUpdateArgs>(
      args: SelectSubset<T, MathProblemSetUpdateArgs>
    ): Prisma__MathProblemSetClient<MathProblemSetGetPayload<T>>

    /**
     * Delete zero or more MathProblemSets.
     * @param {MathProblemSetDeleteManyArgs} args - Arguments to filter MathProblemSets to delete.
     * @example
     * // Delete a few MathProblemSets
     * const { count } = await prisma.mathProblemSet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MathProblemSetDeleteManyArgs>(
      args?: SelectSubset<T, MathProblemSetDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MathProblemSets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathProblemSetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MathProblemSets
     * const mathProblemSet = await prisma.mathProblemSet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MathProblemSetUpdateManyArgs>(
      args: SelectSubset<T, MathProblemSetUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MathProblemSet.
     * @param {MathProblemSetUpsertArgs} args - Arguments to update or create a MathProblemSet.
     * @example
     * // Update or create a MathProblemSet
     * const mathProblemSet = await prisma.mathProblemSet.upsert({
     *   create: {
     *     // ... data to create a MathProblemSet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MathProblemSet we want to update
     *   }
     * })
    **/
    upsert<T extends MathProblemSetUpsertArgs>(
      args: SelectSubset<T, MathProblemSetUpsertArgs>
    ): Prisma__MathProblemSetClient<MathProblemSetGetPayload<T>>

    /**
     * Count the number of MathProblemSets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathProblemSetCountArgs} args - Arguments to filter MathProblemSets to count.
     * @example
     * // Count the number of MathProblemSets
     * const count = await prisma.mathProblemSet.count({
     *   where: {
     *     // ... the filter for the MathProblemSets we want to count
     *   }
     * })
    **/
    count<T extends MathProblemSetCountArgs>(
      args?: Subset<T, MathProblemSetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MathProblemSetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MathProblemSet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathProblemSetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MathProblemSetAggregateArgs>(args: Subset<T, MathProblemSetAggregateArgs>): Prisma.PrismaPromise<GetMathProblemSetAggregateType<T>>

    /**
     * Group by MathProblemSet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathProblemSetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MathProblemSetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MathProblemSetGroupByArgs['orderBy'] }
        : { orderBy?: MathProblemSetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MathProblemSetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMathProblemSetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MathProblemSet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MathProblemSetClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    creator<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    problems<T extends MathProblemSet$problemsArgs= {}>(args?: Subset<T, MathProblemSet$problemsArgs>): Prisma.PrismaPromise<Array<MathSetProbRelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MathProblemSet base type for findUnique actions
   */
  export type MathProblemSetFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MathProblemSet
     */
    select?: MathProblemSetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemSetInclude | null
    /**
     * Filter, which MathProblemSet to fetch.
     */
    where: MathProblemSetWhereUniqueInput
  }

  /**
   * MathProblemSet findUnique
   */
  export interface MathProblemSetFindUniqueArgs extends MathProblemSetFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MathProblemSet findUniqueOrThrow
   */
  export type MathProblemSetFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MathProblemSet
     */
    select?: MathProblemSetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemSetInclude | null
    /**
     * Filter, which MathProblemSet to fetch.
     */
    where: MathProblemSetWhereUniqueInput
  }


  /**
   * MathProblemSet base type for findFirst actions
   */
  export type MathProblemSetFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MathProblemSet
     */
    select?: MathProblemSetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemSetInclude | null
    /**
     * Filter, which MathProblemSet to fetch.
     */
    where?: MathProblemSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MathProblemSets to fetch.
     */
    orderBy?: Enumerable<MathProblemSetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MathProblemSets.
     */
    cursor?: MathProblemSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MathProblemSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MathProblemSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MathProblemSets.
     */
    distinct?: Enumerable<MathProblemSetScalarFieldEnum>
  }

  /**
   * MathProblemSet findFirst
   */
  export interface MathProblemSetFindFirstArgs extends MathProblemSetFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MathProblemSet findFirstOrThrow
   */
  export type MathProblemSetFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MathProblemSet
     */
    select?: MathProblemSetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemSetInclude | null
    /**
     * Filter, which MathProblemSet to fetch.
     */
    where?: MathProblemSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MathProblemSets to fetch.
     */
    orderBy?: Enumerable<MathProblemSetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MathProblemSets.
     */
    cursor?: MathProblemSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MathProblemSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MathProblemSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MathProblemSets.
     */
    distinct?: Enumerable<MathProblemSetScalarFieldEnum>
  }


  /**
   * MathProblemSet findMany
   */
  export type MathProblemSetFindManyArgs = {
    /**
     * Select specific fields to fetch from the MathProblemSet
     */
    select?: MathProblemSetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemSetInclude | null
    /**
     * Filter, which MathProblemSets to fetch.
     */
    where?: MathProblemSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MathProblemSets to fetch.
     */
    orderBy?: Enumerable<MathProblemSetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MathProblemSets.
     */
    cursor?: MathProblemSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MathProblemSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MathProblemSets.
     */
    skip?: number
    distinct?: Enumerable<MathProblemSetScalarFieldEnum>
  }


  /**
   * MathProblemSet create
   */
  export type MathProblemSetCreateArgs = {
    /**
     * Select specific fields to fetch from the MathProblemSet
     */
    select?: MathProblemSetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemSetInclude | null
    /**
     * The data needed to create a MathProblemSet.
     */
    data: XOR<MathProblemSetCreateInput, MathProblemSetUncheckedCreateInput>
  }


  /**
   * MathProblemSet createMany
   */
  export type MathProblemSetCreateManyArgs = {
    /**
     * The data used to create many MathProblemSets.
     */
    data: Enumerable<MathProblemSetCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MathProblemSet update
   */
  export type MathProblemSetUpdateArgs = {
    /**
     * Select specific fields to fetch from the MathProblemSet
     */
    select?: MathProblemSetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemSetInclude | null
    /**
     * The data needed to update a MathProblemSet.
     */
    data: XOR<MathProblemSetUpdateInput, MathProblemSetUncheckedUpdateInput>
    /**
     * Choose, which MathProblemSet to update.
     */
    where: MathProblemSetWhereUniqueInput
  }


  /**
   * MathProblemSet updateMany
   */
  export type MathProblemSetUpdateManyArgs = {
    /**
     * The data used to update MathProblemSets.
     */
    data: XOR<MathProblemSetUpdateManyMutationInput, MathProblemSetUncheckedUpdateManyInput>
    /**
     * Filter which MathProblemSets to update
     */
    where?: MathProblemSetWhereInput
  }


  /**
   * MathProblemSet upsert
   */
  export type MathProblemSetUpsertArgs = {
    /**
     * Select specific fields to fetch from the MathProblemSet
     */
    select?: MathProblemSetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemSetInclude | null
    /**
     * The filter to search for the MathProblemSet to update in case it exists.
     */
    where: MathProblemSetWhereUniqueInput
    /**
     * In case the MathProblemSet found by the `where` argument doesn't exist, create a new MathProblemSet with this data.
     */
    create: XOR<MathProblemSetCreateInput, MathProblemSetUncheckedCreateInput>
    /**
     * In case the MathProblemSet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MathProblemSetUpdateInput, MathProblemSetUncheckedUpdateInput>
  }


  /**
   * MathProblemSet delete
   */
  export type MathProblemSetDeleteArgs = {
    /**
     * Select specific fields to fetch from the MathProblemSet
     */
    select?: MathProblemSetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemSetInclude | null
    /**
     * Filter which MathProblemSet to delete.
     */
    where: MathProblemSetWhereUniqueInput
  }


  /**
   * MathProblemSet deleteMany
   */
  export type MathProblemSetDeleteManyArgs = {
    /**
     * Filter which MathProblemSets to delete
     */
    where?: MathProblemSetWhereInput
  }


  /**
   * MathProblemSet.problems
   */
  export type MathProblemSet$problemsArgs = {
    /**
     * Select specific fields to fetch from the MathSetProbRel
     */
    select?: MathSetProbRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathSetProbRelInclude | null
    where?: MathSetProbRelWhereInput
    orderBy?: Enumerable<MathSetProbRelOrderByWithRelationInput>
    cursor?: MathSetProbRelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MathSetProbRelScalarFieldEnum>
  }


  /**
   * MathProblemSet without action
   */
  export type MathProblemSetArgs = {
    /**
     * Select specific fields to fetch from the MathProblemSet
     */
    select?: MathProblemSetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathProblemSetInclude | null
  }



  /**
   * Model MathSetProbRel
   */


  export type AggregateMathSetProbRel = {
    _count: MathSetProbRelCountAggregateOutputType | null
    _min: MathSetProbRelMinAggregateOutputType | null
    _max: MathSetProbRelMaxAggregateOutputType | null
  }

  export type MathSetProbRelMinAggregateOutputType = {
    problemId: string | null
    setId: string | null
    order: string | null
  }

  export type MathSetProbRelMaxAggregateOutputType = {
    problemId: string | null
    setId: string | null
    order: string | null
  }

  export type MathSetProbRelCountAggregateOutputType = {
    problemId: number
    setId: number
    order: number
    _all: number
  }


  export type MathSetProbRelMinAggregateInputType = {
    problemId?: true
    setId?: true
    order?: true
  }

  export type MathSetProbRelMaxAggregateInputType = {
    problemId?: true
    setId?: true
    order?: true
  }

  export type MathSetProbRelCountAggregateInputType = {
    problemId?: true
    setId?: true
    order?: true
    _all?: true
  }

  export type MathSetProbRelAggregateArgs = {
    /**
     * Filter which MathSetProbRel to aggregate.
     */
    where?: MathSetProbRelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MathSetProbRels to fetch.
     */
    orderBy?: Enumerable<MathSetProbRelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MathSetProbRelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MathSetProbRels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MathSetProbRels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MathSetProbRels
    **/
    _count?: true | MathSetProbRelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MathSetProbRelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MathSetProbRelMaxAggregateInputType
  }

  export type GetMathSetProbRelAggregateType<T extends MathSetProbRelAggregateArgs> = {
        [P in keyof T & keyof AggregateMathSetProbRel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMathSetProbRel[P]>
      : GetScalarType<T[P], AggregateMathSetProbRel[P]>
  }




  export type MathSetProbRelGroupByArgs = {
    where?: MathSetProbRelWhereInput
    orderBy?: Enumerable<MathSetProbRelOrderByWithAggregationInput>
    by: MathSetProbRelScalarFieldEnum[]
    having?: MathSetProbRelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MathSetProbRelCountAggregateInputType | true
    _min?: MathSetProbRelMinAggregateInputType
    _max?: MathSetProbRelMaxAggregateInputType
  }


  export type MathSetProbRelGroupByOutputType = {
    problemId: string
    setId: string
    order: string
    _count: MathSetProbRelCountAggregateOutputType | null
    _min: MathSetProbRelMinAggregateOutputType | null
    _max: MathSetProbRelMaxAggregateOutputType | null
  }

  type GetMathSetProbRelGroupByPayload<T extends MathSetProbRelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MathSetProbRelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MathSetProbRelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MathSetProbRelGroupByOutputType[P]>
            : GetScalarType<T[P], MathSetProbRelGroupByOutputType[P]>
        }
      >
    >


  export type MathSetProbRelSelect = {
    problemId?: boolean
    setId?: boolean
    order?: boolean
    problem?: boolean | MathProblemArgs
    mathProbSet?: boolean | MathProblemSetArgs
  }


  export type MathSetProbRelInclude = {
    problem?: boolean | MathProblemArgs
    mathProbSet?: boolean | MathProblemSetArgs
  }

  export type MathSetProbRelGetPayload<S extends boolean | null | undefined | MathSetProbRelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MathSetProbRel :
    S extends undefined ? never :
    S extends { include: any } & (MathSetProbRelArgs | MathSetProbRelFindManyArgs)
    ? MathSetProbRel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'problem' ? MathProblemGetPayload<S['include'][P]> :
        P extends 'mathProbSet' ? MathProblemSetGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MathSetProbRelArgs | MathSetProbRelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'problem' ? MathProblemGetPayload<S['select'][P]> :
        P extends 'mathProbSet' ? MathProblemSetGetPayload<S['select'][P]> :  P extends keyof MathSetProbRel ? MathSetProbRel[P] : never
  } 
      : MathSetProbRel


  type MathSetProbRelCountArgs = 
    Omit<MathSetProbRelFindManyArgs, 'select' | 'include'> & {
      select?: MathSetProbRelCountAggregateInputType | true
    }

  export interface MathSetProbRelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MathSetProbRel that matches the filter.
     * @param {MathSetProbRelFindUniqueArgs} args - Arguments to find a MathSetProbRel
     * @example
     * // Get one MathSetProbRel
     * const mathSetProbRel = await prisma.mathSetProbRel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MathSetProbRelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MathSetProbRelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MathSetProbRel'> extends True ? Prisma__MathSetProbRelClient<MathSetProbRelGetPayload<T>> : Prisma__MathSetProbRelClient<MathSetProbRelGetPayload<T> | null, null>

    /**
     * Find one MathSetProbRel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MathSetProbRelFindUniqueOrThrowArgs} args - Arguments to find a MathSetProbRel
     * @example
     * // Get one MathSetProbRel
     * const mathSetProbRel = await prisma.mathSetProbRel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MathSetProbRelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MathSetProbRelFindUniqueOrThrowArgs>
    ): Prisma__MathSetProbRelClient<MathSetProbRelGetPayload<T>>

    /**
     * Find the first MathSetProbRel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathSetProbRelFindFirstArgs} args - Arguments to find a MathSetProbRel
     * @example
     * // Get one MathSetProbRel
     * const mathSetProbRel = await prisma.mathSetProbRel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MathSetProbRelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MathSetProbRelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MathSetProbRel'> extends True ? Prisma__MathSetProbRelClient<MathSetProbRelGetPayload<T>> : Prisma__MathSetProbRelClient<MathSetProbRelGetPayload<T> | null, null>

    /**
     * Find the first MathSetProbRel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathSetProbRelFindFirstOrThrowArgs} args - Arguments to find a MathSetProbRel
     * @example
     * // Get one MathSetProbRel
     * const mathSetProbRel = await prisma.mathSetProbRel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MathSetProbRelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MathSetProbRelFindFirstOrThrowArgs>
    ): Prisma__MathSetProbRelClient<MathSetProbRelGetPayload<T>>

    /**
     * Find zero or more MathSetProbRels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathSetProbRelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MathSetProbRels
     * const mathSetProbRels = await prisma.mathSetProbRel.findMany()
     * 
     * // Get first 10 MathSetProbRels
     * const mathSetProbRels = await prisma.mathSetProbRel.findMany({ take: 10 })
     * 
     * // Only select the `problemId`
     * const mathSetProbRelWithProblemIdOnly = await prisma.mathSetProbRel.findMany({ select: { problemId: true } })
     * 
    **/
    findMany<T extends MathSetProbRelFindManyArgs>(
      args?: SelectSubset<T, MathSetProbRelFindManyArgs>
    ): Prisma.PrismaPromise<Array<MathSetProbRelGetPayload<T>>>

    /**
     * Create a MathSetProbRel.
     * @param {MathSetProbRelCreateArgs} args - Arguments to create a MathSetProbRel.
     * @example
     * // Create one MathSetProbRel
     * const MathSetProbRel = await prisma.mathSetProbRel.create({
     *   data: {
     *     // ... data to create a MathSetProbRel
     *   }
     * })
     * 
    **/
    create<T extends MathSetProbRelCreateArgs>(
      args: SelectSubset<T, MathSetProbRelCreateArgs>
    ): Prisma__MathSetProbRelClient<MathSetProbRelGetPayload<T>>

    /**
     * Create many MathSetProbRels.
     *     @param {MathSetProbRelCreateManyArgs} args - Arguments to create many MathSetProbRels.
     *     @example
     *     // Create many MathSetProbRels
     *     const mathSetProbRel = await prisma.mathSetProbRel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MathSetProbRelCreateManyArgs>(
      args?: SelectSubset<T, MathSetProbRelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MathSetProbRel.
     * @param {MathSetProbRelDeleteArgs} args - Arguments to delete one MathSetProbRel.
     * @example
     * // Delete one MathSetProbRel
     * const MathSetProbRel = await prisma.mathSetProbRel.delete({
     *   where: {
     *     // ... filter to delete one MathSetProbRel
     *   }
     * })
     * 
    **/
    delete<T extends MathSetProbRelDeleteArgs>(
      args: SelectSubset<T, MathSetProbRelDeleteArgs>
    ): Prisma__MathSetProbRelClient<MathSetProbRelGetPayload<T>>

    /**
     * Update one MathSetProbRel.
     * @param {MathSetProbRelUpdateArgs} args - Arguments to update one MathSetProbRel.
     * @example
     * // Update one MathSetProbRel
     * const mathSetProbRel = await prisma.mathSetProbRel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MathSetProbRelUpdateArgs>(
      args: SelectSubset<T, MathSetProbRelUpdateArgs>
    ): Prisma__MathSetProbRelClient<MathSetProbRelGetPayload<T>>

    /**
     * Delete zero or more MathSetProbRels.
     * @param {MathSetProbRelDeleteManyArgs} args - Arguments to filter MathSetProbRels to delete.
     * @example
     * // Delete a few MathSetProbRels
     * const { count } = await prisma.mathSetProbRel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MathSetProbRelDeleteManyArgs>(
      args?: SelectSubset<T, MathSetProbRelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MathSetProbRels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathSetProbRelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MathSetProbRels
     * const mathSetProbRel = await prisma.mathSetProbRel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MathSetProbRelUpdateManyArgs>(
      args: SelectSubset<T, MathSetProbRelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MathSetProbRel.
     * @param {MathSetProbRelUpsertArgs} args - Arguments to update or create a MathSetProbRel.
     * @example
     * // Update or create a MathSetProbRel
     * const mathSetProbRel = await prisma.mathSetProbRel.upsert({
     *   create: {
     *     // ... data to create a MathSetProbRel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MathSetProbRel we want to update
     *   }
     * })
    **/
    upsert<T extends MathSetProbRelUpsertArgs>(
      args: SelectSubset<T, MathSetProbRelUpsertArgs>
    ): Prisma__MathSetProbRelClient<MathSetProbRelGetPayload<T>>

    /**
     * Count the number of MathSetProbRels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathSetProbRelCountArgs} args - Arguments to filter MathSetProbRels to count.
     * @example
     * // Count the number of MathSetProbRels
     * const count = await prisma.mathSetProbRel.count({
     *   where: {
     *     // ... the filter for the MathSetProbRels we want to count
     *   }
     * })
    **/
    count<T extends MathSetProbRelCountArgs>(
      args?: Subset<T, MathSetProbRelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MathSetProbRelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MathSetProbRel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathSetProbRelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MathSetProbRelAggregateArgs>(args: Subset<T, MathSetProbRelAggregateArgs>): Prisma.PrismaPromise<GetMathSetProbRelAggregateType<T>>

    /**
     * Group by MathSetProbRel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathSetProbRelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MathSetProbRelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MathSetProbRelGroupByArgs['orderBy'] }
        : { orderBy?: MathSetProbRelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MathSetProbRelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMathSetProbRelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MathSetProbRel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MathSetProbRelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    problem<T extends MathProblemArgs= {}>(args?: Subset<T, MathProblemArgs>): Prisma__MathProblemClient<MathProblemGetPayload<T> | Null>;

    mathProbSet<T extends MathProblemSetArgs= {}>(args?: Subset<T, MathProblemSetArgs>): Prisma__MathProblemSetClient<MathProblemSetGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MathSetProbRel base type for findUnique actions
   */
  export type MathSetProbRelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MathSetProbRel
     */
    select?: MathSetProbRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathSetProbRelInclude | null
    /**
     * Filter, which MathSetProbRel to fetch.
     */
    where: MathSetProbRelWhereUniqueInput
  }

  /**
   * MathSetProbRel findUnique
   */
  export interface MathSetProbRelFindUniqueArgs extends MathSetProbRelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MathSetProbRel findUniqueOrThrow
   */
  export type MathSetProbRelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MathSetProbRel
     */
    select?: MathSetProbRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathSetProbRelInclude | null
    /**
     * Filter, which MathSetProbRel to fetch.
     */
    where: MathSetProbRelWhereUniqueInput
  }


  /**
   * MathSetProbRel base type for findFirst actions
   */
  export type MathSetProbRelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MathSetProbRel
     */
    select?: MathSetProbRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathSetProbRelInclude | null
    /**
     * Filter, which MathSetProbRel to fetch.
     */
    where?: MathSetProbRelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MathSetProbRels to fetch.
     */
    orderBy?: Enumerable<MathSetProbRelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MathSetProbRels.
     */
    cursor?: MathSetProbRelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MathSetProbRels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MathSetProbRels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MathSetProbRels.
     */
    distinct?: Enumerable<MathSetProbRelScalarFieldEnum>
  }

  /**
   * MathSetProbRel findFirst
   */
  export interface MathSetProbRelFindFirstArgs extends MathSetProbRelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MathSetProbRel findFirstOrThrow
   */
  export type MathSetProbRelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MathSetProbRel
     */
    select?: MathSetProbRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathSetProbRelInclude | null
    /**
     * Filter, which MathSetProbRel to fetch.
     */
    where?: MathSetProbRelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MathSetProbRels to fetch.
     */
    orderBy?: Enumerable<MathSetProbRelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MathSetProbRels.
     */
    cursor?: MathSetProbRelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MathSetProbRels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MathSetProbRels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MathSetProbRels.
     */
    distinct?: Enumerable<MathSetProbRelScalarFieldEnum>
  }


  /**
   * MathSetProbRel findMany
   */
  export type MathSetProbRelFindManyArgs = {
    /**
     * Select specific fields to fetch from the MathSetProbRel
     */
    select?: MathSetProbRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathSetProbRelInclude | null
    /**
     * Filter, which MathSetProbRels to fetch.
     */
    where?: MathSetProbRelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MathSetProbRels to fetch.
     */
    orderBy?: Enumerable<MathSetProbRelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MathSetProbRels.
     */
    cursor?: MathSetProbRelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MathSetProbRels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MathSetProbRels.
     */
    skip?: number
    distinct?: Enumerable<MathSetProbRelScalarFieldEnum>
  }


  /**
   * MathSetProbRel create
   */
  export type MathSetProbRelCreateArgs = {
    /**
     * Select specific fields to fetch from the MathSetProbRel
     */
    select?: MathSetProbRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathSetProbRelInclude | null
    /**
     * The data needed to create a MathSetProbRel.
     */
    data: XOR<MathSetProbRelCreateInput, MathSetProbRelUncheckedCreateInput>
  }


  /**
   * MathSetProbRel createMany
   */
  export type MathSetProbRelCreateManyArgs = {
    /**
     * The data used to create many MathSetProbRels.
     */
    data: Enumerable<MathSetProbRelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MathSetProbRel update
   */
  export type MathSetProbRelUpdateArgs = {
    /**
     * Select specific fields to fetch from the MathSetProbRel
     */
    select?: MathSetProbRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathSetProbRelInclude | null
    /**
     * The data needed to update a MathSetProbRel.
     */
    data: XOR<MathSetProbRelUpdateInput, MathSetProbRelUncheckedUpdateInput>
    /**
     * Choose, which MathSetProbRel to update.
     */
    where: MathSetProbRelWhereUniqueInput
  }


  /**
   * MathSetProbRel updateMany
   */
  export type MathSetProbRelUpdateManyArgs = {
    /**
     * The data used to update MathSetProbRels.
     */
    data: XOR<MathSetProbRelUpdateManyMutationInput, MathSetProbRelUncheckedUpdateManyInput>
    /**
     * Filter which MathSetProbRels to update
     */
    where?: MathSetProbRelWhereInput
  }


  /**
   * MathSetProbRel upsert
   */
  export type MathSetProbRelUpsertArgs = {
    /**
     * Select specific fields to fetch from the MathSetProbRel
     */
    select?: MathSetProbRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathSetProbRelInclude | null
    /**
     * The filter to search for the MathSetProbRel to update in case it exists.
     */
    where: MathSetProbRelWhereUniqueInput
    /**
     * In case the MathSetProbRel found by the `where` argument doesn't exist, create a new MathSetProbRel with this data.
     */
    create: XOR<MathSetProbRelCreateInput, MathSetProbRelUncheckedCreateInput>
    /**
     * In case the MathSetProbRel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MathSetProbRelUpdateInput, MathSetProbRelUncheckedUpdateInput>
  }


  /**
   * MathSetProbRel delete
   */
  export type MathSetProbRelDeleteArgs = {
    /**
     * Select specific fields to fetch from the MathSetProbRel
     */
    select?: MathSetProbRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathSetProbRelInclude | null
    /**
     * Filter which MathSetProbRel to delete.
     */
    where: MathSetProbRelWhereUniqueInput
  }


  /**
   * MathSetProbRel deleteMany
   */
  export type MathSetProbRelDeleteManyArgs = {
    /**
     * Filter which MathSetProbRels to delete
     */
    where?: MathSetProbRelWhereInput
  }


  /**
   * MathSetProbRel without action
   */
  export type MathSetProbRelArgs = {
    /**
     * Select specific fields to fetch from the MathSetProbRel
     */
    select?: MathSetProbRelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathSetProbRelInclude | null
  }



  /**
   * Model AuthorMathProblem
   */


  export type AggregateAuthorMathProblem = {
    _count: AuthorMathProblemCountAggregateOutputType | null
    _min: AuthorMathProblemMinAggregateOutputType | null
    _max: AuthorMathProblemMaxAggregateOutputType | null
  }

  export type AuthorMathProblemMinAggregateOutputType = {
    username: string | null
    mathProblemId: string | null
  }

  export type AuthorMathProblemMaxAggregateOutputType = {
    username: string | null
    mathProblemId: string | null
  }

  export type AuthorMathProblemCountAggregateOutputType = {
    username: number
    mathProblemId: number
    _all: number
  }


  export type AuthorMathProblemMinAggregateInputType = {
    username?: true
    mathProblemId?: true
  }

  export type AuthorMathProblemMaxAggregateInputType = {
    username?: true
    mathProblemId?: true
  }

  export type AuthorMathProblemCountAggregateInputType = {
    username?: true
    mathProblemId?: true
    _all?: true
  }

  export type AuthorMathProblemAggregateArgs = {
    /**
     * Filter which AuthorMathProblem to aggregate.
     */
    where?: AuthorMathProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthorMathProblems to fetch.
     */
    orderBy?: Enumerable<AuthorMathProblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthorMathProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthorMathProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthorMathProblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuthorMathProblems
    **/
    _count?: true | AuthorMathProblemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthorMathProblemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthorMathProblemMaxAggregateInputType
  }

  export type GetAuthorMathProblemAggregateType<T extends AuthorMathProblemAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthorMathProblem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthorMathProblem[P]>
      : GetScalarType<T[P], AggregateAuthorMathProblem[P]>
  }




  export type AuthorMathProblemGroupByArgs = {
    where?: AuthorMathProblemWhereInput
    orderBy?: Enumerable<AuthorMathProblemOrderByWithAggregationInput>
    by: AuthorMathProblemScalarFieldEnum[]
    having?: AuthorMathProblemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthorMathProblemCountAggregateInputType | true
    _min?: AuthorMathProblemMinAggregateInputType
    _max?: AuthorMathProblemMaxAggregateInputType
  }


  export type AuthorMathProblemGroupByOutputType = {
    username: string
    mathProblemId: string
    _count: AuthorMathProblemCountAggregateOutputType | null
    _min: AuthorMathProblemMinAggregateOutputType | null
    _max: AuthorMathProblemMaxAggregateOutputType | null
  }

  type GetAuthorMathProblemGroupByPayload<T extends AuthorMathProblemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AuthorMathProblemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthorMathProblemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthorMathProblemGroupByOutputType[P]>
            : GetScalarType<T[P], AuthorMathProblemGroupByOutputType[P]>
        }
      >
    >


  export type AuthorMathProblemSelect = {
    username?: boolean
    mathProblemId?: boolean
    user?: boolean | UserArgs
    mathProblem?: boolean | MathProblemArgs
  }


  export type AuthorMathProblemInclude = {
    user?: boolean | UserArgs
    mathProblem?: boolean | MathProblemArgs
  }

  export type AuthorMathProblemGetPayload<S extends boolean | null | undefined | AuthorMathProblemArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AuthorMathProblem :
    S extends undefined ? never :
    S extends { include: any } & (AuthorMathProblemArgs | AuthorMathProblemFindManyArgs)
    ? AuthorMathProblem  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'mathProblem' ? MathProblemGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (AuthorMathProblemArgs | AuthorMathProblemFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'mathProblem' ? MathProblemGetPayload<S['select'][P]> :  P extends keyof AuthorMathProblem ? AuthorMathProblem[P] : never
  } 
      : AuthorMathProblem


  type AuthorMathProblemCountArgs = 
    Omit<AuthorMathProblemFindManyArgs, 'select' | 'include'> & {
      select?: AuthorMathProblemCountAggregateInputType | true
    }

  export interface AuthorMathProblemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one AuthorMathProblem that matches the filter.
     * @param {AuthorMathProblemFindUniqueArgs} args - Arguments to find a AuthorMathProblem
     * @example
     * // Get one AuthorMathProblem
     * const authorMathProblem = await prisma.authorMathProblem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AuthorMathProblemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AuthorMathProblemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AuthorMathProblem'> extends True ? Prisma__AuthorMathProblemClient<AuthorMathProblemGetPayload<T>> : Prisma__AuthorMathProblemClient<AuthorMathProblemGetPayload<T> | null, null>

    /**
     * Find one AuthorMathProblem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AuthorMathProblemFindUniqueOrThrowArgs} args - Arguments to find a AuthorMathProblem
     * @example
     * // Get one AuthorMathProblem
     * const authorMathProblem = await prisma.authorMathProblem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AuthorMathProblemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AuthorMathProblemFindUniqueOrThrowArgs>
    ): Prisma__AuthorMathProblemClient<AuthorMathProblemGetPayload<T>>

    /**
     * Find the first AuthorMathProblem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorMathProblemFindFirstArgs} args - Arguments to find a AuthorMathProblem
     * @example
     * // Get one AuthorMathProblem
     * const authorMathProblem = await prisma.authorMathProblem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AuthorMathProblemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AuthorMathProblemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AuthorMathProblem'> extends True ? Prisma__AuthorMathProblemClient<AuthorMathProblemGetPayload<T>> : Prisma__AuthorMathProblemClient<AuthorMathProblemGetPayload<T> | null, null>

    /**
     * Find the first AuthorMathProblem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorMathProblemFindFirstOrThrowArgs} args - Arguments to find a AuthorMathProblem
     * @example
     * // Get one AuthorMathProblem
     * const authorMathProblem = await prisma.authorMathProblem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AuthorMathProblemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AuthorMathProblemFindFirstOrThrowArgs>
    ): Prisma__AuthorMathProblemClient<AuthorMathProblemGetPayload<T>>

    /**
     * Find zero or more AuthorMathProblems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorMathProblemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuthorMathProblems
     * const authorMathProblems = await prisma.authorMathProblem.findMany()
     * 
     * // Get first 10 AuthorMathProblems
     * const authorMathProblems = await prisma.authorMathProblem.findMany({ take: 10 })
     * 
     * // Only select the `username`
     * const authorMathProblemWithUsernameOnly = await prisma.authorMathProblem.findMany({ select: { username: true } })
     * 
    **/
    findMany<T extends AuthorMathProblemFindManyArgs>(
      args?: SelectSubset<T, AuthorMathProblemFindManyArgs>
    ): Prisma.PrismaPromise<Array<AuthorMathProblemGetPayload<T>>>

    /**
     * Create a AuthorMathProblem.
     * @param {AuthorMathProblemCreateArgs} args - Arguments to create a AuthorMathProblem.
     * @example
     * // Create one AuthorMathProblem
     * const AuthorMathProblem = await prisma.authorMathProblem.create({
     *   data: {
     *     // ... data to create a AuthorMathProblem
     *   }
     * })
     * 
    **/
    create<T extends AuthorMathProblemCreateArgs>(
      args: SelectSubset<T, AuthorMathProblemCreateArgs>
    ): Prisma__AuthorMathProblemClient<AuthorMathProblemGetPayload<T>>

    /**
     * Create many AuthorMathProblems.
     *     @param {AuthorMathProblemCreateManyArgs} args - Arguments to create many AuthorMathProblems.
     *     @example
     *     // Create many AuthorMathProblems
     *     const authorMathProblem = await prisma.authorMathProblem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AuthorMathProblemCreateManyArgs>(
      args?: SelectSubset<T, AuthorMathProblemCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AuthorMathProblem.
     * @param {AuthorMathProblemDeleteArgs} args - Arguments to delete one AuthorMathProblem.
     * @example
     * // Delete one AuthorMathProblem
     * const AuthorMathProblem = await prisma.authorMathProblem.delete({
     *   where: {
     *     // ... filter to delete one AuthorMathProblem
     *   }
     * })
     * 
    **/
    delete<T extends AuthorMathProblemDeleteArgs>(
      args: SelectSubset<T, AuthorMathProblemDeleteArgs>
    ): Prisma__AuthorMathProblemClient<AuthorMathProblemGetPayload<T>>

    /**
     * Update one AuthorMathProblem.
     * @param {AuthorMathProblemUpdateArgs} args - Arguments to update one AuthorMathProblem.
     * @example
     * // Update one AuthorMathProblem
     * const authorMathProblem = await prisma.authorMathProblem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AuthorMathProblemUpdateArgs>(
      args: SelectSubset<T, AuthorMathProblemUpdateArgs>
    ): Prisma__AuthorMathProblemClient<AuthorMathProblemGetPayload<T>>

    /**
     * Delete zero or more AuthorMathProblems.
     * @param {AuthorMathProblemDeleteManyArgs} args - Arguments to filter AuthorMathProblems to delete.
     * @example
     * // Delete a few AuthorMathProblems
     * const { count } = await prisma.authorMathProblem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AuthorMathProblemDeleteManyArgs>(
      args?: SelectSubset<T, AuthorMathProblemDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuthorMathProblems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorMathProblemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuthorMathProblems
     * const authorMathProblem = await prisma.authorMathProblem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AuthorMathProblemUpdateManyArgs>(
      args: SelectSubset<T, AuthorMathProblemUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuthorMathProblem.
     * @param {AuthorMathProblemUpsertArgs} args - Arguments to update or create a AuthorMathProblem.
     * @example
     * // Update or create a AuthorMathProblem
     * const authorMathProblem = await prisma.authorMathProblem.upsert({
     *   create: {
     *     // ... data to create a AuthorMathProblem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuthorMathProblem we want to update
     *   }
     * })
    **/
    upsert<T extends AuthorMathProblemUpsertArgs>(
      args: SelectSubset<T, AuthorMathProblemUpsertArgs>
    ): Prisma__AuthorMathProblemClient<AuthorMathProblemGetPayload<T>>

    /**
     * Count the number of AuthorMathProblems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorMathProblemCountArgs} args - Arguments to filter AuthorMathProblems to count.
     * @example
     * // Count the number of AuthorMathProblems
     * const count = await prisma.authorMathProblem.count({
     *   where: {
     *     // ... the filter for the AuthorMathProblems we want to count
     *   }
     * })
    **/
    count<T extends AuthorMathProblemCountArgs>(
      args?: Subset<T, AuthorMathProblemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthorMathProblemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuthorMathProblem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorMathProblemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthorMathProblemAggregateArgs>(args: Subset<T, AuthorMathProblemAggregateArgs>): Prisma.PrismaPromise<GetAuthorMathProblemAggregateType<T>>

    /**
     * Group by AuthorMathProblem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorMathProblemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthorMathProblemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthorMathProblemGroupByArgs['orderBy'] }
        : { orderBy?: AuthorMathProblemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthorMathProblemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthorMathProblemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AuthorMathProblem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AuthorMathProblemClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    mathProblem<T extends MathProblemArgs= {}>(args?: Subset<T, MathProblemArgs>): Prisma__MathProblemClient<MathProblemGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AuthorMathProblem base type for findUnique actions
   */
  export type AuthorMathProblemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the AuthorMathProblem
     */
    select?: AuthorMathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorMathProblemInclude | null
    /**
     * Filter, which AuthorMathProblem to fetch.
     */
    where: AuthorMathProblemWhereUniqueInput
  }

  /**
   * AuthorMathProblem findUnique
   */
  export interface AuthorMathProblemFindUniqueArgs extends AuthorMathProblemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AuthorMathProblem findUniqueOrThrow
   */
  export type AuthorMathProblemFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AuthorMathProblem
     */
    select?: AuthorMathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorMathProblemInclude | null
    /**
     * Filter, which AuthorMathProblem to fetch.
     */
    where: AuthorMathProblemWhereUniqueInput
  }


  /**
   * AuthorMathProblem base type for findFirst actions
   */
  export type AuthorMathProblemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the AuthorMathProblem
     */
    select?: AuthorMathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorMathProblemInclude | null
    /**
     * Filter, which AuthorMathProblem to fetch.
     */
    where?: AuthorMathProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthorMathProblems to fetch.
     */
    orderBy?: Enumerable<AuthorMathProblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthorMathProblems.
     */
    cursor?: AuthorMathProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthorMathProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthorMathProblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthorMathProblems.
     */
    distinct?: Enumerable<AuthorMathProblemScalarFieldEnum>
  }

  /**
   * AuthorMathProblem findFirst
   */
  export interface AuthorMathProblemFindFirstArgs extends AuthorMathProblemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AuthorMathProblem findFirstOrThrow
   */
  export type AuthorMathProblemFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AuthorMathProblem
     */
    select?: AuthorMathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorMathProblemInclude | null
    /**
     * Filter, which AuthorMathProblem to fetch.
     */
    where?: AuthorMathProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthorMathProblems to fetch.
     */
    orderBy?: Enumerable<AuthorMathProblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthorMathProblems.
     */
    cursor?: AuthorMathProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthorMathProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthorMathProblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthorMathProblems.
     */
    distinct?: Enumerable<AuthorMathProblemScalarFieldEnum>
  }


  /**
   * AuthorMathProblem findMany
   */
  export type AuthorMathProblemFindManyArgs = {
    /**
     * Select specific fields to fetch from the AuthorMathProblem
     */
    select?: AuthorMathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorMathProblemInclude | null
    /**
     * Filter, which AuthorMathProblems to fetch.
     */
    where?: AuthorMathProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthorMathProblems to fetch.
     */
    orderBy?: Enumerable<AuthorMathProblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuthorMathProblems.
     */
    cursor?: AuthorMathProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthorMathProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthorMathProblems.
     */
    skip?: number
    distinct?: Enumerable<AuthorMathProblemScalarFieldEnum>
  }


  /**
   * AuthorMathProblem create
   */
  export type AuthorMathProblemCreateArgs = {
    /**
     * Select specific fields to fetch from the AuthorMathProblem
     */
    select?: AuthorMathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorMathProblemInclude | null
    /**
     * The data needed to create a AuthorMathProblem.
     */
    data: XOR<AuthorMathProblemCreateInput, AuthorMathProblemUncheckedCreateInput>
  }


  /**
   * AuthorMathProblem createMany
   */
  export type AuthorMathProblemCreateManyArgs = {
    /**
     * The data used to create many AuthorMathProblems.
     */
    data: Enumerable<AuthorMathProblemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AuthorMathProblem update
   */
  export type AuthorMathProblemUpdateArgs = {
    /**
     * Select specific fields to fetch from the AuthorMathProblem
     */
    select?: AuthorMathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorMathProblemInclude | null
    /**
     * The data needed to update a AuthorMathProblem.
     */
    data: XOR<AuthorMathProblemUpdateInput, AuthorMathProblemUncheckedUpdateInput>
    /**
     * Choose, which AuthorMathProblem to update.
     */
    where: AuthorMathProblemWhereUniqueInput
  }


  /**
   * AuthorMathProblem updateMany
   */
  export type AuthorMathProblemUpdateManyArgs = {
    /**
     * The data used to update AuthorMathProblems.
     */
    data: XOR<AuthorMathProblemUpdateManyMutationInput, AuthorMathProblemUncheckedUpdateManyInput>
    /**
     * Filter which AuthorMathProblems to update
     */
    where?: AuthorMathProblemWhereInput
  }


  /**
   * AuthorMathProblem upsert
   */
  export type AuthorMathProblemUpsertArgs = {
    /**
     * Select specific fields to fetch from the AuthorMathProblem
     */
    select?: AuthorMathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorMathProblemInclude | null
    /**
     * The filter to search for the AuthorMathProblem to update in case it exists.
     */
    where: AuthorMathProblemWhereUniqueInput
    /**
     * In case the AuthorMathProblem found by the `where` argument doesn't exist, create a new AuthorMathProblem with this data.
     */
    create: XOR<AuthorMathProblemCreateInput, AuthorMathProblemUncheckedCreateInput>
    /**
     * In case the AuthorMathProblem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthorMathProblemUpdateInput, AuthorMathProblemUncheckedUpdateInput>
  }


  /**
   * AuthorMathProblem delete
   */
  export type AuthorMathProblemDeleteArgs = {
    /**
     * Select specific fields to fetch from the AuthorMathProblem
     */
    select?: AuthorMathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorMathProblemInclude | null
    /**
     * Filter which AuthorMathProblem to delete.
     */
    where: AuthorMathProblemWhereUniqueInput
  }


  /**
   * AuthorMathProblem deleteMany
   */
  export type AuthorMathProblemDeleteManyArgs = {
    /**
     * Filter which AuthorMathProblems to delete
     */
    where?: AuthorMathProblemWhereInput
  }


  /**
   * AuthorMathProblem without action
   */
  export type AuthorMathProblemArgs = {
    /**
     * Select specific fields to fetch from the AuthorMathProblem
     */
    select?: AuthorMathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorMathProblemInclude | null
  }



  /**
   * Model TagMathProblem
   */


  export type AggregateTagMathProblem = {
    _count: TagMathProblemCountAggregateOutputType | null
    _avg: TagMathProblemAvgAggregateOutputType | null
    _sum: TagMathProblemSumAggregateOutputType | null
    _min: TagMathProblemMinAggregateOutputType | null
    _max: TagMathProblemMaxAggregateOutputType | null
  }

  export type TagMathProblemAvgAggregateOutputType = {
    tagId: number | null
  }

  export type TagMathProblemSumAggregateOutputType = {
    tagId: number | null
  }

  export type TagMathProblemMinAggregateOutputType = {
    tagId: number | null
    mathProblemId: string | null
  }

  export type TagMathProblemMaxAggregateOutputType = {
    tagId: number | null
    mathProblemId: string | null
  }

  export type TagMathProblemCountAggregateOutputType = {
    tagId: number
    mathProblemId: number
    _all: number
  }


  export type TagMathProblemAvgAggregateInputType = {
    tagId?: true
  }

  export type TagMathProblemSumAggregateInputType = {
    tagId?: true
  }

  export type TagMathProblemMinAggregateInputType = {
    tagId?: true
    mathProblemId?: true
  }

  export type TagMathProblemMaxAggregateInputType = {
    tagId?: true
    mathProblemId?: true
  }

  export type TagMathProblemCountAggregateInputType = {
    tagId?: true
    mathProblemId?: true
    _all?: true
  }

  export type TagMathProblemAggregateArgs = {
    /**
     * Filter which TagMathProblem to aggregate.
     */
    where?: TagMathProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagMathProblems to fetch.
     */
    orderBy?: Enumerable<TagMathProblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagMathProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagMathProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagMathProblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TagMathProblems
    **/
    _count?: true | TagMathProblemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagMathProblemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagMathProblemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMathProblemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMathProblemMaxAggregateInputType
  }

  export type GetTagMathProblemAggregateType<T extends TagMathProblemAggregateArgs> = {
        [P in keyof T & keyof AggregateTagMathProblem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTagMathProblem[P]>
      : GetScalarType<T[P], AggregateTagMathProblem[P]>
  }




  export type TagMathProblemGroupByArgs = {
    where?: TagMathProblemWhereInput
    orderBy?: Enumerable<TagMathProblemOrderByWithAggregationInput>
    by: TagMathProblemScalarFieldEnum[]
    having?: TagMathProblemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagMathProblemCountAggregateInputType | true
    _avg?: TagMathProblemAvgAggregateInputType
    _sum?: TagMathProblemSumAggregateInputType
    _min?: TagMathProblemMinAggregateInputType
    _max?: TagMathProblemMaxAggregateInputType
  }


  export type TagMathProblemGroupByOutputType = {
    tagId: number
    mathProblemId: string
    _count: TagMathProblemCountAggregateOutputType | null
    _avg: TagMathProblemAvgAggregateOutputType | null
    _sum: TagMathProblemSumAggregateOutputType | null
    _min: TagMathProblemMinAggregateOutputType | null
    _max: TagMathProblemMaxAggregateOutputType | null
  }

  type GetTagMathProblemGroupByPayload<T extends TagMathProblemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TagMathProblemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagMathProblemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagMathProblemGroupByOutputType[P]>
            : GetScalarType<T[P], TagMathProblemGroupByOutputType[P]>
        }
      >
    >


  export type TagMathProblemSelect = {
    tagId?: boolean
    mathProblemId?: boolean
    tag?: boolean | MathProblemTagArgs
    mathProblem?: boolean | MathProblemArgs
  }


  export type TagMathProblemInclude = {
    tag?: boolean | MathProblemTagArgs
    mathProblem?: boolean | MathProblemArgs
  }

  export type TagMathProblemGetPayload<S extends boolean | null | undefined | TagMathProblemArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TagMathProblem :
    S extends undefined ? never :
    S extends { include: any } & (TagMathProblemArgs | TagMathProblemFindManyArgs)
    ? TagMathProblem  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'tag' ? MathProblemTagGetPayload<S['include'][P]> :
        P extends 'mathProblem' ? MathProblemGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TagMathProblemArgs | TagMathProblemFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'tag' ? MathProblemTagGetPayload<S['select'][P]> :
        P extends 'mathProblem' ? MathProblemGetPayload<S['select'][P]> :  P extends keyof TagMathProblem ? TagMathProblem[P] : never
  } 
      : TagMathProblem


  type TagMathProblemCountArgs = 
    Omit<TagMathProblemFindManyArgs, 'select' | 'include'> & {
      select?: TagMathProblemCountAggregateInputType | true
    }

  export interface TagMathProblemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TagMathProblem that matches the filter.
     * @param {TagMathProblemFindUniqueArgs} args - Arguments to find a TagMathProblem
     * @example
     * // Get one TagMathProblem
     * const tagMathProblem = await prisma.tagMathProblem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TagMathProblemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TagMathProblemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TagMathProblem'> extends True ? Prisma__TagMathProblemClient<TagMathProblemGetPayload<T>> : Prisma__TagMathProblemClient<TagMathProblemGetPayload<T> | null, null>

    /**
     * Find one TagMathProblem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TagMathProblemFindUniqueOrThrowArgs} args - Arguments to find a TagMathProblem
     * @example
     * // Get one TagMathProblem
     * const tagMathProblem = await prisma.tagMathProblem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TagMathProblemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TagMathProblemFindUniqueOrThrowArgs>
    ): Prisma__TagMathProblemClient<TagMathProblemGetPayload<T>>

    /**
     * Find the first TagMathProblem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagMathProblemFindFirstArgs} args - Arguments to find a TagMathProblem
     * @example
     * // Get one TagMathProblem
     * const tagMathProblem = await prisma.tagMathProblem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TagMathProblemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TagMathProblemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TagMathProblem'> extends True ? Prisma__TagMathProblemClient<TagMathProblemGetPayload<T>> : Prisma__TagMathProblemClient<TagMathProblemGetPayload<T> | null, null>

    /**
     * Find the first TagMathProblem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagMathProblemFindFirstOrThrowArgs} args - Arguments to find a TagMathProblem
     * @example
     * // Get one TagMathProblem
     * const tagMathProblem = await prisma.tagMathProblem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TagMathProblemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TagMathProblemFindFirstOrThrowArgs>
    ): Prisma__TagMathProblemClient<TagMathProblemGetPayload<T>>

    /**
     * Find zero or more TagMathProblems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagMathProblemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TagMathProblems
     * const tagMathProblems = await prisma.tagMathProblem.findMany()
     * 
     * // Get first 10 TagMathProblems
     * const tagMathProblems = await prisma.tagMathProblem.findMany({ take: 10 })
     * 
     * // Only select the `tagId`
     * const tagMathProblemWithTagIdOnly = await prisma.tagMathProblem.findMany({ select: { tagId: true } })
     * 
    **/
    findMany<T extends TagMathProblemFindManyArgs>(
      args?: SelectSubset<T, TagMathProblemFindManyArgs>
    ): Prisma.PrismaPromise<Array<TagMathProblemGetPayload<T>>>

    /**
     * Create a TagMathProblem.
     * @param {TagMathProblemCreateArgs} args - Arguments to create a TagMathProblem.
     * @example
     * // Create one TagMathProblem
     * const TagMathProblem = await prisma.tagMathProblem.create({
     *   data: {
     *     // ... data to create a TagMathProblem
     *   }
     * })
     * 
    **/
    create<T extends TagMathProblemCreateArgs>(
      args: SelectSubset<T, TagMathProblemCreateArgs>
    ): Prisma__TagMathProblemClient<TagMathProblemGetPayload<T>>

    /**
     * Create many TagMathProblems.
     *     @param {TagMathProblemCreateManyArgs} args - Arguments to create many TagMathProblems.
     *     @example
     *     // Create many TagMathProblems
     *     const tagMathProblem = await prisma.tagMathProblem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TagMathProblemCreateManyArgs>(
      args?: SelectSubset<T, TagMathProblemCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TagMathProblem.
     * @param {TagMathProblemDeleteArgs} args - Arguments to delete one TagMathProblem.
     * @example
     * // Delete one TagMathProblem
     * const TagMathProblem = await prisma.tagMathProblem.delete({
     *   where: {
     *     // ... filter to delete one TagMathProblem
     *   }
     * })
     * 
    **/
    delete<T extends TagMathProblemDeleteArgs>(
      args: SelectSubset<T, TagMathProblemDeleteArgs>
    ): Prisma__TagMathProblemClient<TagMathProblemGetPayload<T>>

    /**
     * Update one TagMathProblem.
     * @param {TagMathProblemUpdateArgs} args - Arguments to update one TagMathProblem.
     * @example
     * // Update one TagMathProblem
     * const tagMathProblem = await prisma.tagMathProblem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TagMathProblemUpdateArgs>(
      args: SelectSubset<T, TagMathProblemUpdateArgs>
    ): Prisma__TagMathProblemClient<TagMathProblemGetPayload<T>>

    /**
     * Delete zero or more TagMathProblems.
     * @param {TagMathProblemDeleteManyArgs} args - Arguments to filter TagMathProblems to delete.
     * @example
     * // Delete a few TagMathProblems
     * const { count } = await prisma.tagMathProblem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TagMathProblemDeleteManyArgs>(
      args?: SelectSubset<T, TagMathProblemDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TagMathProblems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagMathProblemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TagMathProblems
     * const tagMathProblem = await prisma.tagMathProblem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TagMathProblemUpdateManyArgs>(
      args: SelectSubset<T, TagMathProblemUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TagMathProblem.
     * @param {TagMathProblemUpsertArgs} args - Arguments to update or create a TagMathProblem.
     * @example
     * // Update or create a TagMathProblem
     * const tagMathProblem = await prisma.tagMathProblem.upsert({
     *   create: {
     *     // ... data to create a TagMathProblem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TagMathProblem we want to update
     *   }
     * })
    **/
    upsert<T extends TagMathProblemUpsertArgs>(
      args: SelectSubset<T, TagMathProblemUpsertArgs>
    ): Prisma__TagMathProblemClient<TagMathProblemGetPayload<T>>

    /**
     * Count the number of TagMathProblems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagMathProblemCountArgs} args - Arguments to filter TagMathProblems to count.
     * @example
     * // Count the number of TagMathProblems
     * const count = await prisma.tagMathProblem.count({
     *   where: {
     *     // ... the filter for the TagMathProblems we want to count
     *   }
     * })
    **/
    count<T extends TagMathProblemCountArgs>(
      args?: Subset<T, TagMathProblemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagMathProblemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TagMathProblem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagMathProblemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagMathProblemAggregateArgs>(args: Subset<T, TagMathProblemAggregateArgs>): Prisma.PrismaPromise<GetTagMathProblemAggregateType<T>>

    /**
     * Group by TagMathProblem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagMathProblemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagMathProblemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagMathProblemGroupByArgs['orderBy'] }
        : { orderBy?: TagMathProblemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagMathProblemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagMathProblemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TagMathProblem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TagMathProblemClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    tag<T extends MathProblemTagArgs= {}>(args?: Subset<T, MathProblemTagArgs>): Prisma__MathProblemTagClient<MathProblemTagGetPayload<T> | Null>;

    mathProblem<T extends MathProblemArgs= {}>(args?: Subset<T, MathProblemArgs>): Prisma__MathProblemClient<MathProblemGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TagMathProblem base type for findUnique actions
   */
  export type TagMathProblemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TagMathProblem
     */
    select?: TagMathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagMathProblemInclude | null
    /**
     * Filter, which TagMathProblem to fetch.
     */
    where: TagMathProblemWhereUniqueInput
  }

  /**
   * TagMathProblem findUnique
   */
  export interface TagMathProblemFindUniqueArgs extends TagMathProblemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TagMathProblem findUniqueOrThrow
   */
  export type TagMathProblemFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TagMathProblem
     */
    select?: TagMathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagMathProblemInclude | null
    /**
     * Filter, which TagMathProblem to fetch.
     */
    where: TagMathProblemWhereUniqueInput
  }


  /**
   * TagMathProblem base type for findFirst actions
   */
  export type TagMathProblemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TagMathProblem
     */
    select?: TagMathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagMathProblemInclude | null
    /**
     * Filter, which TagMathProblem to fetch.
     */
    where?: TagMathProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagMathProblems to fetch.
     */
    orderBy?: Enumerable<TagMathProblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TagMathProblems.
     */
    cursor?: TagMathProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagMathProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagMathProblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TagMathProblems.
     */
    distinct?: Enumerable<TagMathProblemScalarFieldEnum>
  }

  /**
   * TagMathProblem findFirst
   */
  export interface TagMathProblemFindFirstArgs extends TagMathProblemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TagMathProblem findFirstOrThrow
   */
  export type TagMathProblemFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TagMathProblem
     */
    select?: TagMathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagMathProblemInclude | null
    /**
     * Filter, which TagMathProblem to fetch.
     */
    where?: TagMathProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagMathProblems to fetch.
     */
    orderBy?: Enumerable<TagMathProblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TagMathProblems.
     */
    cursor?: TagMathProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagMathProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagMathProblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TagMathProblems.
     */
    distinct?: Enumerable<TagMathProblemScalarFieldEnum>
  }


  /**
   * TagMathProblem findMany
   */
  export type TagMathProblemFindManyArgs = {
    /**
     * Select specific fields to fetch from the TagMathProblem
     */
    select?: TagMathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagMathProblemInclude | null
    /**
     * Filter, which TagMathProblems to fetch.
     */
    where?: TagMathProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagMathProblems to fetch.
     */
    orderBy?: Enumerable<TagMathProblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TagMathProblems.
     */
    cursor?: TagMathProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagMathProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagMathProblems.
     */
    skip?: number
    distinct?: Enumerable<TagMathProblemScalarFieldEnum>
  }


  /**
   * TagMathProblem create
   */
  export type TagMathProblemCreateArgs = {
    /**
     * Select specific fields to fetch from the TagMathProblem
     */
    select?: TagMathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagMathProblemInclude | null
    /**
     * The data needed to create a TagMathProblem.
     */
    data: XOR<TagMathProblemCreateInput, TagMathProblemUncheckedCreateInput>
  }


  /**
   * TagMathProblem createMany
   */
  export type TagMathProblemCreateManyArgs = {
    /**
     * The data used to create many TagMathProblems.
     */
    data: Enumerable<TagMathProblemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TagMathProblem update
   */
  export type TagMathProblemUpdateArgs = {
    /**
     * Select specific fields to fetch from the TagMathProblem
     */
    select?: TagMathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagMathProblemInclude | null
    /**
     * The data needed to update a TagMathProblem.
     */
    data: XOR<TagMathProblemUpdateInput, TagMathProblemUncheckedUpdateInput>
    /**
     * Choose, which TagMathProblem to update.
     */
    where: TagMathProblemWhereUniqueInput
  }


  /**
   * TagMathProblem updateMany
   */
  export type TagMathProblemUpdateManyArgs = {
    /**
     * The data used to update TagMathProblems.
     */
    data: XOR<TagMathProblemUpdateManyMutationInput, TagMathProblemUncheckedUpdateManyInput>
    /**
     * Filter which TagMathProblems to update
     */
    where?: TagMathProblemWhereInput
  }


  /**
   * TagMathProblem upsert
   */
  export type TagMathProblemUpsertArgs = {
    /**
     * Select specific fields to fetch from the TagMathProblem
     */
    select?: TagMathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagMathProblemInclude | null
    /**
     * The filter to search for the TagMathProblem to update in case it exists.
     */
    where: TagMathProblemWhereUniqueInput
    /**
     * In case the TagMathProblem found by the `where` argument doesn't exist, create a new TagMathProblem with this data.
     */
    create: XOR<TagMathProblemCreateInput, TagMathProblemUncheckedCreateInput>
    /**
     * In case the TagMathProblem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagMathProblemUpdateInput, TagMathProblemUncheckedUpdateInput>
  }


  /**
   * TagMathProblem delete
   */
  export type TagMathProblemDeleteArgs = {
    /**
     * Select specific fields to fetch from the TagMathProblem
     */
    select?: TagMathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagMathProblemInclude | null
    /**
     * Filter which TagMathProblem to delete.
     */
    where: TagMathProblemWhereUniqueInput
  }


  /**
   * TagMathProblem deleteMany
   */
  export type TagMathProblemDeleteManyArgs = {
    /**
     * Filter which TagMathProblems to delete
     */
    where?: TagMathProblemWhereInput
  }


  /**
   * TagMathProblem without action
   */
  export type TagMathProblemArgs = {
    /**
     * Select specific fields to fetch from the TagMathProblem
     */
    select?: TagMathProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagMathProblemInclude | null
  }



  /**
   * Model GroupPost
   */


  export type AggregateGroupPost = {
    _count: GroupPostCountAggregateOutputType | null
    _min: GroupPostMinAggregateOutputType | null
    _max: GroupPostMaxAggregateOutputType | null
  }

  export type GroupPostMinAggregateOutputType = {
    id: string | null
    content: string | null
    authorId: string | null
    createdAt: Date | null
    groupId: string | null
    title: string | null
  }

  export type GroupPostMaxAggregateOutputType = {
    id: string | null
    content: string | null
    authorId: string | null
    createdAt: Date | null
    groupId: string | null
    title: string | null
  }

  export type GroupPostCountAggregateOutputType = {
    id: number
    content: number
    authorId: number
    createdAt: number
    groupId: number
    title: number
    _all: number
  }


  export type GroupPostMinAggregateInputType = {
    id?: true
    content?: true
    authorId?: true
    createdAt?: true
    groupId?: true
    title?: true
  }

  export type GroupPostMaxAggregateInputType = {
    id?: true
    content?: true
    authorId?: true
    createdAt?: true
    groupId?: true
    title?: true
  }

  export type GroupPostCountAggregateInputType = {
    id?: true
    content?: true
    authorId?: true
    createdAt?: true
    groupId?: true
    title?: true
    _all?: true
  }

  export type GroupPostAggregateArgs = {
    /**
     * Filter which GroupPost to aggregate.
     */
    where?: GroupPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupPosts to fetch.
     */
    orderBy?: Enumerable<GroupPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupPosts
    **/
    _count?: true | GroupPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupPostMaxAggregateInputType
  }

  export type GetGroupPostAggregateType<T extends GroupPostAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupPost[P]>
      : GetScalarType<T[P], AggregateGroupPost[P]>
  }




  export type GroupPostGroupByArgs = {
    where?: GroupPostWhereInput
    orderBy?: Enumerable<GroupPostOrderByWithAggregationInput>
    by: GroupPostScalarFieldEnum[]
    having?: GroupPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupPostCountAggregateInputType | true
    _min?: GroupPostMinAggregateInputType
    _max?: GroupPostMaxAggregateInputType
  }


  export type GroupPostGroupByOutputType = {
    id: string
    content: string
    authorId: string
    createdAt: Date
    groupId: string
    title: string
    _count: GroupPostCountAggregateOutputType | null
    _min: GroupPostMinAggregateOutputType | null
    _max: GroupPostMaxAggregateOutputType | null
  }

  type GetGroupPostGroupByPayload<T extends GroupPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<GroupPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupPostGroupByOutputType[P]>
            : GetScalarType<T[P], GroupPostGroupByOutputType[P]>
        }
      >
    >


  export type GroupPostSelect = {
    id?: boolean
    content?: boolean
    authorId?: boolean
    createdAt?: boolean
    groupId?: boolean
    title?: boolean
    author?: boolean | UserArgs
    group?: boolean | GroupArgs
    messages?: boolean | GroupPost$messagesArgs
    _count?: boolean | GroupPostCountOutputTypeArgs
  }


  export type GroupPostInclude = {
    author?: boolean | UserArgs
    group?: boolean | GroupArgs
    messages?: boolean | GroupPost$messagesArgs
    _count?: boolean | GroupPostCountOutputTypeArgs
  }

  export type GroupPostGetPayload<S extends boolean | null | undefined | GroupPostArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? GroupPost :
    S extends undefined ? never :
    S extends { include: any } & (GroupPostArgs | GroupPostFindManyArgs)
    ? GroupPost  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'author' ? UserGetPayload<S['include'][P]> :
        P extends 'group' ? GroupGetPayload<S['include'][P]> :
        P extends 'messages' ? Array < GroupPostMessageGetPayload<S['include'][P]>>  :
        P extends '_count' ? GroupPostCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (GroupPostArgs | GroupPostFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'author' ? UserGetPayload<S['select'][P]> :
        P extends 'group' ? GroupGetPayload<S['select'][P]> :
        P extends 'messages' ? Array < GroupPostMessageGetPayload<S['select'][P]>>  :
        P extends '_count' ? GroupPostCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof GroupPost ? GroupPost[P] : never
  } 
      : GroupPost


  type GroupPostCountArgs = 
    Omit<GroupPostFindManyArgs, 'select' | 'include'> & {
      select?: GroupPostCountAggregateInputType | true
    }

  export interface GroupPostDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one GroupPost that matches the filter.
     * @param {GroupPostFindUniqueArgs} args - Arguments to find a GroupPost
     * @example
     * // Get one GroupPost
     * const groupPost = await prisma.groupPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GroupPostFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GroupPostFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'GroupPost'> extends True ? Prisma__GroupPostClient<GroupPostGetPayload<T>> : Prisma__GroupPostClient<GroupPostGetPayload<T> | null, null>

    /**
     * Find one GroupPost that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GroupPostFindUniqueOrThrowArgs} args - Arguments to find a GroupPost
     * @example
     * // Get one GroupPost
     * const groupPost = await prisma.groupPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GroupPostFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, GroupPostFindUniqueOrThrowArgs>
    ): Prisma__GroupPostClient<GroupPostGetPayload<T>>

    /**
     * Find the first GroupPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupPostFindFirstArgs} args - Arguments to find a GroupPost
     * @example
     * // Get one GroupPost
     * const groupPost = await prisma.groupPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GroupPostFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GroupPostFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'GroupPost'> extends True ? Prisma__GroupPostClient<GroupPostGetPayload<T>> : Prisma__GroupPostClient<GroupPostGetPayload<T> | null, null>

    /**
     * Find the first GroupPost that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupPostFindFirstOrThrowArgs} args - Arguments to find a GroupPost
     * @example
     * // Get one GroupPost
     * const groupPost = await prisma.groupPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GroupPostFindFirstOrThrowArgs>(
      args?: SelectSubset<T, GroupPostFindFirstOrThrowArgs>
    ): Prisma__GroupPostClient<GroupPostGetPayload<T>>

    /**
     * Find zero or more GroupPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupPostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupPosts
     * const groupPosts = await prisma.groupPost.findMany()
     * 
     * // Get first 10 GroupPosts
     * const groupPosts = await prisma.groupPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupPostWithIdOnly = await prisma.groupPost.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GroupPostFindManyArgs>(
      args?: SelectSubset<T, GroupPostFindManyArgs>
    ): Prisma.PrismaPromise<Array<GroupPostGetPayload<T>>>

    /**
     * Create a GroupPost.
     * @param {GroupPostCreateArgs} args - Arguments to create a GroupPost.
     * @example
     * // Create one GroupPost
     * const GroupPost = await prisma.groupPost.create({
     *   data: {
     *     // ... data to create a GroupPost
     *   }
     * })
     * 
    **/
    create<T extends GroupPostCreateArgs>(
      args: SelectSubset<T, GroupPostCreateArgs>
    ): Prisma__GroupPostClient<GroupPostGetPayload<T>>

    /**
     * Create many GroupPosts.
     *     @param {GroupPostCreateManyArgs} args - Arguments to create many GroupPosts.
     *     @example
     *     // Create many GroupPosts
     *     const groupPost = await prisma.groupPost.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GroupPostCreateManyArgs>(
      args?: SelectSubset<T, GroupPostCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GroupPost.
     * @param {GroupPostDeleteArgs} args - Arguments to delete one GroupPost.
     * @example
     * // Delete one GroupPost
     * const GroupPost = await prisma.groupPost.delete({
     *   where: {
     *     // ... filter to delete one GroupPost
     *   }
     * })
     * 
    **/
    delete<T extends GroupPostDeleteArgs>(
      args: SelectSubset<T, GroupPostDeleteArgs>
    ): Prisma__GroupPostClient<GroupPostGetPayload<T>>

    /**
     * Update one GroupPost.
     * @param {GroupPostUpdateArgs} args - Arguments to update one GroupPost.
     * @example
     * // Update one GroupPost
     * const groupPost = await prisma.groupPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GroupPostUpdateArgs>(
      args: SelectSubset<T, GroupPostUpdateArgs>
    ): Prisma__GroupPostClient<GroupPostGetPayload<T>>

    /**
     * Delete zero or more GroupPosts.
     * @param {GroupPostDeleteManyArgs} args - Arguments to filter GroupPosts to delete.
     * @example
     * // Delete a few GroupPosts
     * const { count } = await prisma.groupPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GroupPostDeleteManyArgs>(
      args?: SelectSubset<T, GroupPostDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupPosts
     * const groupPost = await prisma.groupPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GroupPostUpdateManyArgs>(
      args: SelectSubset<T, GroupPostUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GroupPost.
     * @param {GroupPostUpsertArgs} args - Arguments to update or create a GroupPost.
     * @example
     * // Update or create a GroupPost
     * const groupPost = await prisma.groupPost.upsert({
     *   create: {
     *     // ... data to create a GroupPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupPost we want to update
     *   }
     * })
    **/
    upsert<T extends GroupPostUpsertArgs>(
      args: SelectSubset<T, GroupPostUpsertArgs>
    ): Prisma__GroupPostClient<GroupPostGetPayload<T>>

    /**
     * Count the number of GroupPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupPostCountArgs} args - Arguments to filter GroupPosts to count.
     * @example
     * // Count the number of GroupPosts
     * const count = await prisma.groupPost.count({
     *   where: {
     *     // ... the filter for the GroupPosts we want to count
     *   }
     * })
    **/
    count<T extends GroupPostCountArgs>(
      args?: Subset<T, GroupPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupPostAggregateArgs>(args: Subset<T, GroupPostAggregateArgs>): Prisma.PrismaPromise<GetGroupPostAggregateType<T>>

    /**
     * Group by GroupPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupPostGroupByArgs['orderBy'] }
        : { orderBy?: GroupPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GroupPostClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    author<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    group<T extends GroupArgs= {}>(args?: Subset<T, GroupArgs>): Prisma__GroupClient<GroupGetPayload<T> | Null>;

    messages<T extends GroupPost$messagesArgs= {}>(args?: Subset<T, GroupPost$messagesArgs>): Prisma.PrismaPromise<Array<GroupPostMessageGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * GroupPost base type for findUnique actions
   */
  export type GroupPostFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the GroupPost
     */
    select?: GroupPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupPostInclude | null
    /**
     * Filter, which GroupPost to fetch.
     */
    where: GroupPostWhereUniqueInput
  }

  /**
   * GroupPost findUnique
   */
  export interface GroupPostFindUniqueArgs extends GroupPostFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * GroupPost findUniqueOrThrow
   */
  export type GroupPostFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the GroupPost
     */
    select?: GroupPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupPostInclude | null
    /**
     * Filter, which GroupPost to fetch.
     */
    where: GroupPostWhereUniqueInput
  }


  /**
   * GroupPost base type for findFirst actions
   */
  export type GroupPostFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the GroupPost
     */
    select?: GroupPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupPostInclude | null
    /**
     * Filter, which GroupPost to fetch.
     */
    where?: GroupPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupPosts to fetch.
     */
    orderBy?: Enumerable<GroupPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupPosts.
     */
    cursor?: GroupPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupPosts.
     */
    distinct?: Enumerable<GroupPostScalarFieldEnum>
  }

  /**
   * GroupPost findFirst
   */
  export interface GroupPostFindFirstArgs extends GroupPostFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * GroupPost findFirstOrThrow
   */
  export type GroupPostFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the GroupPost
     */
    select?: GroupPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupPostInclude | null
    /**
     * Filter, which GroupPost to fetch.
     */
    where?: GroupPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupPosts to fetch.
     */
    orderBy?: Enumerable<GroupPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupPosts.
     */
    cursor?: GroupPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupPosts.
     */
    distinct?: Enumerable<GroupPostScalarFieldEnum>
  }


  /**
   * GroupPost findMany
   */
  export type GroupPostFindManyArgs = {
    /**
     * Select specific fields to fetch from the GroupPost
     */
    select?: GroupPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupPostInclude | null
    /**
     * Filter, which GroupPosts to fetch.
     */
    where?: GroupPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupPosts to fetch.
     */
    orderBy?: Enumerable<GroupPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupPosts.
     */
    cursor?: GroupPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupPosts.
     */
    skip?: number
    distinct?: Enumerable<GroupPostScalarFieldEnum>
  }


  /**
   * GroupPost create
   */
  export type GroupPostCreateArgs = {
    /**
     * Select specific fields to fetch from the GroupPost
     */
    select?: GroupPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupPostInclude | null
    /**
     * The data needed to create a GroupPost.
     */
    data: XOR<GroupPostCreateInput, GroupPostUncheckedCreateInput>
  }


  /**
   * GroupPost createMany
   */
  export type GroupPostCreateManyArgs = {
    /**
     * The data used to create many GroupPosts.
     */
    data: Enumerable<GroupPostCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * GroupPost update
   */
  export type GroupPostUpdateArgs = {
    /**
     * Select specific fields to fetch from the GroupPost
     */
    select?: GroupPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupPostInclude | null
    /**
     * The data needed to update a GroupPost.
     */
    data: XOR<GroupPostUpdateInput, GroupPostUncheckedUpdateInput>
    /**
     * Choose, which GroupPost to update.
     */
    where: GroupPostWhereUniqueInput
  }


  /**
   * GroupPost updateMany
   */
  export type GroupPostUpdateManyArgs = {
    /**
     * The data used to update GroupPosts.
     */
    data: XOR<GroupPostUpdateManyMutationInput, GroupPostUncheckedUpdateManyInput>
    /**
     * Filter which GroupPosts to update
     */
    where?: GroupPostWhereInput
  }


  /**
   * GroupPost upsert
   */
  export type GroupPostUpsertArgs = {
    /**
     * Select specific fields to fetch from the GroupPost
     */
    select?: GroupPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupPostInclude | null
    /**
     * The filter to search for the GroupPost to update in case it exists.
     */
    where: GroupPostWhereUniqueInput
    /**
     * In case the GroupPost found by the `where` argument doesn't exist, create a new GroupPost with this data.
     */
    create: XOR<GroupPostCreateInput, GroupPostUncheckedCreateInput>
    /**
     * In case the GroupPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupPostUpdateInput, GroupPostUncheckedUpdateInput>
  }


  /**
   * GroupPost delete
   */
  export type GroupPostDeleteArgs = {
    /**
     * Select specific fields to fetch from the GroupPost
     */
    select?: GroupPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupPostInclude | null
    /**
     * Filter which GroupPost to delete.
     */
    where: GroupPostWhereUniqueInput
  }


  /**
   * GroupPost deleteMany
   */
  export type GroupPostDeleteManyArgs = {
    /**
     * Filter which GroupPosts to delete
     */
    where?: GroupPostWhereInput
  }


  /**
   * GroupPost.messages
   */
  export type GroupPost$messagesArgs = {
    /**
     * Select specific fields to fetch from the GroupPostMessage
     */
    select?: GroupPostMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupPostMessageInclude | null
    where?: GroupPostMessageWhereInput
    orderBy?: Enumerable<GroupPostMessageOrderByWithRelationInput>
    cursor?: GroupPostMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<GroupPostMessageScalarFieldEnum>
  }


  /**
   * GroupPost without action
   */
  export type GroupPostArgs = {
    /**
     * Select specific fields to fetch from the GroupPost
     */
    select?: GroupPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupPostInclude | null
  }



  /**
   * Model ChatMessage
   */


  export type AggregateChatMessage = {
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  export type ChatMessageMinAggregateOutputType = {
    id: string | null
    content: string | null
    authorId: string | null
    createdAt: Date | null
    sessionId: string | null
  }

  export type ChatMessageMaxAggregateOutputType = {
    id: string | null
    content: string | null
    authorId: string | null
    createdAt: Date | null
    sessionId: string | null
  }

  export type ChatMessageCountAggregateOutputType = {
    id: number
    content: number
    authorId: number
    createdAt: number
    referenceMessage: number
    sessionId: number
    _all: number
  }


  export type ChatMessageMinAggregateInputType = {
    id?: true
    content?: true
    authorId?: true
    createdAt?: true
    sessionId?: true
  }

  export type ChatMessageMaxAggregateInputType = {
    id?: true
    content?: true
    authorId?: true
    createdAt?: true
    sessionId?: true
  }

  export type ChatMessageCountAggregateInputType = {
    id?: true
    content?: true
    authorId?: true
    createdAt?: true
    referenceMessage?: true
    sessionId?: true
    _all?: true
  }

  export type ChatMessageAggregateArgs = {
    /**
     * Filter which ChatMessage to aggregate.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: Enumerable<ChatMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatMessages
    **/
    _count?: true | ChatMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMessageMaxAggregateInputType
  }

  export type GetChatMessageAggregateType<T extends ChatMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatMessage[P]>
      : GetScalarType<T[P], AggregateChatMessage[P]>
  }




  export type ChatMessageGroupByArgs = {
    where?: ChatMessageWhereInput
    orderBy?: Enumerable<ChatMessageOrderByWithAggregationInput>
    by: ChatMessageScalarFieldEnum[]
    having?: ChatMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatMessageCountAggregateInputType | true
    _min?: ChatMessageMinAggregateInputType
    _max?: ChatMessageMaxAggregateInputType
  }


  export type ChatMessageGroupByOutputType = {
    id: string
    content: string
    authorId: string
    createdAt: Date
    referenceMessage: JsonValue | null
    sessionId: string
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  type GetChatMessageGroupByPayload<T extends ChatMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ChatMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
        }
      >
    >


  export type ChatMessageSelect = {
    id?: boolean
    content?: boolean
    authorId?: boolean
    createdAt?: boolean
    referenceMessage?: boolean
    sessionId?: boolean
    author?: boolean | UserArgs
    chatSession?: boolean | ChatSessionArgs
  }


  export type ChatMessageInclude = {
    author?: boolean | UserArgs
    chatSession?: boolean | ChatSessionArgs
  }

  export type ChatMessageGetPayload<S extends boolean | null | undefined | ChatMessageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ChatMessage :
    S extends undefined ? never :
    S extends { include: any } & (ChatMessageArgs | ChatMessageFindManyArgs)
    ? ChatMessage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'author' ? UserGetPayload<S['include'][P]> :
        P extends 'chatSession' ? ChatSessionGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ChatMessageArgs | ChatMessageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'author' ? UserGetPayload<S['select'][P]> :
        P extends 'chatSession' ? ChatSessionGetPayload<S['select'][P]> :  P extends keyof ChatMessage ? ChatMessage[P] : never
  } 
      : ChatMessage


  type ChatMessageCountArgs = 
    Omit<ChatMessageFindManyArgs, 'select' | 'include'> & {
      select?: ChatMessageCountAggregateInputType | true
    }

  export interface ChatMessageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ChatMessage that matches the filter.
     * @param {ChatMessageFindUniqueArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChatMessageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ChatMessageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ChatMessage'> extends True ? Prisma__ChatMessageClient<ChatMessageGetPayload<T>> : Prisma__ChatMessageClient<ChatMessageGetPayload<T> | null, null>

    /**
     * Find one ChatMessage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ChatMessageFindUniqueOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ChatMessageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ChatMessageFindUniqueOrThrowArgs>
    ): Prisma__ChatMessageClient<ChatMessageGetPayload<T>>

    /**
     * Find the first ChatMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChatMessageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ChatMessageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ChatMessage'> extends True ? Prisma__ChatMessageClient<ChatMessageGetPayload<T>> : Prisma__ChatMessageClient<ChatMessageGetPayload<T> | null, null>

    /**
     * Find the first ChatMessage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ChatMessageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ChatMessageFindFirstOrThrowArgs>
    ): Prisma__ChatMessageClient<ChatMessageGetPayload<T>>

    /**
     * Find zero or more ChatMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany()
     * 
     * // Get first 10 ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ChatMessageFindManyArgs>(
      args?: SelectSubset<T, ChatMessageFindManyArgs>
    ): Prisma.PrismaPromise<Array<ChatMessageGetPayload<T>>>

    /**
     * Create a ChatMessage.
     * @param {ChatMessageCreateArgs} args - Arguments to create a ChatMessage.
     * @example
     * // Create one ChatMessage
     * const ChatMessage = await prisma.chatMessage.create({
     *   data: {
     *     // ... data to create a ChatMessage
     *   }
     * })
     * 
    **/
    create<T extends ChatMessageCreateArgs>(
      args: SelectSubset<T, ChatMessageCreateArgs>
    ): Prisma__ChatMessageClient<ChatMessageGetPayload<T>>

    /**
     * Create many ChatMessages.
     *     @param {ChatMessageCreateManyArgs} args - Arguments to create many ChatMessages.
     *     @example
     *     // Create many ChatMessages
     *     const chatMessage = await prisma.chatMessage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChatMessageCreateManyArgs>(
      args?: SelectSubset<T, ChatMessageCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChatMessage.
     * @param {ChatMessageDeleteArgs} args - Arguments to delete one ChatMessage.
     * @example
     * // Delete one ChatMessage
     * const ChatMessage = await prisma.chatMessage.delete({
     *   where: {
     *     // ... filter to delete one ChatMessage
     *   }
     * })
     * 
    **/
    delete<T extends ChatMessageDeleteArgs>(
      args: SelectSubset<T, ChatMessageDeleteArgs>
    ): Prisma__ChatMessageClient<ChatMessageGetPayload<T>>

    /**
     * Update one ChatMessage.
     * @param {ChatMessageUpdateArgs} args - Arguments to update one ChatMessage.
     * @example
     * // Update one ChatMessage
     * const chatMessage = await prisma.chatMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChatMessageUpdateArgs>(
      args: SelectSubset<T, ChatMessageUpdateArgs>
    ): Prisma__ChatMessageClient<ChatMessageGetPayload<T>>

    /**
     * Delete zero or more ChatMessages.
     * @param {ChatMessageDeleteManyArgs} args - Arguments to filter ChatMessages to delete.
     * @example
     * // Delete a few ChatMessages
     * const { count } = await prisma.chatMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChatMessageDeleteManyArgs>(
      args?: SelectSubset<T, ChatMessageDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChatMessageUpdateManyArgs>(
      args: SelectSubset<T, ChatMessageUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChatMessage.
     * @param {ChatMessageUpsertArgs} args - Arguments to update or create a ChatMessage.
     * @example
     * // Update or create a ChatMessage
     * const chatMessage = await prisma.chatMessage.upsert({
     *   create: {
     *     // ... data to create a ChatMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatMessage we want to update
     *   }
     * })
    **/
    upsert<T extends ChatMessageUpsertArgs>(
      args: SelectSubset<T, ChatMessageUpsertArgs>
    ): Prisma__ChatMessageClient<ChatMessageGetPayload<T>>

    /**
     * Count the number of ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageCountArgs} args - Arguments to filter ChatMessages to count.
     * @example
     * // Count the number of ChatMessages
     * const count = await prisma.chatMessage.count({
     *   where: {
     *     // ... the filter for the ChatMessages we want to count
     *   }
     * })
    **/
    count<T extends ChatMessageCountArgs>(
      args?: Subset<T, ChatMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatMessageAggregateArgs>(args: Subset<T, ChatMessageAggregateArgs>): Prisma.PrismaPromise<GetChatMessageAggregateType<T>>

    /**
     * Group by ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatMessageGroupByArgs['orderBy'] }
        : { orderBy?: ChatMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ChatMessageClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    author<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    chatSession<T extends ChatSessionArgs= {}>(args?: Subset<T, ChatSessionArgs>): Prisma__ChatSessionClient<ChatSessionGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ChatMessage base type for findUnique actions
   */
  export type ChatMessageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatMessageInclude | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findUnique
   */
  export interface ChatMessageFindUniqueArgs extends ChatMessageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ChatMessage findUniqueOrThrow
   */
  export type ChatMessageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatMessageInclude | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }


  /**
   * ChatMessage base type for findFirst actions
   */
  export type ChatMessageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatMessageInclude | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: Enumerable<ChatMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: Enumerable<ChatMessageScalarFieldEnum>
  }

  /**
   * ChatMessage findFirst
   */
  export interface ChatMessageFindFirstArgs extends ChatMessageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ChatMessage findFirstOrThrow
   */
  export type ChatMessageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatMessageInclude | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: Enumerable<ChatMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: Enumerable<ChatMessageScalarFieldEnum>
  }


  /**
   * ChatMessage findMany
   */
  export type ChatMessageFindManyArgs = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatMessageInclude | null
    /**
     * Filter, which ChatMessages to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: Enumerable<ChatMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    distinct?: Enumerable<ChatMessageScalarFieldEnum>
  }


  /**
   * ChatMessage create
   */
  export type ChatMessageCreateArgs = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatMessageInclude | null
    /**
     * The data needed to create a ChatMessage.
     */
    data: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
  }


  /**
   * ChatMessage createMany
   */
  export type ChatMessageCreateManyArgs = {
    /**
     * The data used to create many ChatMessages.
     */
    data: Enumerable<ChatMessageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ChatMessage update
   */
  export type ChatMessageUpdateArgs = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatMessageInclude | null
    /**
     * The data needed to update a ChatMessage.
     */
    data: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
    /**
     * Choose, which ChatMessage to update.
     */
    where: ChatMessageWhereUniqueInput
  }


  /**
   * ChatMessage updateMany
   */
  export type ChatMessageUpdateManyArgs = {
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
  }


  /**
   * ChatMessage upsert
   */
  export type ChatMessageUpsertArgs = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatMessageInclude | null
    /**
     * The filter to search for the ChatMessage to update in case it exists.
     */
    where: ChatMessageWhereUniqueInput
    /**
     * In case the ChatMessage found by the `where` argument doesn't exist, create a new ChatMessage with this data.
     */
    create: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
    /**
     * In case the ChatMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
  }


  /**
   * ChatMessage delete
   */
  export type ChatMessageDeleteArgs = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatMessageInclude | null
    /**
     * Filter which ChatMessage to delete.
     */
    where: ChatMessageWhereUniqueInput
  }


  /**
   * ChatMessage deleteMany
   */
  export type ChatMessageDeleteManyArgs = {
    /**
     * Filter which ChatMessages to delete
     */
    where?: ChatMessageWhereInput
  }


  /**
   * ChatMessage without action
   */
  export type ChatMessageArgs = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatMessageInclude | null
  }



  /**
   * Model GroupPostMessage
   */


  export type AggregateGroupPostMessage = {
    _count: GroupPostMessageCountAggregateOutputType | null
    _min: GroupPostMessageMinAggregateOutputType | null
    _max: GroupPostMessageMaxAggregateOutputType | null
  }

  export type GroupPostMessageMinAggregateOutputType = {
    id: string | null
    content: string | null
    authorId: string | null
    createdAt: Date | null
    postId: string | null
  }

  export type GroupPostMessageMaxAggregateOutputType = {
    id: string | null
    content: string | null
    authorId: string | null
    createdAt: Date | null
    postId: string | null
  }

  export type GroupPostMessageCountAggregateOutputType = {
    id: number
    content: number
    authorId: number
    createdAt: number
    referenceMessage: number
    postId: number
    _all: number
  }


  export type GroupPostMessageMinAggregateInputType = {
    id?: true
    content?: true
    authorId?: true
    createdAt?: true
    postId?: true
  }

  export type GroupPostMessageMaxAggregateInputType = {
    id?: true
    content?: true
    authorId?: true
    createdAt?: true
    postId?: true
  }

  export type GroupPostMessageCountAggregateInputType = {
    id?: true
    content?: true
    authorId?: true
    createdAt?: true
    referenceMessage?: true
    postId?: true
    _all?: true
  }

  export type GroupPostMessageAggregateArgs = {
    /**
     * Filter which GroupPostMessage to aggregate.
     */
    where?: GroupPostMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupPostMessages to fetch.
     */
    orderBy?: Enumerable<GroupPostMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupPostMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupPostMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupPostMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupPostMessages
    **/
    _count?: true | GroupPostMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupPostMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupPostMessageMaxAggregateInputType
  }

  export type GetGroupPostMessageAggregateType<T extends GroupPostMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupPostMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupPostMessage[P]>
      : GetScalarType<T[P], AggregateGroupPostMessage[P]>
  }




  export type GroupPostMessageGroupByArgs = {
    where?: GroupPostMessageWhereInput
    orderBy?: Enumerable<GroupPostMessageOrderByWithAggregationInput>
    by: GroupPostMessageScalarFieldEnum[]
    having?: GroupPostMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupPostMessageCountAggregateInputType | true
    _min?: GroupPostMessageMinAggregateInputType
    _max?: GroupPostMessageMaxAggregateInputType
  }


  export type GroupPostMessageGroupByOutputType = {
    id: string
    content: string
    authorId: string
    createdAt: Date
    referenceMessage: JsonValue | null
    postId: string
    _count: GroupPostMessageCountAggregateOutputType | null
    _min: GroupPostMessageMinAggregateOutputType | null
    _max: GroupPostMessageMaxAggregateOutputType | null
  }

  type GetGroupPostMessageGroupByPayload<T extends GroupPostMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<GroupPostMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupPostMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupPostMessageGroupByOutputType[P]>
            : GetScalarType<T[P], GroupPostMessageGroupByOutputType[P]>
        }
      >
    >


  export type GroupPostMessageSelect = {
    id?: boolean
    content?: boolean
    authorId?: boolean
    createdAt?: boolean
    referenceMessage?: boolean
    postId?: boolean
    author?: boolean | UserArgs
    post?: boolean | GroupPostArgs
  }


  export type GroupPostMessageInclude = {
    author?: boolean | UserArgs
    post?: boolean | GroupPostArgs
  }

  export type GroupPostMessageGetPayload<S extends boolean | null | undefined | GroupPostMessageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? GroupPostMessage :
    S extends undefined ? never :
    S extends { include: any } & (GroupPostMessageArgs | GroupPostMessageFindManyArgs)
    ? GroupPostMessage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'author' ? UserGetPayload<S['include'][P]> :
        P extends 'post' ? GroupPostGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (GroupPostMessageArgs | GroupPostMessageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'author' ? UserGetPayload<S['select'][P]> :
        P extends 'post' ? GroupPostGetPayload<S['select'][P]> :  P extends keyof GroupPostMessage ? GroupPostMessage[P] : never
  } 
      : GroupPostMessage


  type GroupPostMessageCountArgs = 
    Omit<GroupPostMessageFindManyArgs, 'select' | 'include'> & {
      select?: GroupPostMessageCountAggregateInputType | true
    }

  export interface GroupPostMessageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one GroupPostMessage that matches the filter.
     * @param {GroupPostMessageFindUniqueArgs} args - Arguments to find a GroupPostMessage
     * @example
     * // Get one GroupPostMessage
     * const groupPostMessage = await prisma.groupPostMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GroupPostMessageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GroupPostMessageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'GroupPostMessage'> extends True ? Prisma__GroupPostMessageClient<GroupPostMessageGetPayload<T>> : Prisma__GroupPostMessageClient<GroupPostMessageGetPayload<T> | null, null>

    /**
     * Find one GroupPostMessage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GroupPostMessageFindUniqueOrThrowArgs} args - Arguments to find a GroupPostMessage
     * @example
     * // Get one GroupPostMessage
     * const groupPostMessage = await prisma.groupPostMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GroupPostMessageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, GroupPostMessageFindUniqueOrThrowArgs>
    ): Prisma__GroupPostMessageClient<GroupPostMessageGetPayload<T>>

    /**
     * Find the first GroupPostMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupPostMessageFindFirstArgs} args - Arguments to find a GroupPostMessage
     * @example
     * // Get one GroupPostMessage
     * const groupPostMessage = await prisma.groupPostMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GroupPostMessageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GroupPostMessageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'GroupPostMessage'> extends True ? Prisma__GroupPostMessageClient<GroupPostMessageGetPayload<T>> : Prisma__GroupPostMessageClient<GroupPostMessageGetPayload<T> | null, null>

    /**
     * Find the first GroupPostMessage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupPostMessageFindFirstOrThrowArgs} args - Arguments to find a GroupPostMessage
     * @example
     * // Get one GroupPostMessage
     * const groupPostMessage = await prisma.groupPostMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GroupPostMessageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, GroupPostMessageFindFirstOrThrowArgs>
    ): Prisma__GroupPostMessageClient<GroupPostMessageGetPayload<T>>

    /**
     * Find zero or more GroupPostMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupPostMessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupPostMessages
     * const groupPostMessages = await prisma.groupPostMessage.findMany()
     * 
     * // Get first 10 GroupPostMessages
     * const groupPostMessages = await prisma.groupPostMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupPostMessageWithIdOnly = await prisma.groupPostMessage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GroupPostMessageFindManyArgs>(
      args?: SelectSubset<T, GroupPostMessageFindManyArgs>
    ): Prisma.PrismaPromise<Array<GroupPostMessageGetPayload<T>>>

    /**
     * Create a GroupPostMessage.
     * @param {GroupPostMessageCreateArgs} args - Arguments to create a GroupPostMessage.
     * @example
     * // Create one GroupPostMessage
     * const GroupPostMessage = await prisma.groupPostMessage.create({
     *   data: {
     *     // ... data to create a GroupPostMessage
     *   }
     * })
     * 
    **/
    create<T extends GroupPostMessageCreateArgs>(
      args: SelectSubset<T, GroupPostMessageCreateArgs>
    ): Prisma__GroupPostMessageClient<GroupPostMessageGetPayload<T>>

    /**
     * Create many GroupPostMessages.
     *     @param {GroupPostMessageCreateManyArgs} args - Arguments to create many GroupPostMessages.
     *     @example
     *     // Create many GroupPostMessages
     *     const groupPostMessage = await prisma.groupPostMessage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GroupPostMessageCreateManyArgs>(
      args?: SelectSubset<T, GroupPostMessageCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GroupPostMessage.
     * @param {GroupPostMessageDeleteArgs} args - Arguments to delete one GroupPostMessage.
     * @example
     * // Delete one GroupPostMessage
     * const GroupPostMessage = await prisma.groupPostMessage.delete({
     *   where: {
     *     // ... filter to delete one GroupPostMessage
     *   }
     * })
     * 
    **/
    delete<T extends GroupPostMessageDeleteArgs>(
      args: SelectSubset<T, GroupPostMessageDeleteArgs>
    ): Prisma__GroupPostMessageClient<GroupPostMessageGetPayload<T>>

    /**
     * Update one GroupPostMessage.
     * @param {GroupPostMessageUpdateArgs} args - Arguments to update one GroupPostMessage.
     * @example
     * // Update one GroupPostMessage
     * const groupPostMessage = await prisma.groupPostMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GroupPostMessageUpdateArgs>(
      args: SelectSubset<T, GroupPostMessageUpdateArgs>
    ): Prisma__GroupPostMessageClient<GroupPostMessageGetPayload<T>>

    /**
     * Delete zero or more GroupPostMessages.
     * @param {GroupPostMessageDeleteManyArgs} args - Arguments to filter GroupPostMessages to delete.
     * @example
     * // Delete a few GroupPostMessages
     * const { count } = await prisma.groupPostMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GroupPostMessageDeleteManyArgs>(
      args?: SelectSubset<T, GroupPostMessageDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupPostMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupPostMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupPostMessages
     * const groupPostMessage = await prisma.groupPostMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GroupPostMessageUpdateManyArgs>(
      args: SelectSubset<T, GroupPostMessageUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GroupPostMessage.
     * @param {GroupPostMessageUpsertArgs} args - Arguments to update or create a GroupPostMessage.
     * @example
     * // Update or create a GroupPostMessage
     * const groupPostMessage = await prisma.groupPostMessage.upsert({
     *   create: {
     *     // ... data to create a GroupPostMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupPostMessage we want to update
     *   }
     * })
    **/
    upsert<T extends GroupPostMessageUpsertArgs>(
      args: SelectSubset<T, GroupPostMessageUpsertArgs>
    ): Prisma__GroupPostMessageClient<GroupPostMessageGetPayload<T>>

    /**
     * Count the number of GroupPostMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupPostMessageCountArgs} args - Arguments to filter GroupPostMessages to count.
     * @example
     * // Count the number of GroupPostMessages
     * const count = await prisma.groupPostMessage.count({
     *   where: {
     *     // ... the filter for the GroupPostMessages we want to count
     *   }
     * })
    **/
    count<T extends GroupPostMessageCountArgs>(
      args?: Subset<T, GroupPostMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupPostMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupPostMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupPostMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupPostMessageAggregateArgs>(args: Subset<T, GroupPostMessageAggregateArgs>): Prisma.PrismaPromise<GetGroupPostMessageAggregateType<T>>

    /**
     * Group by GroupPostMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupPostMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupPostMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupPostMessageGroupByArgs['orderBy'] }
        : { orderBy?: GroupPostMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupPostMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupPostMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupPostMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GroupPostMessageClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    author<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    post<T extends GroupPostArgs= {}>(args?: Subset<T, GroupPostArgs>): Prisma__GroupPostClient<GroupPostGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * GroupPostMessage base type for findUnique actions
   */
  export type GroupPostMessageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the GroupPostMessage
     */
    select?: GroupPostMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupPostMessageInclude | null
    /**
     * Filter, which GroupPostMessage to fetch.
     */
    where: GroupPostMessageWhereUniqueInput
  }

  /**
   * GroupPostMessage findUnique
   */
  export interface GroupPostMessageFindUniqueArgs extends GroupPostMessageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * GroupPostMessage findUniqueOrThrow
   */
  export type GroupPostMessageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the GroupPostMessage
     */
    select?: GroupPostMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupPostMessageInclude | null
    /**
     * Filter, which GroupPostMessage to fetch.
     */
    where: GroupPostMessageWhereUniqueInput
  }


  /**
   * GroupPostMessage base type for findFirst actions
   */
  export type GroupPostMessageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the GroupPostMessage
     */
    select?: GroupPostMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupPostMessageInclude | null
    /**
     * Filter, which GroupPostMessage to fetch.
     */
    where?: GroupPostMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupPostMessages to fetch.
     */
    orderBy?: Enumerable<GroupPostMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupPostMessages.
     */
    cursor?: GroupPostMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupPostMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupPostMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupPostMessages.
     */
    distinct?: Enumerable<GroupPostMessageScalarFieldEnum>
  }

  /**
   * GroupPostMessage findFirst
   */
  export interface GroupPostMessageFindFirstArgs extends GroupPostMessageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * GroupPostMessage findFirstOrThrow
   */
  export type GroupPostMessageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the GroupPostMessage
     */
    select?: GroupPostMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupPostMessageInclude | null
    /**
     * Filter, which GroupPostMessage to fetch.
     */
    where?: GroupPostMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupPostMessages to fetch.
     */
    orderBy?: Enumerable<GroupPostMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupPostMessages.
     */
    cursor?: GroupPostMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupPostMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupPostMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupPostMessages.
     */
    distinct?: Enumerable<GroupPostMessageScalarFieldEnum>
  }


  /**
   * GroupPostMessage findMany
   */
  export type GroupPostMessageFindManyArgs = {
    /**
     * Select specific fields to fetch from the GroupPostMessage
     */
    select?: GroupPostMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupPostMessageInclude | null
    /**
     * Filter, which GroupPostMessages to fetch.
     */
    where?: GroupPostMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupPostMessages to fetch.
     */
    orderBy?: Enumerable<GroupPostMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupPostMessages.
     */
    cursor?: GroupPostMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupPostMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupPostMessages.
     */
    skip?: number
    distinct?: Enumerable<GroupPostMessageScalarFieldEnum>
  }


  /**
   * GroupPostMessage create
   */
  export type GroupPostMessageCreateArgs = {
    /**
     * Select specific fields to fetch from the GroupPostMessage
     */
    select?: GroupPostMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupPostMessageInclude | null
    /**
     * The data needed to create a GroupPostMessage.
     */
    data: XOR<GroupPostMessageCreateInput, GroupPostMessageUncheckedCreateInput>
  }


  /**
   * GroupPostMessage createMany
   */
  export type GroupPostMessageCreateManyArgs = {
    /**
     * The data used to create many GroupPostMessages.
     */
    data: Enumerable<GroupPostMessageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * GroupPostMessage update
   */
  export type GroupPostMessageUpdateArgs = {
    /**
     * Select specific fields to fetch from the GroupPostMessage
     */
    select?: GroupPostMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupPostMessageInclude | null
    /**
     * The data needed to update a GroupPostMessage.
     */
    data: XOR<GroupPostMessageUpdateInput, GroupPostMessageUncheckedUpdateInput>
    /**
     * Choose, which GroupPostMessage to update.
     */
    where: GroupPostMessageWhereUniqueInput
  }


  /**
   * GroupPostMessage updateMany
   */
  export type GroupPostMessageUpdateManyArgs = {
    /**
     * The data used to update GroupPostMessages.
     */
    data: XOR<GroupPostMessageUpdateManyMutationInput, GroupPostMessageUncheckedUpdateManyInput>
    /**
     * Filter which GroupPostMessages to update
     */
    where?: GroupPostMessageWhereInput
  }


  /**
   * GroupPostMessage upsert
   */
  export type GroupPostMessageUpsertArgs = {
    /**
     * Select specific fields to fetch from the GroupPostMessage
     */
    select?: GroupPostMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupPostMessageInclude | null
    /**
     * The filter to search for the GroupPostMessage to update in case it exists.
     */
    where: GroupPostMessageWhereUniqueInput
    /**
     * In case the GroupPostMessage found by the `where` argument doesn't exist, create a new GroupPostMessage with this data.
     */
    create: XOR<GroupPostMessageCreateInput, GroupPostMessageUncheckedCreateInput>
    /**
     * In case the GroupPostMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupPostMessageUpdateInput, GroupPostMessageUncheckedUpdateInput>
  }


  /**
   * GroupPostMessage delete
   */
  export type GroupPostMessageDeleteArgs = {
    /**
     * Select specific fields to fetch from the GroupPostMessage
     */
    select?: GroupPostMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupPostMessageInclude | null
    /**
     * Filter which GroupPostMessage to delete.
     */
    where: GroupPostMessageWhereUniqueInput
  }


  /**
   * GroupPostMessage deleteMany
   */
  export type GroupPostMessageDeleteManyArgs = {
    /**
     * Filter which GroupPostMessages to delete
     */
    where?: GroupPostMessageWhereInput
  }


  /**
   * GroupPostMessage without action
   */
  export type GroupPostMessageArgs = {
    /**
     * Select specific fields to fetch from the GroupPostMessage
     */
    select?: GroupPostMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupPostMessageInclude | null
  }



  /**
   * Model ChatSession
   */


  export type AggregateChatSession = {
    _count: ChatSessionCountAggregateOutputType | null
    _min: ChatSessionMinAggregateOutputType | null
    _max: ChatSessionMaxAggregateOutputType | null
  }

  export type ChatSessionMinAggregateOutputType = {
    id: string | null
    lastUpdate: Date | null
    groupId: string | null
    type: ChatSessionType | null
  }

  export type ChatSessionMaxAggregateOutputType = {
    id: string | null
    lastUpdate: Date | null
    groupId: string | null
    type: ChatSessionType | null
  }

  export type ChatSessionCountAggregateOutputType = {
    id: number
    lastMessage: number
    lastUpdate: number
    groupId: number
    type: number
    usersInfo: number
    _all: number
  }


  export type ChatSessionMinAggregateInputType = {
    id?: true
    lastUpdate?: true
    groupId?: true
    type?: true
  }

  export type ChatSessionMaxAggregateInputType = {
    id?: true
    lastUpdate?: true
    groupId?: true
    type?: true
  }

  export type ChatSessionCountAggregateInputType = {
    id?: true
    lastMessage?: true
    lastUpdate?: true
    groupId?: true
    type?: true
    usersInfo?: true
    _all?: true
  }

  export type ChatSessionAggregateArgs = {
    /**
     * Filter which ChatSession to aggregate.
     */
    where?: ChatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessions to fetch.
     */
    orderBy?: Enumerable<ChatSessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatSessions
    **/
    _count?: true | ChatSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatSessionMaxAggregateInputType
  }

  export type GetChatSessionAggregateType<T extends ChatSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateChatSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatSession[P]>
      : GetScalarType<T[P], AggregateChatSession[P]>
  }




  export type ChatSessionGroupByArgs = {
    where?: ChatSessionWhereInput
    orderBy?: Enumerable<ChatSessionOrderByWithAggregationInput>
    by: ChatSessionScalarFieldEnum[]
    having?: ChatSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatSessionCountAggregateInputType | true
    _min?: ChatSessionMinAggregateInputType
    _max?: ChatSessionMaxAggregateInputType
  }


  export type ChatSessionGroupByOutputType = {
    id: string
    lastMessage: JsonValue
    lastUpdate: Date
    groupId: string | null
    type: ChatSessionType
    usersInfo: JsonValue | null
    _count: ChatSessionCountAggregateOutputType | null
    _min: ChatSessionMinAggregateOutputType | null
    _max: ChatSessionMaxAggregateOutputType | null
  }

  type GetChatSessionGroupByPayload<T extends ChatSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ChatSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatSessionGroupByOutputType[P]>
            : GetScalarType<T[P], ChatSessionGroupByOutputType[P]>
        }
      >
    >


  export type ChatSessionSelect = {
    id?: boolean
    lastMessage?: boolean
    lastUpdate?: boolean
    groupId?: boolean
    type?: boolean
    usersInfo?: boolean
    chatMessages?: boolean | ChatSession$chatMessagesArgs
    users?: boolean | ChatSession$usersArgs
    _count?: boolean | ChatSessionCountOutputTypeArgs
  }


  export type ChatSessionInclude = {
    chatMessages?: boolean | ChatSession$chatMessagesArgs
    users?: boolean | ChatSession$usersArgs
    _count?: boolean | ChatSessionCountOutputTypeArgs
  }

  export type ChatSessionGetPayload<S extends boolean | null | undefined | ChatSessionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ChatSession :
    S extends undefined ? never :
    S extends { include: any } & (ChatSessionArgs | ChatSessionFindManyArgs)
    ? ChatSession  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'chatMessages' ? Array < ChatMessageGetPayload<S['include'][P]>>  :
        P extends 'users' ? Array < ChatSessionUserGetPayload<S['include'][P]>>  :
        P extends '_count' ? ChatSessionCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ChatSessionArgs | ChatSessionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'chatMessages' ? Array < ChatMessageGetPayload<S['select'][P]>>  :
        P extends 'users' ? Array < ChatSessionUserGetPayload<S['select'][P]>>  :
        P extends '_count' ? ChatSessionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ChatSession ? ChatSession[P] : never
  } 
      : ChatSession


  type ChatSessionCountArgs = 
    Omit<ChatSessionFindManyArgs, 'select' | 'include'> & {
      select?: ChatSessionCountAggregateInputType | true
    }

  export interface ChatSessionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ChatSession that matches the filter.
     * @param {ChatSessionFindUniqueArgs} args - Arguments to find a ChatSession
     * @example
     * // Get one ChatSession
     * const chatSession = await prisma.chatSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChatSessionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ChatSessionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ChatSession'> extends True ? Prisma__ChatSessionClient<ChatSessionGetPayload<T>> : Prisma__ChatSessionClient<ChatSessionGetPayload<T> | null, null>

    /**
     * Find one ChatSession that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ChatSessionFindUniqueOrThrowArgs} args - Arguments to find a ChatSession
     * @example
     * // Get one ChatSession
     * const chatSession = await prisma.chatSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ChatSessionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ChatSessionFindUniqueOrThrowArgs>
    ): Prisma__ChatSessionClient<ChatSessionGetPayload<T>>

    /**
     * Find the first ChatSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionFindFirstArgs} args - Arguments to find a ChatSession
     * @example
     * // Get one ChatSession
     * const chatSession = await prisma.chatSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChatSessionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ChatSessionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ChatSession'> extends True ? Prisma__ChatSessionClient<ChatSessionGetPayload<T>> : Prisma__ChatSessionClient<ChatSessionGetPayload<T> | null, null>

    /**
     * Find the first ChatSession that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionFindFirstOrThrowArgs} args - Arguments to find a ChatSession
     * @example
     * // Get one ChatSession
     * const chatSession = await prisma.chatSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ChatSessionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ChatSessionFindFirstOrThrowArgs>
    ): Prisma__ChatSessionClient<ChatSessionGetPayload<T>>

    /**
     * Find zero or more ChatSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatSessions
     * const chatSessions = await prisma.chatSession.findMany()
     * 
     * // Get first 10 ChatSessions
     * const chatSessions = await prisma.chatSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatSessionWithIdOnly = await prisma.chatSession.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ChatSessionFindManyArgs>(
      args?: SelectSubset<T, ChatSessionFindManyArgs>
    ): Prisma.PrismaPromise<Array<ChatSessionGetPayload<T>>>

    /**
     * Create a ChatSession.
     * @param {ChatSessionCreateArgs} args - Arguments to create a ChatSession.
     * @example
     * // Create one ChatSession
     * const ChatSession = await prisma.chatSession.create({
     *   data: {
     *     // ... data to create a ChatSession
     *   }
     * })
     * 
    **/
    create<T extends ChatSessionCreateArgs>(
      args: SelectSubset<T, ChatSessionCreateArgs>
    ): Prisma__ChatSessionClient<ChatSessionGetPayload<T>>

    /**
     * Create many ChatSessions.
     *     @param {ChatSessionCreateManyArgs} args - Arguments to create many ChatSessions.
     *     @example
     *     // Create many ChatSessions
     *     const chatSession = await prisma.chatSession.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChatSessionCreateManyArgs>(
      args?: SelectSubset<T, ChatSessionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChatSession.
     * @param {ChatSessionDeleteArgs} args - Arguments to delete one ChatSession.
     * @example
     * // Delete one ChatSession
     * const ChatSession = await prisma.chatSession.delete({
     *   where: {
     *     // ... filter to delete one ChatSession
     *   }
     * })
     * 
    **/
    delete<T extends ChatSessionDeleteArgs>(
      args: SelectSubset<T, ChatSessionDeleteArgs>
    ): Prisma__ChatSessionClient<ChatSessionGetPayload<T>>

    /**
     * Update one ChatSession.
     * @param {ChatSessionUpdateArgs} args - Arguments to update one ChatSession.
     * @example
     * // Update one ChatSession
     * const chatSession = await prisma.chatSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChatSessionUpdateArgs>(
      args: SelectSubset<T, ChatSessionUpdateArgs>
    ): Prisma__ChatSessionClient<ChatSessionGetPayload<T>>

    /**
     * Delete zero or more ChatSessions.
     * @param {ChatSessionDeleteManyArgs} args - Arguments to filter ChatSessions to delete.
     * @example
     * // Delete a few ChatSessions
     * const { count } = await prisma.chatSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChatSessionDeleteManyArgs>(
      args?: SelectSubset<T, ChatSessionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatSessions
     * const chatSession = await prisma.chatSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChatSessionUpdateManyArgs>(
      args: SelectSubset<T, ChatSessionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChatSession.
     * @param {ChatSessionUpsertArgs} args - Arguments to update or create a ChatSession.
     * @example
     * // Update or create a ChatSession
     * const chatSession = await prisma.chatSession.upsert({
     *   create: {
     *     // ... data to create a ChatSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatSession we want to update
     *   }
     * })
    **/
    upsert<T extends ChatSessionUpsertArgs>(
      args: SelectSubset<T, ChatSessionUpsertArgs>
    ): Prisma__ChatSessionClient<ChatSessionGetPayload<T>>

    /**
     * Count the number of ChatSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionCountArgs} args - Arguments to filter ChatSessions to count.
     * @example
     * // Count the number of ChatSessions
     * const count = await prisma.chatSession.count({
     *   where: {
     *     // ... the filter for the ChatSessions we want to count
     *   }
     * })
    **/
    count<T extends ChatSessionCountArgs>(
      args?: Subset<T, ChatSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatSessionAggregateArgs>(args: Subset<T, ChatSessionAggregateArgs>): Prisma.PrismaPromise<GetChatSessionAggregateType<T>>

    /**
     * Group by ChatSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatSessionGroupByArgs['orderBy'] }
        : { orderBy?: ChatSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ChatSessionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    chatMessages<T extends ChatSession$chatMessagesArgs= {}>(args?: Subset<T, ChatSession$chatMessagesArgs>): Prisma.PrismaPromise<Array<ChatMessageGetPayload<T>>| Null>;

    users<T extends ChatSession$usersArgs= {}>(args?: Subset<T, ChatSession$usersArgs>): Prisma.PrismaPromise<Array<ChatSessionUserGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ChatSession base type for findUnique actions
   */
  export type ChatSessionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatSessionInclude | null
    /**
     * Filter, which ChatSession to fetch.
     */
    where: ChatSessionWhereUniqueInput
  }

  /**
   * ChatSession findUnique
   */
  export interface ChatSessionFindUniqueArgs extends ChatSessionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ChatSession findUniqueOrThrow
   */
  export type ChatSessionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatSessionInclude | null
    /**
     * Filter, which ChatSession to fetch.
     */
    where: ChatSessionWhereUniqueInput
  }


  /**
   * ChatSession base type for findFirst actions
   */
  export type ChatSessionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatSessionInclude | null
    /**
     * Filter, which ChatSession to fetch.
     */
    where?: ChatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessions to fetch.
     */
    orderBy?: Enumerable<ChatSessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatSessions.
     */
    cursor?: ChatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatSessions.
     */
    distinct?: Enumerable<ChatSessionScalarFieldEnum>
  }

  /**
   * ChatSession findFirst
   */
  export interface ChatSessionFindFirstArgs extends ChatSessionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ChatSession findFirstOrThrow
   */
  export type ChatSessionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatSessionInclude | null
    /**
     * Filter, which ChatSession to fetch.
     */
    where?: ChatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessions to fetch.
     */
    orderBy?: Enumerable<ChatSessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatSessions.
     */
    cursor?: ChatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatSessions.
     */
    distinct?: Enumerable<ChatSessionScalarFieldEnum>
  }


  /**
   * ChatSession findMany
   */
  export type ChatSessionFindManyArgs = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatSessionInclude | null
    /**
     * Filter, which ChatSessions to fetch.
     */
    where?: ChatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessions to fetch.
     */
    orderBy?: Enumerable<ChatSessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatSessions.
     */
    cursor?: ChatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessions.
     */
    skip?: number
    distinct?: Enumerable<ChatSessionScalarFieldEnum>
  }


  /**
   * ChatSession create
   */
  export type ChatSessionCreateArgs = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatSessionInclude | null
    /**
     * The data needed to create a ChatSession.
     */
    data: XOR<ChatSessionCreateInput, ChatSessionUncheckedCreateInput>
  }


  /**
   * ChatSession createMany
   */
  export type ChatSessionCreateManyArgs = {
    /**
     * The data used to create many ChatSessions.
     */
    data: Enumerable<ChatSessionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ChatSession update
   */
  export type ChatSessionUpdateArgs = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatSessionInclude | null
    /**
     * The data needed to update a ChatSession.
     */
    data: XOR<ChatSessionUpdateInput, ChatSessionUncheckedUpdateInput>
    /**
     * Choose, which ChatSession to update.
     */
    where: ChatSessionWhereUniqueInput
  }


  /**
   * ChatSession updateMany
   */
  export type ChatSessionUpdateManyArgs = {
    /**
     * The data used to update ChatSessions.
     */
    data: XOR<ChatSessionUpdateManyMutationInput, ChatSessionUncheckedUpdateManyInput>
    /**
     * Filter which ChatSessions to update
     */
    where?: ChatSessionWhereInput
  }


  /**
   * ChatSession upsert
   */
  export type ChatSessionUpsertArgs = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatSessionInclude | null
    /**
     * The filter to search for the ChatSession to update in case it exists.
     */
    where: ChatSessionWhereUniqueInput
    /**
     * In case the ChatSession found by the `where` argument doesn't exist, create a new ChatSession with this data.
     */
    create: XOR<ChatSessionCreateInput, ChatSessionUncheckedCreateInput>
    /**
     * In case the ChatSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatSessionUpdateInput, ChatSessionUncheckedUpdateInput>
  }


  /**
   * ChatSession delete
   */
  export type ChatSessionDeleteArgs = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatSessionInclude | null
    /**
     * Filter which ChatSession to delete.
     */
    where: ChatSessionWhereUniqueInput
  }


  /**
   * ChatSession deleteMany
   */
  export type ChatSessionDeleteManyArgs = {
    /**
     * Filter which ChatSessions to delete
     */
    where?: ChatSessionWhereInput
  }


  /**
   * ChatSession.chatMessages
   */
  export type ChatSession$chatMessagesArgs = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatMessageInclude | null
    where?: ChatMessageWhereInput
    orderBy?: Enumerable<ChatMessageOrderByWithRelationInput>
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ChatMessageScalarFieldEnum>
  }


  /**
   * ChatSession.users
   */
  export type ChatSession$usersArgs = {
    /**
     * Select specific fields to fetch from the ChatSessionUser
     */
    select?: ChatSessionUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatSessionUserInclude | null
    where?: ChatSessionUserWhereInput
    orderBy?: Enumerable<ChatSessionUserOrderByWithRelationInput>
    cursor?: ChatSessionUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ChatSessionUserScalarFieldEnum>
  }


  /**
   * ChatSession without action
   */
  export type ChatSessionArgs = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatSessionInclude | null
  }



  /**
   * Model ChatSessionUser
   */


  export type AggregateChatSessionUser = {
    _count: ChatSessionUserCountAggregateOutputType | null
    _avg: ChatSessionUserAvgAggregateOutputType | null
    _sum: ChatSessionUserSumAggregateOutputType | null
    _min: ChatSessionUserMinAggregateOutputType | null
    _max: ChatSessionUserMaxAggregateOutputType | null
  }

  export type ChatSessionUserAvgAggregateOutputType = {
    unseenCnt: number | null
  }

  export type ChatSessionUserSumAggregateOutputType = {
    unseenCnt: number | null
  }

  export type ChatSessionUserMinAggregateOutputType = {
    sessionId: string | null
    username: string | null
    unseenCnt: number | null
    joinedAt: Date | null
  }

  export type ChatSessionUserMaxAggregateOutputType = {
    sessionId: string | null
    username: string | null
    unseenCnt: number | null
    joinedAt: Date | null
  }

  export type ChatSessionUserCountAggregateOutputType = {
    sessionId: number
    username: number
    unseenCnt: number
    joinedAt: number
    _all: number
  }


  export type ChatSessionUserAvgAggregateInputType = {
    unseenCnt?: true
  }

  export type ChatSessionUserSumAggregateInputType = {
    unseenCnt?: true
  }

  export type ChatSessionUserMinAggregateInputType = {
    sessionId?: true
    username?: true
    unseenCnt?: true
    joinedAt?: true
  }

  export type ChatSessionUserMaxAggregateInputType = {
    sessionId?: true
    username?: true
    unseenCnt?: true
    joinedAt?: true
  }

  export type ChatSessionUserCountAggregateInputType = {
    sessionId?: true
    username?: true
    unseenCnt?: true
    joinedAt?: true
    _all?: true
  }

  export type ChatSessionUserAggregateArgs = {
    /**
     * Filter which ChatSessionUser to aggregate.
     */
    where?: ChatSessionUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessionUsers to fetch.
     */
    orderBy?: Enumerable<ChatSessionUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatSessionUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessionUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessionUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatSessionUsers
    **/
    _count?: true | ChatSessionUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatSessionUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatSessionUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatSessionUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatSessionUserMaxAggregateInputType
  }

  export type GetChatSessionUserAggregateType<T extends ChatSessionUserAggregateArgs> = {
        [P in keyof T & keyof AggregateChatSessionUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatSessionUser[P]>
      : GetScalarType<T[P], AggregateChatSessionUser[P]>
  }




  export type ChatSessionUserGroupByArgs = {
    where?: ChatSessionUserWhereInput
    orderBy?: Enumerable<ChatSessionUserOrderByWithAggregationInput>
    by: ChatSessionUserScalarFieldEnum[]
    having?: ChatSessionUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatSessionUserCountAggregateInputType | true
    _avg?: ChatSessionUserAvgAggregateInputType
    _sum?: ChatSessionUserSumAggregateInputType
    _min?: ChatSessionUserMinAggregateInputType
    _max?: ChatSessionUserMaxAggregateInputType
  }


  export type ChatSessionUserGroupByOutputType = {
    sessionId: string
    username: string
    unseenCnt: number
    joinedAt: Date
    _count: ChatSessionUserCountAggregateOutputType | null
    _avg: ChatSessionUserAvgAggregateOutputType | null
    _sum: ChatSessionUserSumAggregateOutputType | null
    _min: ChatSessionUserMinAggregateOutputType | null
    _max: ChatSessionUserMaxAggregateOutputType | null
  }

  type GetChatSessionUserGroupByPayload<T extends ChatSessionUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ChatSessionUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatSessionUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatSessionUserGroupByOutputType[P]>
            : GetScalarType<T[P], ChatSessionUserGroupByOutputType[P]>
        }
      >
    >


  export type ChatSessionUserSelect = {
    sessionId?: boolean
    username?: boolean
    unseenCnt?: boolean
    joinedAt?: boolean
    chatSession?: boolean | ChatSessionArgs
    user?: boolean | UserArgs
  }


  export type ChatSessionUserInclude = {
    chatSession?: boolean | ChatSessionArgs
    user?: boolean | UserArgs
  }

  export type ChatSessionUserGetPayload<S extends boolean | null | undefined | ChatSessionUserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ChatSessionUser :
    S extends undefined ? never :
    S extends { include: any } & (ChatSessionUserArgs | ChatSessionUserFindManyArgs)
    ? ChatSessionUser  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'chatSession' ? ChatSessionGetPayload<S['include'][P]> :
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ChatSessionUserArgs | ChatSessionUserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'chatSession' ? ChatSessionGetPayload<S['select'][P]> :
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof ChatSessionUser ? ChatSessionUser[P] : never
  } 
      : ChatSessionUser


  type ChatSessionUserCountArgs = 
    Omit<ChatSessionUserFindManyArgs, 'select' | 'include'> & {
      select?: ChatSessionUserCountAggregateInputType | true
    }

  export interface ChatSessionUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ChatSessionUser that matches the filter.
     * @param {ChatSessionUserFindUniqueArgs} args - Arguments to find a ChatSessionUser
     * @example
     * // Get one ChatSessionUser
     * const chatSessionUser = await prisma.chatSessionUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChatSessionUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ChatSessionUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ChatSessionUser'> extends True ? Prisma__ChatSessionUserClient<ChatSessionUserGetPayload<T>> : Prisma__ChatSessionUserClient<ChatSessionUserGetPayload<T> | null, null>

    /**
     * Find one ChatSessionUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ChatSessionUserFindUniqueOrThrowArgs} args - Arguments to find a ChatSessionUser
     * @example
     * // Get one ChatSessionUser
     * const chatSessionUser = await prisma.chatSessionUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ChatSessionUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ChatSessionUserFindUniqueOrThrowArgs>
    ): Prisma__ChatSessionUserClient<ChatSessionUserGetPayload<T>>

    /**
     * Find the first ChatSessionUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionUserFindFirstArgs} args - Arguments to find a ChatSessionUser
     * @example
     * // Get one ChatSessionUser
     * const chatSessionUser = await prisma.chatSessionUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChatSessionUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ChatSessionUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ChatSessionUser'> extends True ? Prisma__ChatSessionUserClient<ChatSessionUserGetPayload<T>> : Prisma__ChatSessionUserClient<ChatSessionUserGetPayload<T> | null, null>

    /**
     * Find the first ChatSessionUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionUserFindFirstOrThrowArgs} args - Arguments to find a ChatSessionUser
     * @example
     * // Get one ChatSessionUser
     * const chatSessionUser = await prisma.chatSessionUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ChatSessionUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ChatSessionUserFindFirstOrThrowArgs>
    ): Prisma__ChatSessionUserClient<ChatSessionUserGetPayload<T>>

    /**
     * Find zero or more ChatSessionUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatSessionUsers
     * const chatSessionUsers = await prisma.chatSessionUser.findMany()
     * 
     * // Get first 10 ChatSessionUsers
     * const chatSessionUsers = await prisma.chatSessionUser.findMany({ take: 10 })
     * 
     * // Only select the `sessionId`
     * const chatSessionUserWithSessionIdOnly = await prisma.chatSessionUser.findMany({ select: { sessionId: true } })
     * 
    **/
    findMany<T extends ChatSessionUserFindManyArgs>(
      args?: SelectSubset<T, ChatSessionUserFindManyArgs>
    ): Prisma.PrismaPromise<Array<ChatSessionUserGetPayload<T>>>

    /**
     * Create a ChatSessionUser.
     * @param {ChatSessionUserCreateArgs} args - Arguments to create a ChatSessionUser.
     * @example
     * // Create one ChatSessionUser
     * const ChatSessionUser = await prisma.chatSessionUser.create({
     *   data: {
     *     // ... data to create a ChatSessionUser
     *   }
     * })
     * 
    **/
    create<T extends ChatSessionUserCreateArgs>(
      args: SelectSubset<T, ChatSessionUserCreateArgs>
    ): Prisma__ChatSessionUserClient<ChatSessionUserGetPayload<T>>

    /**
     * Create many ChatSessionUsers.
     *     @param {ChatSessionUserCreateManyArgs} args - Arguments to create many ChatSessionUsers.
     *     @example
     *     // Create many ChatSessionUsers
     *     const chatSessionUser = await prisma.chatSessionUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChatSessionUserCreateManyArgs>(
      args?: SelectSubset<T, ChatSessionUserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChatSessionUser.
     * @param {ChatSessionUserDeleteArgs} args - Arguments to delete one ChatSessionUser.
     * @example
     * // Delete one ChatSessionUser
     * const ChatSessionUser = await prisma.chatSessionUser.delete({
     *   where: {
     *     // ... filter to delete one ChatSessionUser
     *   }
     * })
     * 
    **/
    delete<T extends ChatSessionUserDeleteArgs>(
      args: SelectSubset<T, ChatSessionUserDeleteArgs>
    ): Prisma__ChatSessionUserClient<ChatSessionUserGetPayload<T>>

    /**
     * Update one ChatSessionUser.
     * @param {ChatSessionUserUpdateArgs} args - Arguments to update one ChatSessionUser.
     * @example
     * // Update one ChatSessionUser
     * const chatSessionUser = await prisma.chatSessionUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChatSessionUserUpdateArgs>(
      args: SelectSubset<T, ChatSessionUserUpdateArgs>
    ): Prisma__ChatSessionUserClient<ChatSessionUserGetPayload<T>>

    /**
     * Delete zero or more ChatSessionUsers.
     * @param {ChatSessionUserDeleteManyArgs} args - Arguments to filter ChatSessionUsers to delete.
     * @example
     * // Delete a few ChatSessionUsers
     * const { count } = await prisma.chatSessionUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChatSessionUserDeleteManyArgs>(
      args?: SelectSubset<T, ChatSessionUserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatSessionUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatSessionUsers
     * const chatSessionUser = await prisma.chatSessionUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChatSessionUserUpdateManyArgs>(
      args: SelectSubset<T, ChatSessionUserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChatSessionUser.
     * @param {ChatSessionUserUpsertArgs} args - Arguments to update or create a ChatSessionUser.
     * @example
     * // Update or create a ChatSessionUser
     * const chatSessionUser = await prisma.chatSessionUser.upsert({
     *   create: {
     *     // ... data to create a ChatSessionUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatSessionUser we want to update
     *   }
     * })
    **/
    upsert<T extends ChatSessionUserUpsertArgs>(
      args: SelectSubset<T, ChatSessionUserUpsertArgs>
    ): Prisma__ChatSessionUserClient<ChatSessionUserGetPayload<T>>

    /**
     * Count the number of ChatSessionUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionUserCountArgs} args - Arguments to filter ChatSessionUsers to count.
     * @example
     * // Count the number of ChatSessionUsers
     * const count = await prisma.chatSessionUser.count({
     *   where: {
     *     // ... the filter for the ChatSessionUsers we want to count
     *   }
     * })
    **/
    count<T extends ChatSessionUserCountArgs>(
      args?: Subset<T, ChatSessionUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatSessionUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatSessionUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatSessionUserAggregateArgs>(args: Subset<T, ChatSessionUserAggregateArgs>): Prisma.PrismaPromise<GetChatSessionUserAggregateType<T>>

    /**
     * Group by ChatSessionUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatSessionUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatSessionUserGroupByArgs['orderBy'] }
        : { orderBy?: ChatSessionUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatSessionUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatSessionUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatSessionUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ChatSessionUserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    chatSession<T extends ChatSessionArgs= {}>(args?: Subset<T, ChatSessionArgs>): Prisma__ChatSessionClient<ChatSessionGetPayload<T> | Null>;

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ChatSessionUser base type for findUnique actions
   */
  export type ChatSessionUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ChatSessionUser
     */
    select?: ChatSessionUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatSessionUserInclude | null
    /**
     * Filter, which ChatSessionUser to fetch.
     */
    where: ChatSessionUserWhereUniqueInput
  }

  /**
   * ChatSessionUser findUnique
   */
  export interface ChatSessionUserFindUniqueArgs extends ChatSessionUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ChatSessionUser findUniqueOrThrow
   */
  export type ChatSessionUserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ChatSessionUser
     */
    select?: ChatSessionUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatSessionUserInclude | null
    /**
     * Filter, which ChatSessionUser to fetch.
     */
    where: ChatSessionUserWhereUniqueInput
  }


  /**
   * ChatSessionUser base type for findFirst actions
   */
  export type ChatSessionUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ChatSessionUser
     */
    select?: ChatSessionUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatSessionUserInclude | null
    /**
     * Filter, which ChatSessionUser to fetch.
     */
    where?: ChatSessionUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessionUsers to fetch.
     */
    orderBy?: Enumerable<ChatSessionUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatSessionUsers.
     */
    cursor?: ChatSessionUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessionUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessionUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatSessionUsers.
     */
    distinct?: Enumerable<ChatSessionUserScalarFieldEnum>
  }

  /**
   * ChatSessionUser findFirst
   */
  export interface ChatSessionUserFindFirstArgs extends ChatSessionUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ChatSessionUser findFirstOrThrow
   */
  export type ChatSessionUserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ChatSessionUser
     */
    select?: ChatSessionUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatSessionUserInclude | null
    /**
     * Filter, which ChatSessionUser to fetch.
     */
    where?: ChatSessionUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessionUsers to fetch.
     */
    orderBy?: Enumerable<ChatSessionUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatSessionUsers.
     */
    cursor?: ChatSessionUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessionUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessionUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatSessionUsers.
     */
    distinct?: Enumerable<ChatSessionUserScalarFieldEnum>
  }


  /**
   * ChatSessionUser findMany
   */
  export type ChatSessionUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the ChatSessionUser
     */
    select?: ChatSessionUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatSessionUserInclude | null
    /**
     * Filter, which ChatSessionUsers to fetch.
     */
    where?: ChatSessionUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessionUsers to fetch.
     */
    orderBy?: Enumerable<ChatSessionUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatSessionUsers.
     */
    cursor?: ChatSessionUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessionUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessionUsers.
     */
    skip?: number
    distinct?: Enumerable<ChatSessionUserScalarFieldEnum>
  }


  /**
   * ChatSessionUser create
   */
  export type ChatSessionUserCreateArgs = {
    /**
     * Select specific fields to fetch from the ChatSessionUser
     */
    select?: ChatSessionUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatSessionUserInclude | null
    /**
     * The data needed to create a ChatSessionUser.
     */
    data: XOR<ChatSessionUserCreateInput, ChatSessionUserUncheckedCreateInput>
  }


  /**
   * ChatSessionUser createMany
   */
  export type ChatSessionUserCreateManyArgs = {
    /**
     * The data used to create many ChatSessionUsers.
     */
    data: Enumerable<ChatSessionUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ChatSessionUser update
   */
  export type ChatSessionUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the ChatSessionUser
     */
    select?: ChatSessionUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatSessionUserInclude | null
    /**
     * The data needed to update a ChatSessionUser.
     */
    data: XOR<ChatSessionUserUpdateInput, ChatSessionUserUncheckedUpdateInput>
    /**
     * Choose, which ChatSessionUser to update.
     */
    where: ChatSessionUserWhereUniqueInput
  }


  /**
   * ChatSessionUser updateMany
   */
  export type ChatSessionUserUpdateManyArgs = {
    /**
     * The data used to update ChatSessionUsers.
     */
    data: XOR<ChatSessionUserUpdateManyMutationInput, ChatSessionUserUncheckedUpdateManyInput>
    /**
     * Filter which ChatSessionUsers to update
     */
    where?: ChatSessionUserWhereInput
  }


  /**
   * ChatSessionUser upsert
   */
  export type ChatSessionUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the ChatSessionUser
     */
    select?: ChatSessionUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatSessionUserInclude | null
    /**
     * The filter to search for the ChatSessionUser to update in case it exists.
     */
    where: ChatSessionUserWhereUniqueInput
    /**
     * In case the ChatSessionUser found by the `where` argument doesn't exist, create a new ChatSessionUser with this data.
     */
    create: XOR<ChatSessionUserCreateInput, ChatSessionUserUncheckedCreateInput>
    /**
     * In case the ChatSessionUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatSessionUserUpdateInput, ChatSessionUserUncheckedUpdateInput>
  }


  /**
   * ChatSessionUser delete
   */
  export type ChatSessionUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the ChatSessionUser
     */
    select?: ChatSessionUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatSessionUserInclude | null
    /**
     * Filter which ChatSessionUser to delete.
     */
    where: ChatSessionUserWhereUniqueInput
  }


  /**
   * ChatSessionUser deleteMany
   */
  export type ChatSessionUserDeleteManyArgs = {
    /**
     * Filter which ChatSessionUsers to delete
     */
    where?: ChatSessionUserWhereInput
  }


  /**
   * ChatSessionUser without action
   */
  export type ChatSessionUserArgs = {
    /**
     * Select specific fields to fetch from the ChatSessionUser
     */
    select?: ChatSessionUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatSessionUserInclude | null
  }



  /**
   * Model MathNote
   */


  export type AggregateMathNote = {
    _count: MathNoteCountAggregateOutputType | null
    _min: MathNoteMinAggregateOutputType | null
    _max: MathNoteMaxAggregateOutputType | null
  }

  export type MathNoteMinAggregateOutputType = {
    creatorId: string | null
    content: string | null
    mathProblemId: string | null
    createdAt: Date | null
    imageLink: string | null
  }

  export type MathNoteMaxAggregateOutputType = {
    creatorId: string | null
    content: string | null
    mathProblemId: string | null
    createdAt: Date | null
    imageLink: string | null
  }

  export type MathNoteCountAggregateOutputType = {
    creatorId: number
    content: number
    mathProblemId: number
    createdAt: number
    imageLink: number
    _all: number
  }


  export type MathNoteMinAggregateInputType = {
    creatorId?: true
    content?: true
    mathProblemId?: true
    createdAt?: true
    imageLink?: true
  }

  export type MathNoteMaxAggregateInputType = {
    creatorId?: true
    content?: true
    mathProblemId?: true
    createdAt?: true
    imageLink?: true
  }

  export type MathNoteCountAggregateInputType = {
    creatorId?: true
    content?: true
    mathProblemId?: true
    createdAt?: true
    imageLink?: true
    _all?: true
  }

  export type MathNoteAggregateArgs = {
    /**
     * Filter which MathNote to aggregate.
     */
    where?: MathNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MathNotes to fetch.
     */
    orderBy?: Enumerable<MathNoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MathNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MathNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MathNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MathNotes
    **/
    _count?: true | MathNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MathNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MathNoteMaxAggregateInputType
  }

  export type GetMathNoteAggregateType<T extends MathNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateMathNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMathNote[P]>
      : GetScalarType<T[P], AggregateMathNote[P]>
  }




  export type MathNoteGroupByArgs = {
    where?: MathNoteWhereInput
    orderBy?: Enumerable<MathNoteOrderByWithAggregationInput>
    by: MathNoteScalarFieldEnum[]
    having?: MathNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MathNoteCountAggregateInputType | true
    _min?: MathNoteMinAggregateInputType
    _max?: MathNoteMaxAggregateInputType
  }


  export type MathNoteGroupByOutputType = {
    creatorId: string
    content: string
    mathProblemId: string
    createdAt: Date
    imageLink: string | null
    _count: MathNoteCountAggregateOutputType | null
    _min: MathNoteMinAggregateOutputType | null
    _max: MathNoteMaxAggregateOutputType | null
  }

  type GetMathNoteGroupByPayload<T extends MathNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MathNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MathNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MathNoteGroupByOutputType[P]>
            : GetScalarType<T[P], MathNoteGroupByOutputType[P]>
        }
      >
    >


  export type MathNoteSelect = {
    creatorId?: boolean
    content?: boolean
    mathProblemId?: boolean
    createdAt?: boolean
    imageLink?: boolean
    creator?: boolean | UserArgs
    mathProblem?: boolean | MathProblemArgs
  }


  export type MathNoteInclude = {
    creator?: boolean | UserArgs
    mathProblem?: boolean | MathProblemArgs
  }

  export type MathNoteGetPayload<S extends boolean | null | undefined | MathNoteArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MathNote :
    S extends undefined ? never :
    S extends { include: any } & (MathNoteArgs | MathNoteFindManyArgs)
    ? MathNote  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'creator' ? UserGetPayload<S['include'][P]> :
        P extends 'mathProblem' ? MathProblemGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MathNoteArgs | MathNoteFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'creator' ? UserGetPayload<S['select'][P]> :
        P extends 'mathProblem' ? MathProblemGetPayload<S['select'][P]> :  P extends keyof MathNote ? MathNote[P] : never
  } 
      : MathNote


  type MathNoteCountArgs = 
    Omit<MathNoteFindManyArgs, 'select' | 'include'> & {
      select?: MathNoteCountAggregateInputType | true
    }

  export interface MathNoteDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MathNote that matches the filter.
     * @param {MathNoteFindUniqueArgs} args - Arguments to find a MathNote
     * @example
     * // Get one MathNote
     * const mathNote = await prisma.mathNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MathNoteFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MathNoteFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MathNote'> extends True ? Prisma__MathNoteClient<MathNoteGetPayload<T>> : Prisma__MathNoteClient<MathNoteGetPayload<T> | null, null>

    /**
     * Find one MathNote that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MathNoteFindUniqueOrThrowArgs} args - Arguments to find a MathNote
     * @example
     * // Get one MathNote
     * const mathNote = await prisma.mathNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MathNoteFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MathNoteFindUniqueOrThrowArgs>
    ): Prisma__MathNoteClient<MathNoteGetPayload<T>>

    /**
     * Find the first MathNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathNoteFindFirstArgs} args - Arguments to find a MathNote
     * @example
     * // Get one MathNote
     * const mathNote = await prisma.mathNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MathNoteFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MathNoteFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MathNote'> extends True ? Prisma__MathNoteClient<MathNoteGetPayload<T>> : Prisma__MathNoteClient<MathNoteGetPayload<T> | null, null>

    /**
     * Find the first MathNote that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathNoteFindFirstOrThrowArgs} args - Arguments to find a MathNote
     * @example
     * // Get one MathNote
     * const mathNote = await prisma.mathNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MathNoteFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MathNoteFindFirstOrThrowArgs>
    ): Prisma__MathNoteClient<MathNoteGetPayload<T>>

    /**
     * Find zero or more MathNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathNoteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MathNotes
     * const mathNotes = await prisma.mathNote.findMany()
     * 
     * // Get first 10 MathNotes
     * const mathNotes = await prisma.mathNote.findMany({ take: 10 })
     * 
     * // Only select the `creatorId`
     * const mathNoteWithCreatorIdOnly = await prisma.mathNote.findMany({ select: { creatorId: true } })
     * 
    **/
    findMany<T extends MathNoteFindManyArgs>(
      args?: SelectSubset<T, MathNoteFindManyArgs>
    ): Prisma.PrismaPromise<Array<MathNoteGetPayload<T>>>

    /**
     * Create a MathNote.
     * @param {MathNoteCreateArgs} args - Arguments to create a MathNote.
     * @example
     * // Create one MathNote
     * const MathNote = await prisma.mathNote.create({
     *   data: {
     *     // ... data to create a MathNote
     *   }
     * })
     * 
    **/
    create<T extends MathNoteCreateArgs>(
      args: SelectSubset<T, MathNoteCreateArgs>
    ): Prisma__MathNoteClient<MathNoteGetPayload<T>>

    /**
     * Create many MathNotes.
     *     @param {MathNoteCreateManyArgs} args - Arguments to create many MathNotes.
     *     @example
     *     // Create many MathNotes
     *     const mathNote = await prisma.mathNote.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MathNoteCreateManyArgs>(
      args?: SelectSubset<T, MathNoteCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MathNote.
     * @param {MathNoteDeleteArgs} args - Arguments to delete one MathNote.
     * @example
     * // Delete one MathNote
     * const MathNote = await prisma.mathNote.delete({
     *   where: {
     *     // ... filter to delete one MathNote
     *   }
     * })
     * 
    **/
    delete<T extends MathNoteDeleteArgs>(
      args: SelectSubset<T, MathNoteDeleteArgs>
    ): Prisma__MathNoteClient<MathNoteGetPayload<T>>

    /**
     * Update one MathNote.
     * @param {MathNoteUpdateArgs} args - Arguments to update one MathNote.
     * @example
     * // Update one MathNote
     * const mathNote = await prisma.mathNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MathNoteUpdateArgs>(
      args: SelectSubset<T, MathNoteUpdateArgs>
    ): Prisma__MathNoteClient<MathNoteGetPayload<T>>

    /**
     * Delete zero or more MathNotes.
     * @param {MathNoteDeleteManyArgs} args - Arguments to filter MathNotes to delete.
     * @example
     * // Delete a few MathNotes
     * const { count } = await prisma.mathNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MathNoteDeleteManyArgs>(
      args?: SelectSubset<T, MathNoteDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MathNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MathNotes
     * const mathNote = await prisma.mathNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MathNoteUpdateManyArgs>(
      args: SelectSubset<T, MathNoteUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MathNote.
     * @param {MathNoteUpsertArgs} args - Arguments to update or create a MathNote.
     * @example
     * // Update or create a MathNote
     * const mathNote = await prisma.mathNote.upsert({
     *   create: {
     *     // ... data to create a MathNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MathNote we want to update
     *   }
     * })
    **/
    upsert<T extends MathNoteUpsertArgs>(
      args: SelectSubset<T, MathNoteUpsertArgs>
    ): Prisma__MathNoteClient<MathNoteGetPayload<T>>

    /**
     * Count the number of MathNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathNoteCountArgs} args - Arguments to filter MathNotes to count.
     * @example
     * // Count the number of MathNotes
     * const count = await prisma.mathNote.count({
     *   where: {
     *     // ... the filter for the MathNotes we want to count
     *   }
     * })
    **/
    count<T extends MathNoteCountArgs>(
      args?: Subset<T, MathNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MathNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MathNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MathNoteAggregateArgs>(args: Subset<T, MathNoteAggregateArgs>): Prisma.PrismaPromise<GetMathNoteAggregateType<T>>

    /**
     * Group by MathNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MathNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MathNoteGroupByArgs['orderBy'] }
        : { orderBy?: MathNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MathNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMathNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MathNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MathNoteClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    creator<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    mathProblem<T extends MathProblemArgs= {}>(args?: Subset<T, MathProblemArgs>): Prisma__MathProblemClient<MathProblemGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MathNote base type for findUnique actions
   */
  export type MathNoteFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MathNote
     */
    select?: MathNoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathNoteInclude | null
    /**
     * Filter, which MathNote to fetch.
     */
    where: MathNoteWhereUniqueInput
  }

  /**
   * MathNote findUnique
   */
  export interface MathNoteFindUniqueArgs extends MathNoteFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MathNote findUniqueOrThrow
   */
  export type MathNoteFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MathNote
     */
    select?: MathNoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathNoteInclude | null
    /**
     * Filter, which MathNote to fetch.
     */
    where: MathNoteWhereUniqueInput
  }


  /**
   * MathNote base type for findFirst actions
   */
  export type MathNoteFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MathNote
     */
    select?: MathNoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathNoteInclude | null
    /**
     * Filter, which MathNote to fetch.
     */
    where?: MathNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MathNotes to fetch.
     */
    orderBy?: Enumerable<MathNoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MathNotes.
     */
    cursor?: MathNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MathNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MathNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MathNotes.
     */
    distinct?: Enumerable<MathNoteScalarFieldEnum>
  }

  /**
   * MathNote findFirst
   */
  export interface MathNoteFindFirstArgs extends MathNoteFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MathNote findFirstOrThrow
   */
  export type MathNoteFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MathNote
     */
    select?: MathNoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathNoteInclude | null
    /**
     * Filter, which MathNote to fetch.
     */
    where?: MathNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MathNotes to fetch.
     */
    orderBy?: Enumerable<MathNoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MathNotes.
     */
    cursor?: MathNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MathNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MathNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MathNotes.
     */
    distinct?: Enumerable<MathNoteScalarFieldEnum>
  }


  /**
   * MathNote findMany
   */
  export type MathNoteFindManyArgs = {
    /**
     * Select specific fields to fetch from the MathNote
     */
    select?: MathNoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathNoteInclude | null
    /**
     * Filter, which MathNotes to fetch.
     */
    where?: MathNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MathNotes to fetch.
     */
    orderBy?: Enumerable<MathNoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MathNotes.
     */
    cursor?: MathNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MathNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MathNotes.
     */
    skip?: number
    distinct?: Enumerable<MathNoteScalarFieldEnum>
  }


  /**
   * MathNote create
   */
  export type MathNoteCreateArgs = {
    /**
     * Select specific fields to fetch from the MathNote
     */
    select?: MathNoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathNoteInclude | null
    /**
     * The data needed to create a MathNote.
     */
    data: XOR<MathNoteCreateInput, MathNoteUncheckedCreateInput>
  }


  /**
   * MathNote createMany
   */
  export type MathNoteCreateManyArgs = {
    /**
     * The data used to create many MathNotes.
     */
    data: Enumerable<MathNoteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MathNote update
   */
  export type MathNoteUpdateArgs = {
    /**
     * Select specific fields to fetch from the MathNote
     */
    select?: MathNoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathNoteInclude | null
    /**
     * The data needed to update a MathNote.
     */
    data: XOR<MathNoteUpdateInput, MathNoteUncheckedUpdateInput>
    /**
     * Choose, which MathNote to update.
     */
    where: MathNoteWhereUniqueInput
  }


  /**
   * MathNote updateMany
   */
  export type MathNoteUpdateManyArgs = {
    /**
     * The data used to update MathNotes.
     */
    data: XOR<MathNoteUpdateManyMutationInput, MathNoteUncheckedUpdateManyInput>
    /**
     * Filter which MathNotes to update
     */
    where?: MathNoteWhereInput
  }


  /**
   * MathNote upsert
   */
  export type MathNoteUpsertArgs = {
    /**
     * Select specific fields to fetch from the MathNote
     */
    select?: MathNoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathNoteInclude | null
    /**
     * The filter to search for the MathNote to update in case it exists.
     */
    where: MathNoteWhereUniqueInput
    /**
     * In case the MathNote found by the `where` argument doesn't exist, create a new MathNote with this data.
     */
    create: XOR<MathNoteCreateInput, MathNoteUncheckedCreateInput>
    /**
     * In case the MathNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MathNoteUpdateInput, MathNoteUncheckedUpdateInput>
  }


  /**
   * MathNote delete
   */
  export type MathNoteDeleteArgs = {
    /**
     * Select specific fields to fetch from the MathNote
     */
    select?: MathNoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathNoteInclude | null
    /**
     * Filter which MathNote to delete.
     */
    where: MathNoteWhereUniqueInput
  }


  /**
   * MathNote deleteMany
   */
  export type MathNoteDeleteManyArgs = {
    /**
     * Filter which MathNotes to delete
     */
    where?: MathNoteWhereInput
  }


  /**
   * MathNote without action
   */
  export type MathNoteArgs = {
    /**
     * Select specific fields to fetch from the MathNote
     */
    select?: MathNoteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathNoteInclude | null
  }



  /**
   * Model MathSolution
   */


  export type AggregateMathSolution = {
    _count: MathSolutionCountAggregateOutputType | null
    _min: MathSolutionMinAggregateOutputType | null
    _max: MathSolutionMaxAggregateOutputType | null
  }

  export type MathSolutionMinAggregateOutputType = {
    creatorId: string | null
    content: string | null
    mathProblemId: string | null
    createdAt: Date | null
    checked: boolean | null
    imageLink: string | null
  }

  export type MathSolutionMaxAggregateOutputType = {
    creatorId: string | null
    content: string | null
    mathProblemId: string | null
    createdAt: Date | null
    checked: boolean | null
    imageLink: string | null
  }

  export type MathSolutionCountAggregateOutputType = {
    creatorId: number
    content: number
    mathProblemId: number
    createdAt: number
    checked: number
    imageLink: number
    _all: number
  }


  export type MathSolutionMinAggregateInputType = {
    creatorId?: true
    content?: true
    mathProblemId?: true
    createdAt?: true
    checked?: true
    imageLink?: true
  }

  export type MathSolutionMaxAggregateInputType = {
    creatorId?: true
    content?: true
    mathProblemId?: true
    createdAt?: true
    checked?: true
    imageLink?: true
  }

  export type MathSolutionCountAggregateInputType = {
    creatorId?: true
    content?: true
    mathProblemId?: true
    createdAt?: true
    checked?: true
    imageLink?: true
    _all?: true
  }

  export type MathSolutionAggregateArgs = {
    /**
     * Filter which MathSolution to aggregate.
     */
    where?: MathSolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MathSolutions to fetch.
     */
    orderBy?: Enumerable<MathSolutionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MathSolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MathSolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MathSolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MathSolutions
    **/
    _count?: true | MathSolutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MathSolutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MathSolutionMaxAggregateInputType
  }

  export type GetMathSolutionAggregateType<T extends MathSolutionAggregateArgs> = {
        [P in keyof T & keyof AggregateMathSolution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMathSolution[P]>
      : GetScalarType<T[P], AggregateMathSolution[P]>
  }




  export type MathSolutionGroupByArgs = {
    where?: MathSolutionWhereInput
    orderBy?: Enumerable<MathSolutionOrderByWithAggregationInput>
    by: MathSolutionScalarFieldEnum[]
    having?: MathSolutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MathSolutionCountAggregateInputType | true
    _min?: MathSolutionMinAggregateInputType
    _max?: MathSolutionMaxAggregateInputType
  }


  export type MathSolutionGroupByOutputType = {
    creatorId: string
    content: string
    mathProblemId: string
    createdAt: Date
    checked: boolean
    imageLink: string | null
    _count: MathSolutionCountAggregateOutputType | null
    _min: MathSolutionMinAggregateOutputType | null
    _max: MathSolutionMaxAggregateOutputType | null
  }

  type GetMathSolutionGroupByPayload<T extends MathSolutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MathSolutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MathSolutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MathSolutionGroupByOutputType[P]>
            : GetScalarType<T[P], MathSolutionGroupByOutputType[P]>
        }
      >
    >


  export type MathSolutionSelect = {
    creatorId?: boolean
    content?: boolean
    mathProblemId?: boolean
    createdAt?: boolean
    checked?: boolean
    imageLink?: boolean
    creator?: boolean | UserArgs
    mathProblem?: boolean | MathProblemArgs
  }


  export type MathSolutionInclude = {
    creator?: boolean | UserArgs
    mathProblem?: boolean | MathProblemArgs
  }

  export type MathSolutionGetPayload<S extends boolean | null | undefined | MathSolutionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MathSolution :
    S extends undefined ? never :
    S extends { include: any } & (MathSolutionArgs | MathSolutionFindManyArgs)
    ? MathSolution  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'creator' ? UserGetPayload<S['include'][P]> :
        P extends 'mathProblem' ? MathProblemGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MathSolutionArgs | MathSolutionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'creator' ? UserGetPayload<S['select'][P]> :
        P extends 'mathProblem' ? MathProblemGetPayload<S['select'][P]> :  P extends keyof MathSolution ? MathSolution[P] : never
  } 
      : MathSolution


  type MathSolutionCountArgs = 
    Omit<MathSolutionFindManyArgs, 'select' | 'include'> & {
      select?: MathSolutionCountAggregateInputType | true
    }

  export interface MathSolutionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MathSolution that matches the filter.
     * @param {MathSolutionFindUniqueArgs} args - Arguments to find a MathSolution
     * @example
     * // Get one MathSolution
     * const mathSolution = await prisma.mathSolution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MathSolutionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MathSolutionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MathSolution'> extends True ? Prisma__MathSolutionClient<MathSolutionGetPayload<T>> : Prisma__MathSolutionClient<MathSolutionGetPayload<T> | null, null>

    /**
     * Find one MathSolution that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MathSolutionFindUniqueOrThrowArgs} args - Arguments to find a MathSolution
     * @example
     * // Get one MathSolution
     * const mathSolution = await prisma.mathSolution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MathSolutionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MathSolutionFindUniqueOrThrowArgs>
    ): Prisma__MathSolutionClient<MathSolutionGetPayload<T>>

    /**
     * Find the first MathSolution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathSolutionFindFirstArgs} args - Arguments to find a MathSolution
     * @example
     * // Get one MathSolution
     * const mathSolution = await prisma.mathSolution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MathSolutionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MathSolutionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MathSolution'> extends True ? Prisma__MathSolutionClient<MathSolutionGetPayload<T>> : Prisma__MathSolutionClient<MathSolutionGetPayload<T> | null, null>

    /**
     * Find the first MathSolution that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathSolutionFindFirstOrThrowArgs} args - Arguments to find a MathSolution
     * @example
     * // Get one MathSolution
     * const mathSolution = await prisma.mathSolution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MathSolutionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MathSolutionFindFirstOrThrowArgs>
    ): Prisma__MathSolutionClient<MathSolutionGetPayload<T>>

    /**
     * Find zero or more MathSolutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathSolutionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MathSolutions
     * const mathSolutions = await prisma.mathSolution.findMany()
     * 
     * // Get first 10 MathSolutions
     * const mathSolutions = await prisma.mathSolution.findMany({ take: 10 })
     * 
     * // Only select the `creatorId`
     * const mathSolutionWithCreatorIdOnly = await prisma.mathSolution.findMany({ select: { creatorId: true } })
     * 
    **/
    findMany<T extends MathSolutionFindManyArgs>(
      args?: SelectSubset<T, MathSolutionFindManyArgs>
    ): Prisma.PrismaPromise<Array<MathSolutionGetPayload<T>>>

    /**
     * Create a MathSolution.
     * @param {MathSolutionCreateArgs} args - Arguments to create a MathSolution.
     * @example
     * // Create one MathSolution
     * const MathSolution = await prisma.mathSolution.create({
     *   data: {
     *     // ... data to create a MathSolution
     *   }
     * })
     * 
    **/
    create<T extends MathSolutionCreateArgs>(
      args: SelectSubset<T, MathSolutionCreateArgs>
    ): Prisma__MathSolutionClient<MathSolutionGetPayload<T>>

    /**
     * Create many MathSolutions.
     *     @param {MathSolutionCreateManyArgs} args - Arguments to create many MathSolutions.
     *     @example
     *     // Create many MathSolutions
     *     const mathSolution = await prisma.mathSolution.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MathSolutionCreateManyArgs>(
      args?: SelectSubset<T, MathSolutionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MathSolution.
     * @param {MathSolutionDeleteArgs} args - Arguments to delete one MathSolution.
     * @example
     * // Delete one MathSolution
     * const MathSolution = await prisma.mathSolution.delete({
     *   where: {
     *     // ... filter to delete one MathSolution
     *   }
     * })
     * 
    **/
    delete<T extends MathSolutionDeleteArgs>(
      args: SelectSubset<T, MathSolutionDeleteArgs>
    ): Prisma__MathSolutionClient<MathSolutionGetPayload<T>>

    /**
     * Update one MathSolution.
     * @param {MathSolutionUpdateArgs} args - Arguments to update one MathSolution.
     * @example
     * // Update one MathSolution
     * const mathSolution = await prisma.mathSolution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MathSolutionUpdateArgs>(
      args: SelectSubset<T, MathSolutionUpdateArgs>
    ): Prisma__MathSolutionClient<MathSolutionGetPayload<T>>

    /**
     * Delete zero or more MathSolutions.
     * @param {MathSolutionDeleteManyArgs} args - Arguments to filter MathSolutions to delete.
     * @example
     * // Delete a few MathSolutions
     * const { count } = await prisma.mathSolution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MathSolutionDeleteManyArgs>(
      args?: SelectSubset<T, MathSolutionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MathSolutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathSolutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MathSolutions
     * const mathSolution = await prisma.mathSolution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MathSolutionUpdateManyArgs>(
      args: SelectSubset<T, MathSolutionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MathSolution.
     * @param {MathSolutionUpsertArgs} args - Arguments to update or create a MathSolution.
     * @example
     * // Update or create a MathSolution
     * const mathSolution = await prisma.mathSolution.upsert({
     *   create: {
     *     // ... data to create a MathSolution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MathSolution we want to update
     *   }
     * })
    **/
    upsert<T extends MathSolutionUpsertArgs>(
      args: SelectSubset<T, MathSolutionUpsertArgs>
    ): Prisma__MathSolutionClient<MathSolutionGetPayload<T>>

    /**
     * Count the number of MathSolutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathSolutionCountArgs} args - Arguments to filter MathSolutions to count.
     * @example
     * // Count the number of MathSolutions
     * const count = await prisma.mathSolution.count({
     *   where: {
     *     // ... the filter for the MathSolutions we want to count
     *   }
     * })
    **/
    count<T extends MathSolutionCountArgs>(
      args?: Subset<T, MathSolutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MathSolutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MathSolution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathSolutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MathSolutionAggregateArgs>(args: Subset<T, MathSolutionAggregateArgs>): Prisma.PrismaPromise<GetMathSolutionAggregateType<T>>

    /**
     * Group by MathSolution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MathSolutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MathSolutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MathSolutionGroupByArgs['orderBy'] }
        : { orderBy?: MathSolutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MathSolutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMathSolutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MathSolution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MathSolutionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    creator<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    mathProblem<T extends MathProblemArgs= {}>(args?: Subset<T, MathProblemArgs>): Prisma__MathProblemClient<MathProblemGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MathSolution base type for findUnique actions
   */
  export type MathSolutionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MathSolution
     */
    select?: MathSolutionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathSolutionInclude | null
    /**
     * Filter, which MathSolution to fetch.
     */
    where: MathSolutionWhereUniqueInput
  }

  /**
   * MathSolution findUnique
   */
  export interface MathSolutionFindUniqueArgs extends MathSolutionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MathSolution findUniqueOrThrow
   */
  export type MathSolutionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MathSolution
     */
    select?: MathSolutionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathSolutionInclude | null
    /**
     * Filter, which MathSolution to fetch.
     */
    where: MathSolutionWhereUniqueInput
  }


  /**
   * MathSolution base type for findFirst actions
   */
  export type MathSolutionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MathSolution
     */
    select?: MathSolutionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathSolutionInclude | null
    /**
     * Filter, which MathSolution to fetch.
     */
    where?: MathSolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MathSolutions to fetch.
     */
    orderBy?: Enumerable<MathSolutionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MathSolutions.
     */
    cursor?: MathSolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MathSolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MathSolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MathSolutions.
     */
    distinct?: Enumerable<MathSolutionScalarFieldEnum>
  }

  /**
   * MathSolution findFirst
   */
  export interface MathSolutionFindFirstArgs extends MathSolutionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MathSolution findFirstOrThrow
   */
  export type MathSolutionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MathSolution
     */
    select?: MathSolutionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathSolutionInclude | null
    /**
     * Filter, which MathSolution to fetch.
     */
    where?: MathSolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MathSolutions to fetch.
     */
    orderBy?: Enumerable<MathSolutionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MathSolutions.
     */
    cursor?: MathSolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MathSolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MathSolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MathSolutions.
     */
    distinct?: Enumerable<MathSolutionScalarFieldEnum>
  }


  /**
   * MathSolution findMany
   */
  export type MathSolutionFindManyArgs = {
    /**
     * Select specific fields to fetch from the MathSolution
     */
    select?: MathSolutionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathSolutionInclude | null
    /**
     * Filter, which MathSolutions to fetch.
     */
    where?: MathSolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MathSolutions to fetch.
     */
    orderBy?: Enumerable<MathSolutionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MathSolutions.
     */
    cursor?: MathSolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MathSolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MathSolutions.
     */
    skip?: number
    distinct?: Enumerable<MathSolutionScalarFieldEnum>
  }


  /**
   * MathSolution create
   */
  export type MathSolutionCreateArgs = {
    /**
     * Select specific fields to fetch from the MathSolution
     */
    select?: MathSolutionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathSolutionInclude | null
    /**
     * The data needed to create a MathSolution.
     */
    data: XOR<MathSolutionCreateInput, MathSolutionUncheckedCreateInput>
  }


  /**
   * MathSolution createMany
   */
  export type MathSolutionCreateManyArgs = {
    /**
     * The data used to create many MathSolutions.
     */
    data: Enumerable<MathSolutionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MathSolution update
   */
  export type MathSolutionUpdateArgs = {
    /**
     * Select specific fields to fetch from the MathSolution
     */
    select?: MathSolutionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathSolutionInclude | null
    /**
     * The data needed to update a MathSolution.
     */
    data: XOR<MathSolutionUpdateInput, MathSolutionUncheckedUpdateInput>
    /**
     * Choose, which MathSolution to update.
     */
    where: MathSolutionWhereUniqueInput
  }


  /**
   * MathSolution updateMany
   */
  export type MathSolutionUpdateManyArgs = {
    /**
     * The data used to update MathSolutions.
     */
    data: XOR<MathSolutionUpdateManyMutationInput, MathSolutionUncheckedUpdateManyInput>
    /**
     * Filter which MathSolutions to update
     */
    where?: MathSolutionWhereInput
  }


  /**
   * MathSolution upsert
   */
  export type MathSolutionUpsertArgs = {
    /**
     * Select specific fields to fetch from the MathSolution
     */
    select?: MathSolutionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathSolutionInclude | null
    /**
     * The filter to search for the MathSolution to update in case it exists.
     */
    where: MathSolutionWhereUniqueInput
    /**
     * In case the MathSolution found by the `where` argument doesn't exist, create a new MathSolution with this data.
     */
    create: XOR<MathSolutionCreateInput, MathSolutionUncheckedCreateInput>
    /**
     * In case the MathSolution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MathSolutionUpdateInput, MathSolutionUncheckedUpdateInput>
  }


  /**
   * MathSolution delete
   */
  export type MathSolutionDeleteArgs = {
    /**
     * Select specific fields to fetch from the MathSolution
     */
    select?: MathSolutionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathSolutionInclude | null
    /**
     * Filter which MathSolution to delete.
     */
    where: MathSolutionWhereUniqueInput
  }


  /**
   * MathSolution deleteMany
   */
  export type MathSolutionDeleteManyArgs = {
    /**
     * Filter which MathSolutions to delete
     */
    where?: MathSolutionWhereInput
  }


  /**
   * MathSolution without action
   */
  export type MathSolutionArgs = {
    /**
     * Select specific fields to fetch from the MathSolution
     */
    select?: MathSolutionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MathSolutionInclude | null
  }



  /**
   * Model Contest
   */


  export type AggregateContest = {
    _count: ContestCountAggregateOutputType | null
    _avg: ContestAvgAggregateOutputType | null
    _sum: ContestSumAggregateOutputType | null
    _min: ContestMinAggregateOutputType | null
    _max: ContestMaxAggregateOutputType | null
  }

  export type ContestAvgAggregateOutputType = {
    duration: number | null
  }

  export type ContestSumAggregateOutputType = {
    duration: number | null
  }

  export type ContestMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    realTimeRank: boolean | null
    password: string | null
    ruleType: ProblemRuleType | null
    startTime: Date | null
    duration: number | null
    endTime: Date | null
    createTime: Date | null
    lastUpdateTime: Date | null
    visible: boolean | null
  }

  export type ContestMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    realTimeRank: boolean | null
    password: string | null
    ruleType: ProblemRuleType | null
    startTime: Date | null
    duration: number | null
    endTime: Date | null
    createTime: Date | null
    lastUpdateTime: Date | null
    visible: boolean | null
  }

  export type ContestCountAggregateOutputType = {
    id: number
    title: number
    description: number
    realTimeRank: number
    password: number
    ruleType: number
    startTime: number
    duration: number
    endTime: number
    createTime: number
    lastUpdateTime: number
    visible: number
    _all: number
  }


  export type ContestAvgAggregateInputType = {
    duration?: true
  }

  export type ContestSumAggregateInputType = {
    duration?: true
  }

  export type ContestMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    realTimeRank?: true
    password?: true
    ruleType?: true
    startTime?: true
    duration?: true
    endTime?: true
    createTime?: true
    lastUpdateTime?: true
    visible?: true
  }

  export type ContestMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    realTimeRank?: true
    password?: true
    ruleType?: true
    startTime?: true
    duration?: true
    endTime?: true
    createTime?: true
    lastUpdateTime?: true
    visible?: true
  }

  export type ContestCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    realTimeRank?: true
    password?: true
    ruleType?: true
    startTime?: true
    duration?: true
    endTime?: true
    createTime?: true
    lastUpdateTime?: true
    visible?: true
    _all?: true
  }

  export type ContestAggregateArgs = {
    /**
     * Filter which Contest to aggregate.
     */
    where?: ContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contests to fetch.
     */
    orderBy?: Enumerable<ContestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contests
    **/
    _count?: true | ContestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContestMaxAggregateInputType
  }

  export type GetContestAggregateType<T extends ContestAggregateArgs> = {
        [P in keyof T & keyof AggregateContest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContest[P]>
      : GetScalarType<T[P], AggregateContest[P]>
  }




  export type ContestGroupByArgs = {
    where?: ContestWhereInput
    orderBy?: Enumerable<ContestOrderByWithAggregationInput>
    by: ContestScalarFieldEnum[]
    having?: ContestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContestCountAggregateInputType | true
    _avg?: ContestAvgAggregateInputType
    _sum?: ContestSumAggregateInputType
    _min?: ContestMinAggregateInputType
    _max?: ContestMaxAggregateInputType
  }


  export type ContestGroupByOutputType = {
    id: string
    title: string
    description: string
    realTimeRank: boolean
    password: string | null
    ruleType: ProblemRuleType
    startTime: Date
    duration: number
    endTime: Date
    createTime: Date
    lastUpdateTime: Date
    visible: boolean
    _count: ContestCountAggregateOutputType | null
    _avg: ContestAvgAggregateOutputType | null
    _sum: ContestSumAggregateOutputType | null
    _min: ContestMinAggregateOutputType | null
    _max: ContestMaxAggregateOutputType | null
  }

  type GetContestGroupByPayload<T extends ContestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ContestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContestGroupByOutputType[P]>
            : GetScalarType<T[P], ContestGroupByOutputType[P]>
        }
      >
    >


  export type ContestSelect = {
    id?: boolean
    title?: boolean
    description?: boolean
    realTimeRank?: boolean
    password?: boolean
    ruleType?: boolean
    startTime?: boolean
    duration?: boolean
    endTime?: boolean
    createTime?: boolean
    lastUpdateTime?: boolean
    visible?: boolean
    codingProblems?: boolean | Contest$codingProblemsArgs
    _count?: boolean | ContestCountOutputTypeArgs
  }


  export type ContestInclude = {
    codingProblems?: boolean | Contest$codingProblemsArgs
    _count?: boolean | ContestCountOutputTypeArgs
  }

  export type ContestGetPayload<S extends boolean | null | undefined | ContestArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Contest :
    S extends undefined ? never :
    S extends { include: any } & (ContestArgs | ContestFindManyArgs)
    ? Contest  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'codingProblems' ? Array < CodingProblemGetPayload<S['include'][P]>>  :
        P extends '_count' ? ContestCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ContestArgs | ContestFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'codingProblems' ? Array < CodingProblemGetPayload<S['select'][P]>>  :
        P extends '_count' ? ContestCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Contest ? Contest[P] : never
  } 
      : Contest


  type ContestCountArgs = 
    Omit<ContestFindManyArgs, 'select' | 'include'> & {
      select?: ContestCountAggregateInputType | true
    }

  export interface ContestDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Contest that matches the filter.
     * @param {ContestFindUniqueArgs} args - Arguments to find a Contest
     * @example
     * // Get one Contest
     * const contest = await prisma.contest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContestFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ContestFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Contest'> extends True ? Prisma__ContestClient<ContestGetPayload<T>> : Prisma__ContestClient<ContestGetPayload<T> | null, null>

    /**
     * Find one Contest that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ContestFindUniqueOrThrowArgs} args - Arguments to find a Contest
     * @example
     * // Get one Contest
     * const contest = await prisma.contest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ContestFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ContestFindUniqueOrThrowArgs>
    ): Prisma__ContestClient<ContestGetPayload<T>>

    /**
     * Find the first Contest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestFindFirstArgs} args - Arguments to find a Contest
     * @example
     * // Get one Contest
     * const contest = await prisma.contest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContestFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ContestFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Contest'> extends True ? Prisma__ContestClient<ContestGetPayload<T>> : Prisma__ContestClient<ContestGetPayload<T> | null, null>

    /**
     * Find the first Contest that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestFindFirstOrThrowArgs} args - Arguments to find a Contest
     * @example
     * // Get one Contest
     * const contest = await prisma.contest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ContestFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ContestFindFirstOrThrowArgs>
    ): Prisma__ContestClient<ContestGetPayload<T>>

    /**
     * Find zero or more Contests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contests
     * const contests = await prisma.contest.findMany()
     * 
     * // Get first 10 Contests
     * const contests = await prisma.contest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contestWithIdOnly = await prisma.contest.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ContestFindManyArgs>(
      args?: SelectSubset<T, ContestFindManyArgs>
    ): Prisma.PrismaPromise<Array<ContestGetPayload<T>>>

    /**
     * Create a Contest.
     * @param {ContestCreateArgs} args - Arguments to create a Contest.
     * @example
     * // Create one Contest
     * const Contest = await prisma.contest.create({
     *   data: {
     *     // ... data to create a Contest
     *   }
     * })
     * 
    **/
    create<T extends ContestCreateArgs>(
      args: SelectSubset<T, ContestCreateArgs>
    ): Prisma__ContestClient<ContestGetPayload<T>>

    /**
     * Create many Contests.
     *     @param {ContestCreateManyArgs} args - Arguments to create many Contests.
     *     @example
     *     // Create many Contests
     *     const contest = await prisma.contest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ContestCreateManyArgs>(
      args?: SelectSubset<T, ContestCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contest.
     * @param {ContestDeleteArgs} args - Arguments to delete one Contest.
     * @example
     * // Delete one Contest
     * const Contest = await prisma.contest.delete({
     *   where: {
     *     // ... filter to delete one Contest
     *   }
     * })
     * 
    **/
    delete<T extends ContestDeleteArgs>(
      args: SelectSubset<T, ContestDeleteArgs>
    ): Prisma__ContestClient<ContestGetPayload<T>>

    /**
     * Update one Contest.
     * @param {ContestUpdateArgs} args - Arguments to update one Contest.
     * @example
     * // Update one Contest
     * const contest = await prisma.contest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContestUpdateArgs>(
      args: SelectSubset<T, ContestUpdateArgs>
    ): Prisma__ContestClient<ContestGetPayload<T>>

    /**
     * Delete zero or more Contests.
     * @param {ContestDeleteManyArgs} args - Arguments to filter Contests to delete.
     * @example
     * // Delete a few Contests
     * const { count } = await prisma.contest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContestDeleteManyArgs>(
      args?: SelectSubset<T, ContestDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contests
     * const contest = await prisma.contest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContestUpdateManyArgs>(
      args: SelectSubset<T, ContestUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contest.
     * @param {ContestUpsertArgs} args - Arguments to update or create a Contest.
     * @example
     * // Update or create a Contest
     * const contest = await prisma.contest.upsert({
     *   create: {
     *     // ... data to create a Contest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contest we want to update
     *   }
     * })
    **/
    upsert<T extends ContestUpsertArgs>(
      args: SelectSubset<T, ContestUpsertArgs>
    ): Prisma__ContestClient<ContestGetPayload<T>>

    /**
     * Count the number of Contests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestCountArgs} args - Arguments to filter Contests to count.
     * @example
     * // Count the number of Contests
     * const count = await prisma.contest.count({
     *   where: {
     *     // ... the filter for the Contests we want to count
     *   }
     * })
    **/
    count<T extends ContestCountArgs>(
      args?: Subset<T, ContestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContestAggregateArgs>(args: Subset<T, ContestAggregateArgs>): Prisma.PrismaPromise<GetContestAggregateType<T>>

    /**
     * Group by Contest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContestGroupByArgs['orderBy'] }
        : { orderBy?: ContestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Contest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ContestClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    codingProblems<T extends Contest$codingProblemsArgs= {}>(args?: Subset<T, Contest$codingProblemsArgs>): Prisma.PrismaPromise<Array<CodingProblemGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Contest base type for findUnique actions
   */
  export type ContestFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContestInclude | null
    /**
     * Filter, which Contest to fetch.
     */
    where: ContestWhereUniqueInput
  }

  /**
   * Contest findUnique
   */
  export interface ContestFindUniqueArgs extends ContestFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Contest findUniqueOrThrow
   */
  export type ContestFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContestInclude | null
    /**
     * Filter, which Contest to fetch.
     */
    where: ContestWhereUniqueInput
  }


  /**
   * Contest base type for findFirst actions
   */
  export type ContestFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContestInclude | null
    /**
     * Filter, which Contest to fetch.
     */
    where?: ContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contests to fetch.
     */
    orderBy?: Enumerable<ContestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contests.
     */
    cursor?: ContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contests.
     */
    distinct?: Enumerable<ContestScalarFieldEnum>
  }

  /**
   * Contest findFirst
   */
  export interface ContestFindFirstArgs extends ContestFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Contest findFirstOrThrow
   */
  export type ContestFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContestInclude | null
    /**
     * Filter, which Contest to fetch.
     */
    where?: ContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contests to fetch.
     */
    orderBy?: Enumerable<ContestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contests.
     */
    cursor?: ContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contests.
     */
    distinct?: Enumerable<ContestScalarFieldEnum>
  }


  /**
   * Contest findMany
   */
  export type ContestFindManyArgs = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContestInclude | null
    /**
     * Filter, which Contests to fetch.
     */
    where?: ContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contests to fetch.
     */
    orderBy?: Enumerable<ContestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contests.
     */
    cursor?: ContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contests.
     */
    skip?: number
    distinct?: Enumerable<ContestScalarFieldEnum>
  }


  /**
   * Contest create
   */
  export type ContestCreateArgs = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContestInclude | null
    /**
     * The data needed to create a Contest.
     */
    data: XOR<ContestCreateInput, ContestUncheckedCreateInput>
  }


  /**
   * Contest createMany
   */
  export type ContestCreateManyArgs = {
    /**
     * The data used to create many Contests.
     */
    data: Enumerable<ContestCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Contest update
   */
  export type ContestUpdateArgs = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContestInclude | null
    /**
     * The data needed to update a Contest.
     */
    data: XOR<ContestUpdateInput, ContestUncheckedUpdateInput>
    /**
     * Choose, which Contest to update.
     */
    where: ContestWhereUniqueInput
  }


  /**
   * Contest updateMany
   */
  export type ContestUpdateManyArgs = {
    /**
     * The data used to update Contests.
     */
    data: XOR<ContestUpdateManyMutationInput, ContestUncheckedUpdateManyInput>
    /**
     * Filter which Contests to update
     */
    where?: ContestWhereInput
  }


  /**
   * Contest upsert
   */
  export type ContestUpsertArgs = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContestInclude | null
    /**
     * The filter to search for the Contest to update in case it exists.
     */
    where: ContestWhereUniqueInput
    /**
     * In case the Contest found by the `where` argument doesn't exist, create a new Contest with this data.
     */
    create: XOR<ContestCreateInput, ContestUncheckedCreateInput>
    /**
     * In case the Contest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContestUpdateInput, ContestUncheckedUpdateInput>
  }


  /**
   * Contest delete
   */
  export type ContestDeleteArgs = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContestInclude | null
    /**
     * Filter which Contest to delete.
     */
    where: ContestWhereUniqueInput
  }


  /**
   * Contest deleteMany
   */
  export type ContestDeleteManyArgs = {
    /**
     * Filter which Contests to delete
     */
    where?: ContestWhereInput
  }


  /**
   * Contest.codingProblems
   */
  export type Contest$codingProblemsArgs = {
    /**
     * Select specific fields to fetch from the CodingProblem
     */
    select?: CodingProblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodingProblemInclude | null
    where?: CodingProblemWhereInput
    orderBy?: Enumerable<CodingProblemOrderByWithRelationInput>
    cursor?: CodingProblemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CodingProblemScalarFieldEnum>
  }


  /**
   * Contest without action
   */
  export type ContestArgs = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContestInclude | null
  }



  /**
   * Model Submission
   */


  export type AggregateSubmission = {
    _count: SubmissionCountAggregateOutputType | null
    _min: SubmissionMinAggregateOutputType | null
    _max: SubmissionMaxAggregateOutputType | null
  }

  export type SubmissionMinAggregateOutputType = {
    id: string | null
    contestId: string | null
    problemId: string | null
    createTime: Date | null
    username: string | null
    code: string | null
    result: JudgeStatus | null
    language: string | null
    shared: boolean | null
  }

  export type SubmissionMaxAggregateOutputType = {
    id: string | null
    contestId: string | null
    problemId: string | null
    createTime: Date | null
    username: string | null
    code: string | null
    result: JudgeStatus | null
    language: string | null
    shared: boolean | null
  }

  export type SubmissionCountAggregateOutputType = {
    id: number
    contestId: number
    problemId: number
    createTime: number
    username: number
    code: number
    result: number
    language: number
    shared: number
    status: number
    statistic_info: number
    _all: number
  }


  export type SubmissionMinAggregateInputType = {
    id?: true
    contestId?: true
    problemId?: true
    createTime?: true
    username?: true
    code?: true
    result?: true
    language?: true
    shared?: true
  }

  export type SubmissionMaxAggregateInputType = {
    id?: true
    contestId?: true
    problemId?: true
    createTime?: true
    username?: true
    code?: true
    result?: true
    language?: true
    shared?: true
  }

  export type SubmissionCountAggregateInputType = {
    id?: true
    contestId?: true
    problemId?: true
    createTime?: true
    username?: true
    code?: true
    result?: true
    language?: true
    shared?: true
    status?: true
    statistic_info?: true
    _all?: true
  }

  export type SubmissionAggregateArgs = {
    /**
     * Filter which Submission to aggregate.
     */
    where?: SubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submissions to fetch.
     */
    orderBy?: Enumerable<SubmissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Submissions
    **/
    _count?: true | SubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubmissionMaxAggregateInputType
  }

  export type GetSubmissionAggregateType<T extends SubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubmission[P]>
      : GetScalarType<T[P], AggregateSubmission[P]>
  }




  export type SubmissionGroupByArgs = {
    where?: SubmissionWhereInput
    orderBy?: Enumerable<SubmissionOrderByWithAggregationInput>
    by: SubmissionScalarFieldEnum[]
    having?: SubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubmissionCountAggregateInputType | true
    _min?: SubmissionMinAggregateInputType
    _max?: SubmissionMaxAggregateInputType
  }


  export type SubmissionGroupByOutputType = {
    id: string
    contestId: string | null
    problemId: string
    createTime: Date
    username: string
    code: string
    result: JudgeStatus
    language: string
    shared: boolean
    status: JsonValue | null
    statistic_info: JsonValue
    _count: SubmissionCountAggregateOutputType | null
    _min: SubmissionMinAggregateOutputType | null
    _max: SubmissionMaxAggregateOutputType | null
  }

  type GetSubmissionGroupByPayload<T extends SubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], SubmissionGroupByOutputType[P]>
        }
      >
    >


  export type SubmissionSelect = {
    id?: boolean
    contestId?: boolean
    problemId?: boolean
    createTime?: boolean
    username?: boolean
    code?: boolean
    result?: boolean
    language?: boolean
    shared?: boolean
    status?: boolean
    statistic_info?: boolean
  }


  export type SubmissionGetPayload<S extends boolean | null | undefined | SubmissionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Submission :
    S extends undefined ? never :
    S extends { include: any } & (SubmissionArgs | SubmissionFindManyArgs)
    ? Submission 
    : S extends { select: any } & (SubmissionArgs | SubmissionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Submission ? Submission[P] : never
  } 
      : Submission


  type SubmissionCountArgs = 
    Omit<SubmissionFindManyArgs, 'select' | 'include'> & {
      select?: SubmissionCountAggregateInputType | true
    }

  export interface SubmissionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Submission that matches the filter.
     * @param {SubmissionFindUniqueArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubmissionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubmissionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Submission'> extends True ? Prisma__SubmissionClient<SubmissionGetPayload<T>> : Prisma__SubmissionClient<SubmissionGetPayload<T> | null, null>

    /**
     * Find one Submission that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SubmissionFindUniqueOrThrowArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SubmissionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SubmissionFindUniqueOrThrowArgs>
    ): Prisma__SubmissionClient<SubmissionGetPayload<T>>

    /**
     * Find the first Submission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionFindFirstArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubmissionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubmissionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Submission'> extends True ? Prisma__SubmissionClient<SubmissionGetPayload<T>> : Prisma__SubmissionClient<SubmissionGetPayload<T> | null, null>

    /**
     * Find the first Submission that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionFindFirstOrThrowArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SubmissionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SubmissionFindFirstOrThrowArgs>
    ): Prisma__SubmissionClient<SubmissionGetPayload<T>>

    /**
     * Find zero or more Submissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Submissions
     * const submissions = await prisma.submission.findMany()
     * 
     * // Get first 10 Submissions
     * const submissions = await prisma.submission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const submissionWithIdOnly = await prisma.submission.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubmissionFindManyArgs>(
      args?: SelectSubset<T, SubmissionFindManyArgs>
    ): Prisma.PrismaPromise<Array<SubmissionGetPayload<T>>>

    /**
     * Create a Submission.
     * @param {SubmissionCreateArgs} args - Arguments to create a Submission.
     * @example
     * // Create one Submission
     * const Submission = await prisma.submission.create({
     *   data: {
     *     // ... data to create a Submission
     *   }
     * })
     * 
    **/
    create<T extends SubmissionCreateArgs>(
      args: SelectSubset<T, SubmissionCreateArgs>
    ): Prisma__SubmissionClient<SubmissionGetPayload<T>>

    /**
     * Create many Submissions.
     *     @param {SubmissionCreateManyArgs} args - Arguments to create many Submissions.
     *     @example
     *     // Create many Submissions
     *     const submission = await prisma.submission.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubmissionCreateManyArgs>(
      args?: SelectSubset<T, SubmissionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Submission.
     * @param {SubmissionDeleteArgs} args - Arguments to delete one Submission.
     * @example
     * // Delete one Submission
     * const Submission = await prisma.submission.delete({
     *   where: {
     *     // ... filter to delete one Submission
     *   }
     * })
     * 
    **/
    delete<T extends SubmissionDeleteArgs>(
      args: SelectSubset<T, SubmissionDeleteArgs>
    ): Prisma__SubmissionClient<SubmissionGetPayload<T>>

    /**
     * Update one Submission.
     * @param {SubmissionUpdateArgs} args - Arguments to update one Submission.
     * @example
     * // Update one Submission
     * const submission = await prisma.submission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubmissionUpdateArgs>(
      args: SelectSubset<T, SubmissionUpdateArgs>
    ): Prisma__SubmissionClient<SubmissionGetPayload<T>>

    /**
     * Delete zero or more Submissions.
     * @param {SubmissionDeleteManyArgs} args - Arguments to filter Submissions to delete.
     * @example
     * // Delete a few Submissions
     * const { count } = await prisma.submission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubmissionDeleteManyArgs>(
      args?: SelectSubset<T, SubmissionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Submissions
     * const submission = await prisma.submission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubmissionUpdateManyArgs>(
      args: SelectSubset<T, SubmissionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Submission.
     * @param {SubmissionUpsertArgs} args - Arguments to update or create a Submission.
     * @example
     * // Update or create a Submission
     * const submission = await prisma.submission.upsert({
     *   create: {
     *     // ... data to create a Submission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Submission we want to update
     *   }
     * })
    **/
    upsert<T extends SubmissionUpsertArgs>(
      args: SelectSubset<T, SubmissionUpsertArgs>
    ): Prisma__SubmissionClient<SubmissionGetPayload<T>>

    /**
     * Count the number of Submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionCountArgs} args - Arguments to filter Submissions to count.
     * @example
     * // Count the number of Submissions
     * const count = await prisma.submission.count({
     *   where: {
     *     // ... the filter for the Submissions we want to count
     *   }
     * })
    **/
    count<T extends SubmissionCountArgs>(
      args?: Subset<T, SubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Submission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubmissionAggregateArgs>(args: Subset<T, SubmissionAggregateArgs>): Prisma.PrismaPromise<GetSubmissionAggregateType<T>>

    /**
     * Group by Submission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubmissionGroupByArgs['orderBy'] }
        : { orderBy?: SubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Submission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubmissionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Submission base type for findUnique actions
   */
  export type SubmissionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect | null
    /**
     * Filter, which Submission to fetch.
     */
    where: SubmissionWhereUniqueInput
  }

  /**
   * Submission findUnique
   */
  export interface SubmissionFindUniqueArgs extends SubmissionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Submission findUniqueOrThrow
   */
  export type SubmissionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect | null
    /**
     * Filter, which Submission to fetch.
     */
    where: SubmissionWhereUniqueInput
  }


  /**
   * Submission base type for findFirst actions
   */
  export type SubmissionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect | null
    /**
     * Filter, which Submission to fetch.
     */
    where?: SubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submissions to fetch.
     */
    orderBy?: Enumerable<SubmissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Submissions.
     */
    cursor?: SubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Submissions.
     */
    distinct?: Enumerable<SubmissionScalarFieldEnum>
  }

  /**
   * Submission findFirst
   */
  export interface SubmissionFindFirstArgs extends SubmissionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Submission findFirstOrThrow
   */
  export type SubmissionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect | null
    /**
     * Filter, which Submission to fetch.
     */
    where?: SubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submissions to fetch.
     */
    orderBy?: Enumerable<SubmissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Submissions.
     */
    cursor?: SubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Submissions.
     */
    distinct?: Enumerable<SubmissionScalarFieldEnum>
  }


  /**
   * Submission findMany
   */
  export type SubmissionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect | null
    /**
     * Filter, which Submissions to fetch.
     */
    where?: SubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submissions to fetch.
     */
    orderBy?: Enumerable<SubmissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Submissions.
     */
    cursor?: SubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submissions.
     */
    skip?: number
    distinct?: Enumerable<SubmissionScalarFieldEnum>
  }


  /**
   * Submission create
   */
  export type SubmissionCreateArgs = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect | null
    /**
     * The data needed to create a Submission.
     */
    data: XOR<SubmissionCreateInput, SubmissionUncheckedCreateInput>
  }


  /**
   * Submission createMany
   */
  export type SubmissionCreateManyArgs = {
    /**
     * The data used to create many Submissions.
     */
    data: Enumerable<SubmissionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Submission update
   */
  export type SubmissionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect | null
    /**
     * The data needed to update a Submission.
     */
    data: XOR<SubmissionUpdateInput, SubmissionUncheckedUpdateInput>
    /**
     * Choose, which Submission to update.
     */
    where: SubmissionWhereUniqueInput
  }


  /**
   * Submission updateMany
   */
  export type SubmissionUpdateManyArgs = {
    /**
     * The data used to update Submissions.
     */
    data: XOR<SubmissionUpdateManyMutationInput, SubmissionUncheckedUpdateManyInput>
    /**
     * Filter which Submissions to update
     */
    where?: SubmissionWhereInput
  }


  /**
   * Submission upsert
   */
  export type SubmissionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect | null
    /**
     * The filter to search for the Submission to update in case it exists.
     */
    where: SubmissionWhereUniqueInput
    /**
     * In case the Submission found by the `where` argument doesn't exist, create a new Submission with this data.
     */
    create: XOR<SubmissionCreateInput, SubmissionUncheckedCreateInput>
    /**
     * In case the Submission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubmissionUpdateInput, SubmissionUncheckedUpdateInput>
  }


  /**
   * Submission delete
   */
  export type SubmissionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect | null
    /**
     * Filter which Submission to delete.
     */
    where: SubmissionWhereUniqueInput
  }


  /**
   * Submission deleteMany
   */
  export type SubmissionDeleteManyArgs = {
    /**
     * Filter which Submissions to delete
     */
    where?: SubmissionWhereInput
  }


  /**
   * Submission without action
   */
  export type SubmissionArgs = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect | null
  }



  /**
   * Model ChildSubmission
   */


  export type AggregateChildSubmission = {
    _count: ChildSubmissionCountAggregateOutputType | null
    _avg: ChildSubmissionAvgAggregateOutputType | null
    _sum: ChildSubmissionSumAggregateOutputType | null
    _min: ChildSubmissionMinAggregateOutputType | null
    _max: ChildSubmissionMaxAggregateOutputType | null
  }

  export type ChildSubmissionAvgAggregateOutputType = {
    languageId: number | null
  }

  export type ChildSubmissionSumAggregateOutputType = {
    languageId: number | null
  }

  export type ChildSubmissionMinAggregateOutputType = {
    id: string | null
    parentId: string | null
    token: string | null
    languageId: number | null
  }

  export type ChildSubmissionMaxAggregateOutputType = {
    id: string | null
    parentId: string | null
    token: string | null
    languageId: number | null
  }

  export type ChildSubmissionCountAggregateOutputType = {
    id: number
    parentId: number
    status: number
    token: number
    languageId: number
    _all: number
  }


  export type ChildSubmissionAvgAggregateInputType = {
    languageId?: true
  }

  export type ChildSubmissionSumAggregateInputType = {
    languageId?: true
  }

  export type ChildSubmissionMinAggregateInputType = {
    id?: true
    parentId?: true
    token?: true
    languageId?: true
  }

  export type ChildSubmissionMaxAggregateInputType = {
    id?: true
    parentId?: true
    token?: true
    languageId?: true
  }

  export type ChildSubmissionCountAggregateInputType = {
    id?: true
    parentId?: true
    status?: true
    token?: true
    languageId?: true
    _all?: true
  }

  export type ChildSubmissionAggregateArgs = {
    /**
     * Filter which ChildSubmission to aggregate.
     */
    where?: ChildSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChildSubmissions to fetch.
     */
    orderBy?: Enumerable<ChildSubmissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChildSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChildSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChildSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChildSubmissions
    **/
    _count?: true | ChildSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChildSubmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChildSubmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChildSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChildSubmissionMaxAggregateInputType
  }

  export type GetChildSubmissionAggregateType<T extends ChildSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateChildSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChildSubmission[P]>
      : GetScalarType<T[P], AggregateChildSubmission[P]>
  }




  export type ChildSubmissionGroupByArgs = {
    where?: ChildSubmissionWhereInput
    orderBy?: Enumerable<ChildSubmissionOrderByWithAggregationInput>
    by: ChildSubmissionScalarFieldEnum[]
    having?: ChildSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChildSubmissionCountAggregateInputType | true
    _avg?: ChildSubmissionAvgAggregateInputType
    _sum?: ChildSubmissionSumAggregateInputType
    _min?: ChildSubmissionMinAggregateInputType
    _max?: ChildSubmissionMaxAggregateInputType
  }


  export type ChildSubmissionGroupByOutputType = {
    id: string
    parentId: string
    status: JsonValue
    token: string
    languageId: number
    _count: ChildSubmissionCountAggregateOutputType | null
    _avg: ChildSubmissionAvgAggregateOutputType | null
    _sum: ChildSubmissionSumAggregateOutputType | null
    _min: ChildSubmissionMinAggregateOutputType | null
    _max: ChildSubmissionMaxAggregateOutputType | null
  }

  type GetChildSubmissionGroupByPayload<T extends ChildSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ChildSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChildSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChildSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], ChildSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type ChildSubmissionSelect = {
    id?: boolean
    parentId?: boolean
    status?: boolean
    token?: boolean
    languageId?: boolean
  }


  export type ChildSubmissionGetPayload<S extends boolean | null | undefined | ChildSubmissionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ChildSubmission :
    S extends undefined ? never :
    S extends { include: any } & (ChildSubmissionArgs | ChildSubmissionFindManyArgs)
    ? ChildSubmission 
    : S extends { select: any } & (ChildSubmissionArgs | ChildSubmissionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ChildSubmission ? ChildSubmission[P] : never
  } 
      : ChildSubmission


  type ChildSubmissionCountArgs = 
    Omit<ChildSubmissionFindManyArgs, 'select' | 'include'> & {
      select?: ChildSubmissionCountAggregateInputType | true
    }

  export interface ChildSubmissionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ChildSubmission that matches the filter.
     * @param {ChildSubmissionFindUniqueArgs} args - Arguments to find a ChildSubmission
     * @example
     * // Get one ChildSubmission
     * const childSubmission = await prisma.childSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChildSubmissionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ChildSubmissionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ChildSubmission'> extends True ? Prisma__ChildSubmissionClient<ChildSubmissionGetPayload<T>> : Prisma__ChildSubmissionClient<ChildSubmissionGetPayload<T> | null, null>

    /**
     * Find one ChildSubmission that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ChildSubmissionFindUniqueOrThrowArgs} args - Arguments to find a ChildSubmission
     * @example
     * // Get one ChildSubmission
     * const childSubmission = await prisma.childSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ChildSubmissionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ChildSubmissionFindUniqueOrThrowArgs>
    ): Prisma__ChildSubmissionClient<ChildSubmissionGetPayload<T>>

    /**
     * Find the first ChildSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildSubmissionFindFirstArgs} args - Arguments to find a ChildSubmission
     * @example
     * // Get one ChildSubmission
     * const childSubmission = await prisma.childSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChildSubmissionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ChildSubmissionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ChildSubmission'> extends True ? Prisma__ChildSubmissionClient<ChildSubmissionGetPayload<T>> : Prisma__ChildSubmissionClient<ChildSubmissionGetPayload<T> | null, null>

    /**
     * Find the first ChildSubmission that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildSubmissionFindFirstOrThrowArgs} args - Arguments to find a ChildSubmission
     * @example
     * // Get one ChildSubmission
     * const childSubmission = await prisma.childSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ChildSubmissionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ChildSubmissionFindFirstOrThrowArgs>
    ): Prisma__ChildSubmissionClient<ChildSubmissionGetPayload<T>>

    /**
     * Find zero or more ChildSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildSubmissionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChildSubmissions
     * const childSubmissions = await prisma.childSubmission.findMany()
     * 
     * // Get first 10 ChildSubmissions
     * const childSubmissions = await prisma.childSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const childSubmissionWithIdOnly = await prisma.childSubmission.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ChildSubmissionFindManyArgs>(
      args?: SelectSubset<T, ChildSubmissionFindManyArgs>
    ): Prisma.PrismaPromise<Array<ChildSubmissionGetPayload<T>>>

    /**
     * Create a ChildSubmission.
     * @param {ChildSubmissionCreateArgs} args - Arguments to create a ChildSubmission.
     * @example
     * // Create one ChildSubmission
     * const ChildSubmission = await prisma.childSubmission.create({
     *   data: {
     *     // ... data to create a ChildSubmission
     *   }
     * })
     * 
    **/
    create<T extends ChildSubmissionCreateArgs>(
      args: SelectSubset<T, ChildSubmissionCreateArgs>
    ): Prisma__ChildSubmissionClient<ChildSubmissionGetPayload<T>>

    /**
     * Create many ChildSubmissions.
     *     @param {ChildSubmissionCreateManyArgs} args - Arguments to create many ChildSubmissions.
     *     @example
     *     // Create many ChildSubmissions
     *     const childSubmission = await prisma.childSubmission.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChildSubmissionCreateManyArgs>(
      args?: SelectSubset<T, ChildSubmissionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChildSubmission.
     * @param {ChildSubmissionDeleteArgs} args - Arguments to delete one ChildSubmission.
     * @example
     * // Delete one ChildSubmission
     * const ChildSubmission = await prisma.childSubmission.delete({
     *   where: {
     *     // ... filter to delete one ChildSubmission
     *   }
     * })
     * 
    **/
    delete<T extends ChildSubmissionDeleteArgs>(
      args: SelectSubset<T, ChildSubmissionDeleteArgs>
    ): Prisma__ChildSubmissionClient<ChildSubmissionGetPayload<T>>

    /**
     * Update one ChildSubmission.
     * @param {ChildSubmissionUpdateArgs} args - Arguments to update one ChildSubmission.
     * @example
     * // Update one ChildSubmission
     * const childSubmission = await prisma.childSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChildSubmissionUpdateArgs>(
      args: SelectSubset<T, ChildSubmissionUpdateArgs>
    ): Prisma__ChildSubmissionClient<ChildSubmissionGetPayload<T>>

    /**
     * Delete zero or more ChildSubmissions.
     * @param {ChildSubmissionDeleteManyArgs} args - Arguments to filter ChildSubmissions to delete.
     * @example
     * // Delete a few ChildSubmissions
     * const { count } = await prisma.childSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChildSubmissionDeleteManyArgs>(
      args?: SelectSubset<T, ChildSubmissionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChildSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChildSubmissions
     * const childSubmission = await prisma.childSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChildSubmissionUpdateManyArgs>(
      args: SelectSubset<T, ChildSubmissionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChildSubmission.
     * @param {ChildSubmissionUpsertArgs} args - Arguments to update or create a ChildSubmission.
     * @example
     * // Update or create a ChildSubmission
     * const childSubmission = await prisma.childSubmission.upsert({
     *   create: {
     *     // ... data to create a ChildSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChildSubmission we want to update
     *   }
     * })
    **/
    upsert<T extends ChildSubmissionUpsertArgs>(
      args: SelectSubset<T, ChildSubmissionUpsertArgs>
    ): Prisma__ChildSubmissionClient<ChildSubmissionGetPayload<T>>

    /**
     * Count the number of ChildSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildSubmissionCountArgs} args - Arguments to filter ChildSubmissions to count.
     * @example
     * // Count the number of ChildSubmissions
     * const count = await prisma.childSubmission.count({
     *   where: {
     *     // ... the filter for the ChildSubmissions we want to count
     *   }
     * })
    **/
    count<T extends ChildSubmissionCountArgs>(
      args?: Subset<T, ChildSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChildSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChildSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChildSubmissionAggregateArgs>(args: Subset<T, ChildSubmissionAggregateArgs>): Prisma.PrismaPromise<GetChildSubmissionAggregateType<T>>

    /**
     * Group by ChildSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChildSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChildSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: ChildSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChildSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChildSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ChildSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ChildSubmissionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ChildSubmission base type for findUnique actions
   */
  export type ChildSubmissionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ChildSubmission
     */
    select?: ChildSubmissionSelect | null
    /**
     * Filter, which ChildSubmission to fetch.
     */
    where: ChildSubmissionWhereUniqueInput
  }

  /**
   * ChildSubmission findUnique
   */
  export interface ChildSubmissionFindUniqueArgs extends ChildSubmissionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ChildSubmission findUniqueOrThrow
   */
  export type ChildSubmissionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ChildSubmission
     */
    select?: ChildSubmissionSelect | null
    /**
     * Filter, which ChildSubmission to fetch.
     */
    where: ChildSubmissionWhereUniqueInput
  }


  /**
   * ChildSubmission base type for findFirst actions
   */
  export type ChildSubmissionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ChildSubmission
     */
    select?: ChildSubmissionSelect | null
    /**
     * Filter, which ChildSubmission to fetch.
     */
    where?: ChildSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChildSubmissions to fetch.
     */
    orderBy?: Enumerable<ChildSubmissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChildSubmissions.
     */
    cursor?: ChildSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChildSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChildSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChildSubmissions.
     */
    distinct?: Enumerable<ChildSubmissionScalarFieldEnum>
  }

  /**
   * ChildSubmission findFirst
   */
  export interface ChildSubmissionFindFirstArgs extends ChildSubmissionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ChildSubmission findFirstOrThrow
   */
  export type ChildSubmissionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ChildSubmission
     */
    select?: ChildSubmissionSelect | null
    /**
     * Filter, which ChildSubmission to fetch.
     */
    where?: ChildSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChildSubmissions to fetch.
     */
    orderBy?: Enumerable<ChildSubmissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChildSubmissions.
     */
    cursor?: ChildSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChildSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChildSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChildSubmissions.
     */
    distinct?: Enumerable<ChildSubmissionScalarFieldEnum>
  }


  /**
   * ChildSubmission findMany
   */
  export type ChildSubmissionFindManyArgs = {
    /**
     * Select specific fields to fetch from the ChildSubmission
     */
    select?: ChildSubmissionSelect | null
    /**
     * Filter, which ChildSubmissions to fetch.
     */
    where?: ChildSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChildSubmissions to fetch.
     */
    orderBy?: Enumerable<ChildSubmissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChildSubmissions.
     */
    cursor?: ChildSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChildSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChildSubmissions.
     */
    skip?: number
    distinct?: Enumerable<ChildSubmissionScalarFieldEnum>
  }


  /**
   * ChildSubmission create
   */
  export type ChildSubmissionCreateArgs = {
    /**
     * Select specific fields to fetch from the ChildSubmission
     */
    select?: ChildSubmissionSelect | null
    /**
     * The data needed to create a ChildSubmission.
     */
    data: XOR<ChildSubmissionCreateInput, ChildSubmissionUncheckedCreateInput>
  }


  /**
   * ChildSubmission createMany
   */
  export type ChildSubmissionCreateManyArgs = {
    /**
     * The data used to create many ChildSubmissions.
     */
    data: Enumerable<ChildSubmissionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ChildSubmission update
   */
  export type ChildSubmissionUpdateArgs = {
    /**
     * Select specific fields to fetch from the ChildSubmission
     */
    select?: ChildSubmissionSelect | null
    /**
     * The data needed to update a ChildSubmission.
     */
    data: XOR<ChildSubmissionUpdateInput, ChildSubmissionUncheckedUpdateInput>
    /**
     * Choose, which ChildSubmission to update.
     */
    where: ChildSubmissionWhereUniqueInput
  }


  /**
   * ChildSubmission updateMany
   */
  export type ChildSubmissionUpdateManyArgs = {
    /**
     * The data used to update ChildSubmissions.
     */
    data: XOR<ChildSubmissionUpdateManyMutationInput, ChildSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which ChildSubmissions to update
     */
    where?: ChildSubmissionWhereInput
  }


  /**
   * ChildSubmission upsert
   */
  export type ChildSubmissionUpsertArgs = {
    /**
     * Select specific fields to fetch from the ChildSubmission
     */
    select?: ChildSubmissionSelect | null
    /**
     * The filter to search for the ChildSubmission to update in case it exists.
     */
    where: ChildSubmissionWhereUniqueInput
    /**
     * In case the ChildSubmission found by the `where` argument doesn't exist, create a new ChildSubmission with this data.
     */
    create: XOR<ChildSubmissionCreateInput, ChildSubmissionUncheckedCreateInput>
    /**
     * In case the ChildSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChildSubmissionUpdateInput, ChildSubmissionUncheckedUpdateInput>
  }


  /**
   * ChildSubmission delete
   */
  export type ChildSubmissionDeleteArgs = {
    /**
     * Select specific fields to fetch from the ChildSubmission
     */
    select?: ChildSubmissionSelect | null
    /**
     * Filter which ChildSubmission to delete.
     */
    where: ChildSubmissionWhereUniqueInput
  }


  /**
   * ChildSubmission deleteMany
   */
  export type ChildSubmissionDeleteManyArgs = {
    /**
     * Filter which ChildSubmissions to delete
     */
    where?: ChildSubmissionWhereInput
  }


  /**
   * ChildSubmission without action
   */
  export type ChildSubmissionArgs = {
    /**
     * Select specific fields to fetch from the ChildSubmission
     */
    select?: ChildSubmissionSelect | null
  }



  /**
   * Model Language
   */


  export type AggregateLanguage = {
    _count: LanguageCountAggregateOutputType | null
    _avg: LanguageAvgAggregateOutputType | null
    _sum: LanguageSumAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  export type LanguageAvgAggregateOutputType = {
    id: number | null
  }

  export type LanguageSumAggregateOutputType = {
    id: number | null
  }

  export type LanguageMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type LanguageMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type LanguageCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type LanguageAvgAggregateInputType = {
    id?: true
  }

  export type LanguageSumAggregateInputType = {
    id?: true
  }

  export type LanguageMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type LanguageMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type LanguageCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type LanguageAggregateArgs = {
    /**
     * Filter which Language to aggregate.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: Enumerable<LanguageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Languages
    **/
    _count?: true | LanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LanguageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LanguageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LanguageMaxAggregateInputType
  }

  export type GetLanguageAggregateType<T extends LanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguage[P]>
      : GetScalarType<T[P], AggregateLanguage[P]>
  }




  export type LanguageGroupByArgs = {
    where?: LanguageWhereInput
    orderBy?: Enumerable<LanguageOrderByWithAggregationInput>
    by: LanguageScalarFieldEnum[]
    having?: LanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LanguageCountAggregateInputType | true
    _avg?: LanguageAvgAggregateInputType
    _sum?: LanguageSumAggregateInputType
    _min?: LanguageMinAggregateInputType
    _max?: LanguageMaxAggregateInputType
  }


  export type LanguageGroupByOutputType = {
    id: number
    name: string
    _count: LanguageCountAggregateOutputType | null
    _avg: LanguageAvgAggregateOutputType | null
    _sum: LanguageSumAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  type GetLanguageGroupByPayload<T extends LanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LanguageGroupByOutputType[P]>
            : GetScalarType<T[P], LanguageGroupByOutputType[P]>
        }
      >
    >


  export type LanguageSelect = {
    id?: boolean
    name?: boolean
  }


  export type LanguageGetPayload<S extends boolean | null | undefined | LanguageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Language :
    S extends undefined ? never :
    S extends { include: any } & (LanguageArgs | LanguageFindManyArgs)
    ? Language 
    : S extends { select: any } & (LanguageArgs | LanguageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Language ? Language[P] : never
  } 
      : Language


  type LanguageCountArgs = 
    Omit<LanguageFindManyArgs, 'select' | 'include'> & {
      select?: LanguageCountAggregateInputType | true
    }

  export interface LanguageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Language that matches the filter.
     * @param {LanguageFindUniqueArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LanguageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LanguageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Language'> extends True ? Prisma__LanguageClient<LanguageGetPayload<T>> : Prisma__LanguageClient<LanguageGetPayload<T> | null, null>

    /**
     * Find one Language that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LanguageFindUniqueOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LanguageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LanguageFindUniqueOrThrowArgs>
    ): Prisma__LanguageClient<LanguageGetPayload<T>>

    /**
     * Find the first Language that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LanguageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LanguageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Language'> extends True ? Prisma__LanguageClient<LanguageGetPayload<T>> : Prisma__LanguageClient<LanguageGetPayload<T> | null, null>

    /**
     * Find the first Language that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LanguageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LanguageFindFirstOrThrowArgs>
    ): Prisma__LanguageClient<LanguageGetPayload<T>>

    /**
     * Find zero or more Languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Languages
     * const languages = await prisma.language.findMany()
     * 
     * // Get first 10 Languages
     * const languages = await prisma.language.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const languageWithIdOnly = await prisma.language.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LanguageFindManyArgs>(
      args?: SelectSubset<T, LanguageFindManyArgs>
    ): Prisma.PrismaPromise<Array<LanguageGetPayload<T>>>

    /**
     * Create a Language.
     * @param {LanguageCreateArgs} args - Arguments to create a Language.
     * @example
     * // Create one Language
     * const Language = await prisma.language.create({
     *   data: {
     *     // ... data to create a Language
     *   }
     * })
     * 
    **/
    create<T extends LanguageCreateArgs>(
      args: SelectSubset<T, LanguageCreateArgs>
    ): Prisma__LanguageClient<LanguageGetPayload<T>>

    /**
     * Create many Languages.
     *     @param {LanguageCreateManyArgs} args - Arguments to create many Languages.
     *     @example
     *     // Create many Languages
     *     const language = await prisma.language.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LanguageCreateManyArgs>(
      args?: SelectSubset<T, LanguageCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Language.
     * @param {LanguageDeleteArgs} args - Arguments to delete one Language.
     * @example
     * // Delete one Language
     * const Language = await prisma.language.delete({
     *   where: {
     *     // ... filter to delete one Language
     *   }
     * })
     * 
    **/
    delete<T extends LanguageDeleteArgs>(
      args: SelectSubset<T, LanguageDeleteArgs>
    ): Prisma__LanguageClient<LanguageGetPayload<T>>

    /**
     * Update one Language.
     * @param {LanguageUpdateArgs} args - Arguments to update one Language.
     * @example
     * // Update one Language
     * const language = await prisma.language.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LanguageUpdateArgs>(
      args: SelectSubset<T, LanguageUpdateArgs>
    ): Prisma__LanguageClient<LanguageGetPayload<T>>

    /**
     * Delete zero or more Languages.
     * @param {LanguageDeleteManyArgs} args - Arguments to filter Languages to delete.
     * @example
     * // Delete a few Languages
     * const { count } = await prisma.language.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LanguageDeleteManyArgs>(
      args?: SelectSubset<T, LanguageDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LanguageUpdateManyArgs>(
      args: SelectSubset<T, LanguageUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Language.
     * @param {LanguageUpsertArgs} args - Arguments to update or create a Language.
     * @example
     * // Update or create a Language
     * const language = await prisma.language.upsert({
     *   create: {
     *     // ... data to create a Language
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Language we want to update
     *   }
     * })
    **/
    upsert<T extends LanguageUpsertArgs>(
      args: SelectSubset<T, LanguageUpsertArgs>
    ): Prisma__LanguageClient<LanguageGetPayload<T>>

    /**
     * Count the number of Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageCountArgs} args - Arguments to filter Languages to count.
     * @example
     * // Count the number of Languages
     * const count = await prisma.language.count({
     *   where: {
     *     // ... the filter for the Languages we want to count
     *   }
     * })
    **/
    count<T extends LanguageCountArgs>(
      args?: Subset<T, LanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LanguageAggregateArgs>(args: Subset<T, LanguageAggregateArgs>): Prisma.PrismaPromise<GetLanguageAggregateType<T>>

    /**
     * Group by Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LanguageGroupByArgs['orderBy'] }
        : { orderBy?: LanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Language.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LanguageClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Language base type for findUnique actions
   */
  export type LanguageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findUnique
   */
  export interface LanguageFindUniqueArgs extends LanguageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Language findUniqueOrThrow
   */
  export type LanguageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }


  /**
   * Language base type for findFirst actions
   */
  export type LanguageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: Enumerable<LanguageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: Enumerable<LanguageScalarFieldEnum>
  }

  /**
   * Language findFirst
   */
  export interface LanguageFindFirstArgs extends LanguageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Language findFirstOrThrow
   */
  export type LanguageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: Enumerable<LanguageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: Enumerable<LanguageScalarFieldEnum>
  }


  /**
   * Language findMany
   */
  export type LanguageFindManyArgs = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect | null
    /**
     * Filter, which Languages to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: Enumerable<LanguageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    distinct?: Enumerable<LanguageScalarFieldEnum>
  }


  /**
   * Language create
   */
  export type LanguageCreateArgs = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect | null
    /**
     * The data needed to create a Language.
     */
    data: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
  }


  /**
   * Language createMany
   */
  export type LanguageCreateManyArgs = {
    /**
     * The data used to create many Languages.
     */
    data: Enumerable<LanguageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Language update
   */
  export type LanguageUpdateArgs = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect | null
    /**
     * The data needed to update a Language.
     */
    data: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
    /**
     * Choose, which Language to update.
     */
    where: LanguageWhereUniqueInput
  }


  /**
   * Language updateMany
   */
  export type LanguageUpdateManyArgs = {
    /**
     * The data used to update Languages.
     */
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     */
    where?: LanguageWhereInput
  }


  /**
   * Language upsert
   */
  export type LanguageUpsertArgs = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect | null
    /**
     * The filter to search for the Language to update in case it exists.
     */
    where: LanguageWhereUniqueInput
    /**
     * In case the Language found by the `where` argument doesn't exist, create a new Language with this data.
     */
    create: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
    /**
     * In case the Language was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
  }


  /**
   * Language delete
   */
  export type LanguageDeleteArgs = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect | null
    /**
     * Filter which Language to delete.
     */
    where: LanguageWhereUniqueInput
  }


  /**
   * Language deleteMany
   */
  export type LanguageDeleteManyArgs = {
    /**
     * Filter which Languages to delete
     */
    where?: LanguageWhereInput
  }


  /**
   * Language without action
   */
  export type LanguageArgs = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect | null
  }



  /**
   * Model Testcase
   */


  export type AggregateTestcase = {
    _count: TestcaseCountAggregateOutputType | null
    _avg: TestcaseAvgAggregateOutputType | null
    _sum: TestcaseSumAggregateOutputType | null
    _min: TestcaseMinAggregateOutputType | null
    _max: TestcaseMaxAggregateOutputType | null
  }

  export type TestcaseAvgAggregateOutputType = {
    subTestNumber: number | null
  }

  export type TestcaseSumAggregateOutputType = {
    subTestNumber: number | null
  }

  export type TestcaseMinAggregateOutputType = {
    id: string | null
    problemId: string | null
    subTestNumber: number | null
  }

  export type TestcaseMaxAggregateOutputType = {
    id: string | null
    problemId: string | null
    subTestNumber: number | null
  }

  export type TestcaseCountAggregateOutputType = {
    id: number
    problemId: number
    subTestNumber: number
    description: number
    _all: number
  }


  export type TestcaseAvgAggregateInputType = {
    subTestNumber?: true
  }

  export type TestcaseSumAggregateInputType = {
    subTestNumber?: true
  }

  export type TestcaseMinAggregateInputType = {
    id?: true
    problemId?: true
    subTestNumber?: true
  }

  export type TestcaseMaxAggregateInputType = {
    id?: true
    problemId?: true
    subTestNumber?: true
  }

  export type TestcaseCountAggregateInputType = {
    id?: true
    problemId?: true
    subTestNumber?: true
    description?: true
    _all?: true
  }

  export type TestcaseAggregateArgs = {
    /**
     * Filter which Testcase to aggregate.
     */
    where?: TestcaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testcases to fetch.
     */
    orderBy?: Enumerable<TestcaseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestcaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testcases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testcases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Testcases
    **/
    _count?: true | TestcaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestcaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestcaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestcaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestcaseMaxAggregateInputType
  }

  export type GetTestcaseAggregateType<T extends TestcaseAggregateArgs> = {
        [P in keyof T & keyof AggregateTestcase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestcase[P]>
      : GetScalarType<T[P], AggregateTestcase[P]>
  }




  export type TestcaseGroupByArgs = {
    where?: TestcaseWhereInput
    orderBy?: Enumerable<TestcaseOrderByWithAggregationInput>
    by: TestcaseScalarFieldEnum[]
    having?: TestcaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestcaseCountAggregateInputType | true
    _avg?: TestcaseAvgAggregateInputType
    _sum?: TestcaseSumAggregateInputType
    _min?: TestcaseMinAggregateInputType
    _max?: TestcaseMaxAggregateInputType
  }


  export type TestcaseGroupByOutputType = {
    id: string
    problemId: string
    subTestNumber: number
    description: JsonValue
    _count: TestcaseCountAggregateOutputType | null
    _avg: TestcaseAvgAggregateOutputType | null
    _sum: TestcaseSumAggregateOutputType | null
    _min: TestcaseMinAggregateOutputType | null
    _max: TestcaseMaxAggregateOutputType | null
  }

  type GetTestcaseGroupByPayload<T extends TestcaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TestcaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestcaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestcaseGroupByOutputType[P]>
            : GetScalarType<T[P], TestcaseGroupByOutputType[P]>
        }
      >
    >


  export type TestcaseSelect = {
    id?: boolean
    problemId?: boolean
    subTestNumber?: boolean
    description?: boolean
    problem?: boolean | CodingProblemArgs
  }


  export type TestcaseInclude = {
    problem?: boolean | CodingProblemArgs
  }

  export type TestcaseGetPayload<S extends boolean | null | undefined | TestcaseArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Testcase :
    S extends undefined ? never :
    S extends { include: any } & (TestcaseArgs | TestcaseFindManyArgs)
    ? Testcase  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'problem' ? CodingProblemGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TestcaseArgs | TestcaseFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'problem' ? CodingProblemGetPayload<S['select'][P]> :  P extends keyof Testcase ? Testcase[P] : never
  } 
      : Testcase


  type TestcaseCountArgs = 
    Omit<TestcaseFindManyArgs, 'select' | 'include'> & {
      select?: TestcaseCountAggregateInputType | true
    }

  export interface TestcaseDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Testcase that matches the filter.
     * @param {TestcaseFindUniqueArgs} args - Arguments to find a Testcase
     * @example
     * // Get one Testcase
     * const testcase = await prisma.testcase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TestcaseFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TestcaseFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Testcase'> extends True ? Prisma__TestcaseClient<TestcaseGetPayload<T>> : Prisma__TestcaseClient<TestcaseGetPayload<T> | null, null>

    /**
     * Find one Testcase that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TestcaseFindUniqueOrThrowArgs} args - Arguments to find a Testcase
     * @example
     * // Get one Testcase
     * const testcase = await prisma.testcase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TestcaseFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TestcaseFindUniqueOrThrowArgs>
    ): Prisma__TestcaseClient<TestcaseGetPayload<T>>

    /**
     * Find the first Testcase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestcaseFindFirstArgs} args - Arguments to find a Testcase
     * @example
     * // Get one Testcase
     * const testcase = await prisma.testcase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TestcaseFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TestcaseFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Testcase'> extends True ? Prisma__TestcaseClient<TestcaseGetPayload<T>> : Prisma__TestcaseClient<TestcaseGetPayload<T> | null, null>

    /**
     * Find the first Testcase that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestcaseFindFirstOrThrowArgs} args - Arguments to find a Testcase
     * @example
     * // Get one Testcase
     * const testcase = await prisma.testcase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TestcaseFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TestcaseFindFirstOrThrowArgs>
    ): Prisma__TestcaseClient<TestcaseGetPayload<T>>

    /**
     * Find zero or more Testcases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestcaseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Testcases
     * const testcases = await prisma.testcase.findMany()
     * 
     * // Get first 10 Testcases
     * const testcases = await prisma.testcase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testcaseWithIdOnly = await prisma.testcase.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TestcaseFindManyArgs>(
      args?: SelectSubset<T, TestcaseFindManyArgs>
    ): Prisma.PrismaPromise<Array<TestcaseGetPayload<T>>>

    /**
     * Create a Testcase.
     * @param {TestcaseCreateArgs} args - Arguments to create a Testcase.
     * @example
     * // Create one Testcase
     * const Testcase = await prisma.testcase.create({
     *   data: {
     *     // ... data to create a Testcase
     *   }
     * })
     * 
    **/
    create<T extends TestcaseCreateArgs>(
      args: SelectSubset<T, TestcaseCreateArgs>
    ): Prisma__TestcaseClient<TestcaseGetPayload<T>>

    /**
     * Create many Testcases.
     *     @param {TestcaseCreateManyArgs} args - Arguments to create many Testcases.
     *     @example
     *     // Create many Testcases
     *     const testcase = await prisma.testcase.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TestcaseCreateManyArgs>(
      args?: SelectSubset<T, TestcaseCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Testcase.
     * @param {TestcaseDeleteArgs} args - Arguments to delete one Testcase.
     * @example
     * // Delete one Testcase
     * const Testcase = await prisma.testcase.delete({
     *   where: {
     *     // ... filter to delete one Testcase
     *   }
     * })
     * 
    **/
    delete<T extends TestcaseDeleteArgs>(
      args: SelectSubset<T, TestcaseDeleteArgs>
    ): Prisma__TestcaseClient<TestcaseGetPayload<T>>

    /**
     * Update one Testcase.
     * @param {TestcaseUpdateArgs} args - Arguments to update one Testcase.
     * @example
     * // Update one Testcase
     * const testcase = await prisma.testcase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TestcaseUpdateArgs>(
      args: SelectSubset<T, TestcaseUpdateArgs>
    ): Prisma__TestcaseClient<TestcaseGetPayload<T>>

    /**
     * Delete zero or more Testcases.
     * @param {TestcaseDeleteManyArgs} args - Arguments to filter Testcases to delete.
     * @example
     * // Delete a few Testcases
     * const { count } = await prisma.testcase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TestcaseDeleteManyArgs>(
      args?: SelectSubset<T, TestcaseDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Testcases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestcaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Testcases
     * const testcase = await prisma.testcase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TestcaseUpdateManyArgs>(
      args: SelectSubset<T, TestcaseUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Testcase.
     * @param {TestcaseUpsertArgs} args - Arguments to update or create a Testcase.
     * @example
     * // Update or create a Testcase
     * const testcase = await prisma.testcase.upsert({
     *   create: {
     *     // ... data to create a Testcase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Testcase we want to update
     *   }
     * })
    **/
    upsert<T extends TestcaseUpsertArgs>(
      args: SelectSubset<T, TestcaseUpsertArgs>
    ): Prisma__TestcaseClient<TestcaseGetPayload<T>>

    /**
     * Count the number of Testcases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestcaseCountArgs} args - Arguments to filter Testcases to count.
     * @example
     * // Count the number of Testcases
     * const count = await prisma.testcase.count({
     *   where: {
     *     // ... the filter for the Testcases we want to count
     *   }
     * })
    **/
    count<T extends TestcaseCountArgs>(
      args?: Subset<T, TestcaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestcaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Testcase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestcaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestcaseAggregateArgs>(args: Subset<T, TestcaseAggregateArgs>): Prisma.PrismaPromise<GetTestcaseAggregateType<T>>

    /**
     * Group by Testcase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestcaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestcaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestcaseGroupByArgs['orderBy'] }
        : { orderBy?: TestcaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestcaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestcaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Testcase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TestcaseClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    problem<T extends CodingProblemArgs= {}>(args?: Subset<T, CodingProblemArgs>): Prisma__CodingProblemClient<CodingProblemGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Testcase base type for findUnique actions
   */
  export type TestcaseFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Testcase
     */
    select?: TestcaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestcaseInclude | null
    /**
     * Filter, which Testcase to fetch.
     */
    where: TestcaseWhereUniqueInput
  }

  /**
   * Testcase findUnique
   */
  export interface TestcaseFindUniqueArgs extends TestcaseFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Testcase findUniqueOrThrow
   */
  export type TestcaseFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Testcase
     */
    select?: TestcaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestcaseInclude | null
    /**
     * Filter, which Testcase to fetch.
     */
    where: TestcaseWhereUniqueInput
  }


  /**
   * Testcase base type for findFirst actions
   */
  export type TestcaseFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Testcase
     */
    select?: TestcaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestcaseInclude | null
    /**
     * Filter, which Testcase to fetch.
     */
    where?: TestcaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testcases to fetch.
     */
    orderBy?: Enumerable<TestcaseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Testcases.
     */
    cursor?: TestcaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testcases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testcases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Testcases.
     */
    distinct?: Enumerable<TestcaseScalarFieldEnum>
  }

  /**
   * Testcase findFirst
   */
  export interface TestcaseFindFirstArgs extends TestcaseFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Testcase findFirstOrThrow
   */
  export type TestcaseFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Testcase
     */
    select?: TestcaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestcaseInclude | null
    /**
     * Filter, which Testcase to fetch.
     */
    where?: TestcaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testcases to fetch.
     */
    orderBy?: Enumerable<TestcaseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Testcases.
     */
    cursor?: TestcaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testcases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testcases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Testcases.
     */
    distinct?: Enumerable<TestcaseScalarFieldEnum>
  }


  /**
   * Testcase findMany
   */
  export type TestcaseFindManyArgs = {
    /**
     * Select specific fields to fetch from the Testcase
     */
    select?: TestcaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestcaseInclude | null
    /**
     * Filter, which Testcases to fetch.
     */
    where?: TestcaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testcases to fetch.
     */
    orderBy?: Enumerable<TestcaseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Testcases.
     */
    cursor?: TestcaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testcases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testcases.
     */
    skip?: number
    distinct?: Enumerable<TestcaseScalarFieldEnum>
  }


  /**
   * Testcase create
   */
  export type TestcaseCreateArgs = {
    /**
     * Select specific fields to fetch from the Testcase
     */
    select?: TestcaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestcaseInclude | null
    /**
     * The data needed to create a Testcase.
     */
    data: XOR<TestcaseCreateInput, TestcaseUncheckedCreateInput>
  }


  /**
   * Testcase createMany
   */
  export type TestcaseCreateManyArgs = {
    /**
     * The data used to create many Testcases.
     */
    data: Enumerable<TestcaseCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Testcase update
   */
  export type TestcaseUpdateArgs = {
    /**
     * Select specific fields to fetch from the Testcase
     */
    select?: TestcaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestcaseInclude | null
    /**
     * The data needed to update a Testcase.
     */
    data: XOR<TestcaseUpdateInput, TestcaseUncheckedUpdateInput>
    /**
     * Choose, which Testcase to update.
     */
    where: TestcaseWhereUniqueInput
  }


  /**
   * Testcase updateMany
   */
  export type TestcaseUpdateManyArgs = {
    /**
     * The data used to update Testcases.
     */
    data: XOR<TestcaseUpdateManyMutationInput, TestcaseUncheckedUpdateManyInput>
    /**
     * Filter which Testcases to update
     */
    where?: TestcaseWhereInput
  }


  /**
   * Testcase upsert
   */
  export type TestcaseUpsertArgs = {
    /**
     * Select specific fields to fetch from the Testcase
     */
    select?: TestcaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestcaseInclude | null
    /**
     * The filter to search for the Testcase to update in case it exists.
     */
    where: TestcaseWhereUniqueInput
    /**
     * In case the Testcase found by the `where` argument doesn't exist, create a new Testcase with this data.
     */
    create: XOR<TestcaseCreateInput, TestcaseUncheckedCreateInput>
    /**
     * In case the Testcase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestcaseUpdateInput, TestcaseUncheckedUpdateInput>
  }


  /**
   * Testcase delete
   */
  export type TestcaseDeleteArgs = {
    /**
     * Select specific fields to fetch from the Testcase
     */
    select?: TestcaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestcaseInclude | null
    /**
     * Filter which Testcase to delete.
     */
    where: TestcaseWhereUniqueInput
  }


  /**
   * Testcase deleteMany
   */
  export type TestcaseDeleteManyArgs = {
    /**
     * Filter which Testcases to delete
     */
    where?: TestcaseWhereInput
  }


  /**
   * Testcase without action
   */
  export type TestcaseArgs = {
    /**
     * Select specific fields to fetch from the Testcase
     */
    select?: TestcaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestcaseInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AuthorCodingProblemScalarFieldEnum: {
    username: 'username',
    codingProblemId: 'codingProblemId'
  };

  export type AuthorCodingProblemScalarFieldEnum = (typeof AuthorCodingProblemScalarFieldEnum)[keyof typeof AuthorCodingProblemScalarFieldEnum]


  export const AuthorMathProblemScalarFieldEnum: {
    username: 'username',
    mathProblemId: 'mathProblemId'
  };

  export type AuthorMathProblemScalarFieldEnum = (typeof AuthorMathProblemScalarFieldEnum)[keyof typeof AuthorMathProblemScalarFieldEnum]


  export const ChatMessageScalarFieldEnum: {
    id: 'id',
    content: 'content',
    authorId: 'authorId',
    createdAt: 'createdAt',
    referenceMessage: 'referenceMessage',
    sessionId: 'sessionId'
  };

  export type ChatMessageScalarFieldEnum = (typeof ChatMessageScalarFieldEnum)[keyof typeof ChatMessageScalarFieldEnum]


  export const ChatSessionScalarFieldEnum: {
    id: 'id',
    lastMessage: 'lastMessage',
    lastUpdate: 'lastUpdate',
    groupId: 'groupId',
    type: 'type',
    usersInfo: 'usersInfo'
  };

  export type ChatSessionScalarFieldEnum = (typeof ChatSessionScalarFieldEnum)[keyof typeof ChatSessionScalarFieldEnum]


  export const ChatSessionUserScalarFieldEnum: {
    sessionId: 'sessionId',
    username: 'username',
    unseenCnt: 'unseenCnt',
    joinedAt: 'joinedAt'
  };

  export type ChatSessionUserScalarFieldEnum = (typeof ChatSessionUserScalarFieldEnum)[keyof typeof ChatSessionUserScalarFieldEnum]


  export const ChildSubmissionScalarFieldEnum: {
    id: 'id',
    parentId: 'parentId',
    status: 'status',
    token: 'token',
    languageId: 'languageId'
  };

  export type ChildSubmissionScalarFieldEnum = (typeof ChildSubmissionScalarFieldEnum)[keyof typeof ChildSubmissionScalarFieldEnum]


  export const CodefocesTagProblemScalarFieldEnum: {
    problemId: 'problemId',
    codeforcesTagId: 'codeforcesTagId'
  };

  export type CodefocesTagProblemScalarFieldEnum = (typeof CodefocesTagProblemScalarFieldEnum)[keyof typeof CodefocesTagProblemScalarFieldEnum]


  export const CodeforcesTagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    parentId: 'parentId'
  };

  export type CodeforcesTagScalarFieldEnum = (typeof CodeforcesTagScalarFieldEnum)[keyof typeof CodeforcesTagScalarFieldEnum]


  export const CodingProblemCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type CodingProblemCategoryScalarFieldEnum = (typeof CodingProblemCategoryScalarFieldEnum)[keyof typeof CodingProblemCategoryScalarFieldEnum]


  export const CodingProblemScalarFieldEnum: {
    id: 'id',
    code: 'code',
    title: 'title',
    categoryId: 'categoryId',
    link: 'link',
    description: 'description',
    timeLimit: 'timeLimit',
    memoryLimit: 'memoryLimit',
    difficulty: 'difficulty',
    practicePoint: 'practicePoint',
    totalPoint: 'totalPoint',
    submissionNumber: 'submissionNumber',
    acceptedNumber: 'acceptedNumber',
    contestId: 'contestId',
    visibleFrom: 'visibleFrom'
  };

  export type CodingProblemScalarFieldEnum = (typeof CodingProblemScalarFieldEnum)[keyof typeof CodingProblemScalarFieldEnum]


  export const CodingProblemTagScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type CodingProblemTagScalarFieldEnum = (typeof CodingProblemTagScalarFieldEnum)[keyof typeof CodingProblemTagScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    threadId: 'threadId',
    parentId: 'parentId',
    rootId: 'rootId',
    totalChildren: 'totalChildren',
    depth: 'depth',
    likes: 'likes',
    parentUsername: 'parentUsername',
    creatorId: 'creatorId',
    published: 'published',
    createdAt: 'createdAt',
    content: 'content'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const ContestScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    realTimeRank: 'realTimeRank',
    password: 'password',
    ruleType: 'ruleType',
    startTime: 'startTime',
    duration: 'duration',
    endTime: 'endTime',
    createTime: 'createTime',
    lastUpdateTime: 'lastUpdateTime',
    visible: 'visible'
  };

  export type ContestScalarFieldEnum = (typeof ContestScalarFieldEnum)[keyof typeof ContestScalarFieldEnum]


  export const FriendRequestScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    recieverId: 'recieverId',
    disable: 'disable'
  };

  export type FriendRequestScalarFieldEnum = (typeof FriendRequestScalarFieldEnum)[keyof typeof FriendRequestScalarFieldEnum]


  export const FriendShipScalarFieldEnum: {
    id: 'id',
    username1: 'username1',
    username2: 'username2',
    establishedAt: 'establishedAt'
  };

  export type FriendShipScalarFieldEnum = (typeof FriendShipScalarFieldEnum)[keyof typeof FriendShipScalarFieldEnum]


  export const GroupPostMessageScalarFieldEnum: {
    id: 'id',
    content: 'content',
    authorId: 'authorId',
    createdAt: 'createdAt',
    referenceMessage: 'referenceMessage',
    postId: 'postId'
  };

  export type GroupPostMessageScalarFieldEnum = (typeof GroupPostMessageScalarFieldEnum)[keyof typeof GroupPostMessageScalarFieldEnum]


  export const GroupPostScalarFieldEnum: {
    id: 'id',
    content: 'content',
    authorId: 'authorId',
    createdAt: 'createdAt',
    groupId: 'groupId',
    title: 'title'
  };

  export type GroupPostScalarFieldEnum = (typeof GroupPostScalarFieldEnum)[keyof typeof GroupPostScalarFieldEnum]


  export const GroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    creatorId: 'creatorId',
    generalChatSessionId: 'generalChatSessionId',
    createdAt: 'createdAt'
  };

  export type GroupScalarFieldEnum = (typeof GroupScalarFieldEnum)[keyof typeof GroupScalarFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const LanguageScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type LanguageScalarFieldEnum = (typeof LanguageScalarFieldEnum)[keyof typeof LanguageScalarFieldEnum]


  export const MathNoteScalarFieldEnum: {
    creatorId: 'creatorId',
    content: 'content',
    mathProblemId: 'mathProblemId',
    createdAt: 'createdAt',
    imageLink: 'imageLink'
  };

  export type MathNoteScalarFieldEnum = (typeof MathNoteScalarFieldEnum)[keyof typeof MathNoteScalarFieldEnum]


  export const MathProblemCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type MathProblemCategoryScalarFieldEnum = (typeof MathProblemCategoryScalarFieldEnum)[keyof typeof MathProblemCategoryScalarFieldEnum]


  export const MathProblemScalarFieldEnum: {
    id: 'id',
    title: 'title',
    categoryId: 'categoryId',
    link: 'link',
    description: 'description',
    hint: 'hint',
    difficulty: 'difficulty',
    practicePoint: 'practicePoint',
    totalPoint: 'totalPoint',
    prevProblems: 'prevProblems',
    nextProblems: 'nextProblems',
    numSolution: 'numSolution',
    numCheckedSolution: 'numCheckedSolution'
  };

  export type MathProblemScalarFieldEnum = (typeof MathProblemScalarFieldEnum)[keyof typeof MathProblemScalarFieldEnum]


  export const MathProblemSetScalarFieldEnum: {
    id: 'id',
    title: 'title',
    creatorId: 'creatorId',
    numberProb: 'numberProb'
  };

  export type MathProblemSetScalarFieldEnum = (typeof MathProblemSetScalarFieldEnum)[keyof typeof MathProblemSetScalarFieldEnum]


  export const MathProblemTagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    parentId: 'parentId',
    nextSibling: 'nextSibling',
    prevSibling: 'prevSibling'
  };

  export type MathProblemTagScalarFieldEnum = (typeof MathProblemTagScalarFieldEnum)[keyof typeof MathProblemTagScalarFieldEnum]


  export const MathSetProbRelScalarFieldEnum: {
    problemId: 'problemId',
    setId: 'setId',
    order: 'order'
  };

  export type MathSetProbRelScalarFieldEnum = (typeof MathSetProbRelScalarFieldEnum)[keyof typeof MathSetProbRelScalarFieldEnum]


  export const MathSolutionScalarFieldEnum: {
    creatorId: 'creatorId',
    content: 'content',
    mathProblemId: 'mathProblemId',
    createdAt: 'createdAt',
    checked: 'checked',
    imageLink: 'imageLink'
  };

  export type MathSolutionScalarFieldEnum = (typeof MathSolutionScalarFieldEnum)[keyof typeof MathSolutionScalarFieldEnum]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const SharePTPScalarFieldEnum: {
    id: 'id',
    resourceId: 'resourceId',
    resourceType: 'resourceType',
    senderId: 'senderId',
    receiverId: 'receiverId',
    resourceLink: 'resourceLink',
    look: 'look',
    createdAt: 'createdAt'
  };

  export type SharePTPScalarFieldEnum = (typeof SharePTPScalarFieldEnum)[keyof typeof SharePTPScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const SubmissionScalarFieldEnum: {
    id: 'id',
    contestId: 'contestId',
    problemId: 'problemId',
    createTime: 'createTime',
    username: 'username',
    code: 'code',
    result: 'result',
    language: 'language',
    shared: 'shared',
    status: 'status',
    statistic_info: 'statistic_info'
  };

  export type SubmissionScalarFieldEnum = (typeof SubmissionScalarFieldEnum)[keyof typeof SubmissionScalarFieldEnum]


  export const TagCodingProblemScalarFieldEnum: {
    tagId: 'tagId',
    codingProblemId: 'codingProblemId'
  };

  export type TagCodingProblemScalarFieldEnum = (typeof TagCodingProblemScalarFieldEnum)[keyof typeof TagCodingProblemScalarFieldEnum]


  export const TagMathProblemScalarFieldEnum: {
    tagId: 'tagId',
    mathProblemId: 'mathProblemId'
  };

  export type TagMathProblemScalarFieldEnum = (typeof TagMathProblemScalarFieldEnum)[keyof typeof TagMathProblemScalarFieldEnum]


  export const TestcaseScalarFieldEnum: {
    id: 'id',
    problemId: 'problemId',
    subTestNumber: 'subTestNumber',
    description: 'description'
  };

  export type TestcaseScalarFieldEnum = (typeof TestcaseScalarFieldEnum)[keyof typeof TestcaseScalarFieldEnum]


  export const ThreadCategoryScalarFieldEnum: {
    id: 'id',
    parentId: 'parentId',
    title: 'title'
  };

  export type ThreadCategoryScalarFieldEnum = (typeof ThreadCategoryScalarFieldEnum)[keyof typeof ThreadCategoryScalarFieldEnum]


  export const ThreadScalarFieldEnum: {
    id: 'id',
    authorId: 'authorId',
    parentId: 'parentId',
    title: 'title',
    summary: 'summary',
    published: 'published',
    createdAt: 'createdAt',
    lastUpdateAt: 'lastUpdateAt',
    publishedAt: 'publishedAt',
    content: 'content',
    totalComments: 'totalComments',
    totalRootComments: 'totalRootComments',
    likes: 'likes',
    views: 'views',
    categoryId: 'categoryId'
  };

  export type ThreadScalarFieldEnum = (typeof ThreadScalarFieldEnum)[keyof typeof ThreadScalarFieldEnum]


  export const ThreadTagRelScalarFieldEnum: {
    threadId: 'threadId',
    tagId: 'tagId'
  };

  export type ThreadTagRelScalarFieldEnum = (typeof ThreadTagRelScalarFieldEnum)[keyof typeof ThreadTagRelScalarFieldEnum]


  export const ThreadTagScalarFieldEnum: {
    id: 'id',
    title: 'title'
  };

  export type ThreadTagScalarFieldEnum = (typeof ThreadTagScalarFieldEnum)[keyof typeof ThreadTagScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserGroupRelScalarFieldEnum: {
    username: 'username',
    groupId: 'groupId',
    joinedAt: 'joinedAt'
  };

  export type UserGroupRelScalarFieldEnum = (typeof UserGroupRelScalarFieldEnum)[keyof typeof UserGroupRelScalarFieldEnum]


  export const UserLikeCommentScalarFieldEnum: {
    username: 'username',
    commentId: 'commentId',
    disable: 'disable'
  };

  export type UserLikeCommentScalarFieldEnum = (typeof UserLikeCommentScalarFieldEnum)[keyof typeof UserLikeCommentScalarFieldEnum]


  export const UserLikeThreadScalarFieldEnum: {
    username: 'username',
    threadId: 'threadId',
    disable: 'disable'
  };

  export type UserLikeThreadScalarFieldEnum = (typeof UserLikeThreadScalarFieldEnum)[keyof typeof UserLikeThreadScalarFieldEnum]


  export const UserProfileScalarFieldEnum: {
    id: 'id',
    real_name: 'real_name',
    avatar: 'avatar',
    blog: 'blog',
    github: 'github',
    school: 'school',
    major: 'major',
    language: 'language',
    accepted_number: 'accepted_number',
    total_score: 'total_score',
    total_practice_score: 'total_practice_score',
    submission_number: 'submission_number',
    rating: 'rating',
    username: 'username'
  };

  export type UserProfileScalarFieldEnum = (typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum]


  export const UserRatingScalarFieldEnum: {
    username: 'username',
    rating: 'rating'
  };

  export type UserRatingScalarFieldEnum = (typeof UserRatingScalarFieldEnum)[keyof typeof UserRatingScalarFieldEnum]


  export const UserScalarFieldEnum: {
    username: 'username',
    email: 'email',
    create_time: 'create_time',
    admin_type: 'admin_type',
    is_disabled: 'is_disabled',
    auth0_id: 'auth0_id'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    username?: StringFilter | string
    email?: StringFilter | string
    create_time?: DateTimeFilter | Date | string
    admin_type?: Enumadmin_typeFilter | admin_type
    is_disabled?: BoolFilter | boolean
    auth0_id?: StringNullableFilter | string | null
    codingProblems?: AuthorCodingProblemListRelationFilter
    authorMathProblems?: AuthorMathProblemListRelationFilter
    threads?: ThreadListRelationFilter
    comments?: CommentListRelationFilter
    threadLiked?: UserLikeThreadListRelationFilter
    commentLiked?: UserLikeCommentListRelationFilter
    UserProfile?: XOR<UserProfileRelationFilter, UserProfileWhereInput> | null
    mathNotes?: MathNoteListRelationFilter
    mathSolutions?: MathSolutionListRelationFilter
    mathProbSetList?: MathProblemSetListRelationFilter
    myFriendReqs?: FriendRequestListRelationFilter
    otherFriendReqs?: FriendRequestListRelationFilter
    createdGroup?: GroupListRelationFilter
    joinedGroups?: UserGroupRelListRelationFilter
    posts?: GroupPostListRelationFilter
    chatMessages?: ChatMessageListRelationFilter
    chatSessions?: ChatSessionUserListRelationFilter
    groupPostMessages?: GroupPostMessageListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    username?: SortOrder
    email?: SortOrder
    create_time?: SortOrder
    admin_type?: SortOrder
    is_disabled?: SortOrder
    auth0_id?: SortOrder
    codingProblems?: AuthorCodingProblemOrderByRelationAggregateInput
    authorMathProblems?: AuthorMathProblemOrderByRelationAggregateInput
    threads?: ThreadOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    threadLiked?: UserLikeThreadOrderByRelationAggregateInput
    commentLiked?: UserLikeCommentOrderByRelationAggregateInput
    UserProfile?: UserProfileOrderByWithRelationInput
    mathNotes?: MathNoteOrderByRelationAggregateInput
    mathSolutions?: MathSolutionOrderByRelationAggregateInput
    mathProbSetList?: MathProblemSetOrderByRelationAggregateInput
    myFriendReqs?: FriendRequestOrderByRelationAggregateInput
    otherFriendReqs?: FriendRequestOrderByRelationAggregateInput
    createdGroup?: GroupOrderByRelationAggregateInput
    joinedGroups?: UserGroupRelOrderByRelationAggregateInput
    posts?: GroupPostOrderByRelationAggregateInput
    chatMessages?: ChatMessageOrderByRelationAggregateInput
    chatSessions?: ChatSessionUserOrderByRelationAggregateInput
    groupPostMessages?: GroupPostMessageOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    username?: string
    email?: string
    auth0_id?: string
  }

  export type UserOrderByWithAggregationInput = {
    username?: SortOrder
    email?: SortOrder
    create_time?: SortOrder
    admin_type?: SortOrder
    is_disabled?: SortOrder
    auth0_id?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    username?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    create_time?: DateTimeWithAggregatesFilter | Date | string
    admin_type?: Enumadmin_typeWithAggregatesFilter | admin_type
    is_disabled?: BoolWithAggregatesFilter | boolean
    auth0_id?: StringNullableWithAggregatesFilter | string | null
  }

  export type UserRatingWhereInput = {
    AND?: Enumerable<UserRatingWhereInput>
    OR?: Enumerable<UserRatingWhereInput>
    NOT?: Enumerable<UserRatingWhereInput>
    username?: StringFilter | string
    rating?: IntFilter | number
  }

  export type UserRatingOrderByWithRelationInput = {
    username?: SortOrder
    rating?: SortOrder
  }

  export type UserRatingWhereUniqueInput = {
    username?: string
  }

  export type UserRatingOrderByWithAggregationInput = {
    username?: SortOrder
    rating?: SortOrder
    _count?: UserRatingCountOrderByAggregateInput
    _avg?: UserRatingAvgOrderByAggregateInput
    _max?: UserRatingMaxOrderByAggregateInput
    _min?: UserRatingMinOrderByAggregateInput
    _sum?: UserRatingSumOrderByAggregateInput
  }

  export type UserRatingScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserRatingScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserRatingScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserRatingScalarWhereWithAggregatesInput>
    username?: StringWithAggregatesFilter | string
    rating?: IntWithAggregatesFilter | number
  }

  export type FriendShipWhereInput = {
    AND?: Enumerable<FriendShipWhereInput>
    OR?: Enumerable<FriendShipWhereInput>
    NOT?: Enumerable<FriendShipWhereInput>
    id?: StringFilter | string
    username1?: StringFilter | string
    username2?: StringFilter | string
    establishedAt?: DateTimeFilter | Date | string
  }

  export type FriendShipOrderByWithRelationInput = {
    id?: SortOrder
    username1?: SortOrder
    username2?: SortOrder
    establishedAt?: SortOrder
  }

  export type FriendShipWhereUniqueInput = {
    id?: string
  }

  export type FriendShipOrderByWithAggregationInput = {
    id?: SortOrder
    username1?: SortOrder
    username2?: SortOrder
    establishedAt?: SortOrder
    _count?: FriendShipCountOrderByAggregateInput
    _max?: FriendShipMaxOrderByAggregateInput
    _min?: FriendShipMinOrderByAggregateInput
  }

  export type FriendShipScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FriendShipScalarWhereWithAggregatesInput>
    OR?: Enumerable<FriendShipScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FriendShipScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    username1?: StringWithAggregatesFilter | string
    username2?: StringWithAggregatesFilter | string
    establishedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FriendRequestWhereInput = {
    AND?: Enumerable<FriendRequestWhereInput>
    OR?: Enumerable<FriendRequestWhereInput>
    NOT?: Enumerable<FriendRequestWhereInput>
    id?: StringFilter | string
    senderId?: StringFilter | string
    recieverId?: StringFilter | string
    disable?: BoolFilter | boolean
    sender?: XOR<UserRelationFilter, UserWhereInput>
    reciever?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type FriendRequestOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    recieverId?: SortOrder
    disable?: SortOrder
    sender?: UserOrderByWithRelationInput
    reciever?: UserOrderByWithRelationInput
  }

  export type FriendRequestWhereUniqueInput = {
    id?: string
  }

  export type FriendRequestOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    recieverId?: SortOrder
    disable?: SortOrder
    _count?: FriendRequestCountOrderByAggregateInput
    _max?: FriendRequestMaxOrderByAggregateInput
    _min?: FriendRequestMinOrderByAggregateInput
  }

  export type FriendRequestScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FriendRequestScalarWhereWithAggregatesInput>
    OR?: Enumerable<FriendRequestScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FriendRequestScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    senderId?: StringWithAggregatesFilter | string
    recieverId?: StringWithAggregatesFilter | string
    disable?: BoolWithAggregatesFilter | boolean
  }

  export type SharePTPWhereInput = {
    AND?: Enumerable<SharePTPWhereInput>
    OR?: Enumerable<SharePTPWhereInput>
    NOT?: Enumerable<SharePTPWhereInput>
    id?: StringFilter | string
    resourceId?: StringFilter | string
    resourceType?: StringFilter | string
    senderId?: StringFilter | string
    receiverId?: StringFilter | string
    resourceLink?: StringNullableFilter | string | null
    look?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
  }

  export type SharePTPOrderByWithRelationInput = {
    id?: SortOrder
    resourceId?: SortOrder
    resourceType?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    resourceLink?: SortOrder
    look?: SortOrder
    createdAt?: SortOrder
  }

  export type SharePTPWhereUniqueInput = {
    id?: string
  }

  export type SharePTPOrderByWithAggregationInput = {
    id?: SortOrder
    resourceId?: SortOrder
    resourceType?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    resourceLink?: SortOrder
    look?: SortOrder
    createdAt?: SortOrder
    _count?: SharePTPCountOrderByAggregateInput
    _max?: SharePTPMaxOrderByAggregateInput
    _min?: SharePTPMinOrderByAggregateInput
  }

  export type SharePTPScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SharePTPScalarWhereWithAggregatesInput>
    OR?: Enumerable<SharePTPScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SharePTPScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    resourceId?: StringWithAggregatesFilter | string
    resourceType?: StringWithAggregatesFilter | string
    senderId?: StringWithAggregatesFilter | string
    receiverId?: StringWithAggregatesFilter | string
    resourceLink?: StringNullableWithAggregatesFilter | string | null
    look?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type GroupWhereInput = {
    AND?: Enumerable<GroupWhereInput>
    OR?: Enumerable<GroupWhereInput>
    NOT?: Enumerable<GroupWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    creatorId?: StringFilter | string
    generalChatSessionId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
    users?: UserGroupRelListRelationFilter
    posts?: GroupPostListRelationFilter
  }

  export type GroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    creatorId?: SortOrder
    generalChatSessionId?: SortOrder
    createdAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    users?: UserGroupRelOrderByRelationAggregateInput
    posts?: GroupPostOrderByRelationAggregateInput
  }

  export type GroupWhereUniqueInput = {
    id?: string
  }

  export type GroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    creatorId?: SortOrder
    generalChatSessionId?: SortOrder
    createdAt?: SortOrder
    _count?: GroupCountOrderByAggregateInput
    _max?: GroupMaxOrderByAggregateInput
    _min?: GroupMinOrderByAggregateInput
  }

  export type GroupScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GroupScalarWhereWithAggregatesInput>
    OR?: Enumerable<GroupScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GroupScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    creatorId?: StringWithAggregatesFilter | string
    generalChatSessionId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserGroupRelWhereInput = {
    AND?: Enumerable<UserGroupRelWhereInput>
    OR?: Enumerable<UserGroupRelWhereInput>
    NOT?: Enumerable<UserGroupRelWhereInput>
    username?: StringFilter | string
    groupId?: StringFilter | string
    joinedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    group?: XOR<GroupRelationFilter, GroupWhereInput>
  }

  export type UserGroupRelOrderByWithRelationInput = {
    username?: SortOrder
    groupId?: SortOrder
    joinedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    group?: GroupOrderByWithRelationInput
  }

  export type UserGroupRelWhereUniqueInput = {
    username_groupId?: UserGroupRelUsernameGroupIdCompoundUniqueInput
  }

  export type UserGroupRelOrderByWithAggregationInput = {
    username?: SortOrder
    groupId?: SortOrder
    joinedAt?: SortOrder
    _count?: UserGroupRelCountOrderByAggregateInput
    _max?: UserGroupRelMaxOrderByAggregateInput
    _min?: UserGroupRelMinOrderByAggregateInput
  }

  export type UserGroupRelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserGroupRelScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserGroupRelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserGroupRelScalarWhereWithAggregatesInput>
    username?: StringWithAggregatesFilter | string
    groupId?: StringWithAggregatesFilter | string
    joinedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserProfileWhereInput = {
    AND?: Enumerable<UserProfileWhereInput>
    OR?: Enumerable<UserProfileWhereInput>
    NOT?: Enumerable<UserProfileWhereInput>
    id?: StringFilter | string
    real_name?: StringNullableFilter | string | null
    avatar?: StringNullableFilter | string | null
    blog?: StringNullableFilter | string | null
    github?: StringNullableFilter | string | null
    school?: StringNullableFilter | string | null
    major?: StringNullableFilter | string | null
    language?: StringNullableFilter | string | null
    accepted_number?: IntNullableFilter | number | null
    total_score?: IntNullableFilter | number | null
    total_practice_score?: IntNullableFilter | number | null
    submission_number?: IntNullableFilter | number | null
    rating?: IntNullableFilter | number | null
    username?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserProfileOrderByWithRelationInput = {
    id?: SortOrder
    real_name?: SortOrder
    avatar?: SortOrder
    blog?: SortOrder
    github?: SortOrder
    school?: SortOrder
    major?: SortOrder
    language?: SortOrder
    accepted_number?: SortOrder
    total_score?: SortOrder
    total_practice_score?: SortOrder
    submission_number?: SortOrder
    rating?: SortOrder
    username?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserProfileWhereUniqueInput = {
    id?: string
    username?: string
  }

  export type UserProfileOrderByWithAggregationInput = {
    id?: SortOrder
    real_name?: SortOrder
    avatar?: SortOrder
    blog?: SortOrder
    github?: SortOrder
    school?: SortOrder
    major?: SortOrder
    language?: SortOrder
    accepted_number?: SortOrder
    total_score?: SortOrder
    total_practice_score?: SortOrder
    submission_number?: SortOrder
    rating?: SortOrder
    username?: SortOrder
    _count?: UserProfileCountOrderByAggregateInput
    _avg?: UserProfileAvgOrderByAggregateInput
    _max?: UserProfileMaxOrderByAggregateInput
    _min?: UserProfileMinOrderByAggregateInput
    _sum?: UserProfileSumOrderByAggregateInput
  }

  export type UserProfileScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserProfileScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserProfileScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserProfileScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    real_name?: StringNullableWithAggregatesFilter | string | null
    avatar?: StringNullableWithAggregatesFilter | string | null
    blog?: StringNullableWithAggregatesFilter | string | null
    github?: StringNullableWithAggregatesFilter | string | null
    school?: StringNullableWithAggregatesFilter | string | null
    major?: StringNullableWithAggregatesFilter | string | null
    language?: StringNullableWithAggregatesFilter | string | null
    accepted_number?: IntNullableWithAggregatesFilter | number | null
    total_score?: IntNullableWithAggregatesFilter | number | null
    total_practice_score?: IntNullableWithAggregatesFilter | number | null
    submission_number?: IntNullableWithAggregatesFilter | number | null
    rating?: IntNullableWithAggregatesFilter | number | null
    username?: StringWithAggregatesFilter | string
  }

  export type CodingProblemCategoryWhereInput = {
    AND?: Enumerable<CodingProblemCategoryWhereInput>
    OR?: Enumerable<CodingProblemCategoryWhereInput>
    NOT?: Enumerable<CodingProblemCategoryWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    codingProblems?: CodingProblemListRelationFilter
  }

  export type CodingProblemCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    codingProblems?: CodingProblemOrderByRelationAggregateInput
  }

  export type CodingProblemCategoryWhereUniqueInput = {
    id?: number
  }

  export type CodingProblemCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: CodingProblemCategoryCountOrderByAggregateInput
    _avg?: CodingProblemCategoryAvgOrderByAggregateInput
    _max?: CodingProblemCategoryMaxOrderByAggregateInput
    _min?: CodingProblemCategoryMinOrderByAggregateInput
    _sum?: CodingProblemCategorySumOrderByAggregateInput
  }

  export type CodingProblemCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CodingProblemCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<CodingProblemCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CodingProblemCategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type CodingProblemTagWhereInput = {
    AND?: Enumerable<CodingProblemTagWhereInput>
    OR?: Enumerable<CodingProblemTagWhereInput>
    NOT?: Enumerable<CodingProblemTagWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    codingProblems?: TagCodingProblemListRelationFilter
  }

  export type CodingProblemTagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    codingProblems?: TagCodingProblemOrderByRelationAggregateInput
  }

  export type CodingProblemTagWhereUniqueInput = {
    id?: number
  }

  export type CodingProblemTagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: CodingProblemTagCountOrderByAggregateInput
    _avg?: CodingProblemTagAvgOrderByAggregateInput
    _max?: CodingProblemTagMaxOrderByAggregateInput
    _min?: CodingProblemTagMinOrderByAggregateInput
    _sum?: CodingProblemTagSumOrderByAggregateInput
  }

  export type CodingProblemTagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CodingProblemTagScalarWhereWithAggregatesInput>
    OR?: Enumerable<CodingProblemTagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CodingProblemTagScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type CodeforcesTagWhereInput = {
    AND?: Enumerable<CodeforcesTagWhereInput>
    OR?: Enumerable<CodeforcesTagWhereInput>
    NOT?: Enumerable<CodeforcesTagWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    parentId?: StringNullableFilter | string | null
    problems?: CodefocesTagProblemListRelationFilter
  }

  export type CodeforcesTagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    problems?: CodefocesTagProblemOrderByRelationAggregateInput
  }

  export type CodeforcesTagWhereUniqueInput = {
    id?: string
  }

  export type CodeforcesTagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    _count?: CodeforcesTagCountOrderByAggregateInput
    _max?: CodeforcesTagMaxOrderByAggregateInput
    _min?: CodeforcesTagMinOrderByAggregateInput
  }

  export type CodeforcesTagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CodeforcesTagScalarWhereWithAggregatesInput>
    OR?: Enumerable<CodeforcesTagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CodeforcesTagScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    parentId?: StringNullableWithAggregatesFilter | string | null
  }

  export type CodefocesTagProblemWhereInput = {
    AND?: Enumerable<CodefocesTagProblemWhereInput>
    OR?: Enumerable<CodefocesTagProblemWhereInput>
    NOT?: Enumerable<CodefocesTagProblemWhereInput>
    problemId?: StringFilter | string
    codeforcesTagId?: StringFilter | string
    problem?: XOR<CodingProblemRelationFilter, CodingProblemWhereInput>
    codeforcesTag?: XOR<CodeforcesTagRelationFilter, CodeforcesTagWhereInput>
  }

  export type CodefocesTagProblemOrderByWithRelationInput = {
    problemId?: SortOrder
    codeforcesTagId?: SortOrder
    problem?: CodingProblemOrderByWithRelationInput
    codeforcesTag?: CodeforcesTagOrderByWithRelationInput
  }

  export type CodefocesTagProblemWhereUniqueInput = {
    problemId_codeforcesTagId?: CodefocesTagProblemProblemIdCodeforcesTagIdCompoundUniqueInput
  }

  export type CodefocesTagProblemOrderByWithAggregationInput = {
    problemId?: SortOrder
    codeforcesTagId?: SortOrder
    _count?: CodefocesTagProblemCountOrderByAggregateInput
    _max?: CodefocesTagProblemMaxOrderByAggregateInput
    _min?: CodefocesTagProblemMinOrderByAggregateInput
  }

  export type CodefocesTagProblemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CodefocesTagProblemScalarWhereWithAggregatesInput>
    OR?: Enumerable<CodefocesTagProblemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CodefocesTagProblemScalarWhereWithAggregatesInput>
    problemId?: StringWithAggregatesFilter | string
    codeforcesTagId?: StringWithAggregatesFilter | string
  }

  export type CodingProblemWhereInput = {
    AND?: Enumerable<CodingProblemWhereInput>
    OR?: Enumerable<CodingProblemWhereInput>
    NOT?: Enumerable<CodingProblemWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    title?: StringFilter | string
    categoryId?: IntFilter | number
    link?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    timeLimit?: IntFilter | number
    memoryLimit?: IntFilter | number
    difficulty?: IntFilter | number
    practicePoint?: IntFilter | number
    totalPoint?: IntFilter | number
    submissionNumber?: IntFilter | number
    acceptedNumber?: IntFilter | number
    contestId?: StringNullableFilter | string | null
    visibleFrom?: DateTimeNullableFilter | Date | string | null
    category?: XOR<CodingProblemCategoryRelationFilter, CodingProblemCategoryWhereInput>
    authors?: AuthorCodingProblemListRelationFilter
    tags?: TagCodingProblemListRelationFilter
    codeforcesTag?: CodefocesTagProblemListRelationFilter
    testCases?: TestcaseListRelationFilter
    contest?: XOR<ContestRelationFilter, ContestWhereInput> | null
  }

  export type CodingProblemOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    categoryId?: SortOrder
    link?: SortOrder
    description?: SortOrder
    timeLimit?: SortOrder
    memoryLimit?: SortOrder
    difficulty?: SortOrder
    practicePoint?: SortOrder
    totalPoint?: SortOrder
    submissionNumber?: SortOrder
    acceptedNumber?: SortOrder
    contestId?: SortOrder
    visibleFrom?: SortOrder
    category?: CodingProblemCategoryOrderByWithRelationInput
    authors?: AuthorCodingProblemOrderByRelationAggregateInput
    tags?: TagCodingProblemOrderByRelationAggregateInput
    codeforcesTag?: CodefocesTagProblemOrderByRelationAggregateInput
    testCases?: TestcaseOrderByRelationAggregateInput
    contest?: ContestOrderByWithRelationInput
  }

  export type CodingProblemWhereUniqueInput = {
    id?: string
    code?: string
  }

  export type CodingProblemOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    categoryId?: SortOrder
    link?: SortOrder
    description?: SortOrder
    timeLimit?: SortOrder
    memoryLimit?: SortOrder
    difficulty?: SortOrder
    practicePoint?: SortOrder
    totalPoint?: SortOrder
    submissionNumber?: SortOrder
    acceptedNumber?: SortOrder
    contestId?: SortOrder
    visibleFrom?: SortOrder
    _count?: CodingProblemCountOrderByAggregateInput
    _avg?: CodingProblemAvgOrderByAggregateInput
    _max?: CodingProblemMaxOrderByAggregateInput
    _min?: CodingProblemMinOrderByAggregateInput
    _sum?: CodingProblemSumOrderByAggregateInput
  }

  export type CodingProblemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CodingProblemScalarWhereWithAggregatesInput>
    OR?: Enumerable<CodingProblemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CodingProblemScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    categoryId?: IntWithAggregatesFilter | number
    link?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    timeLimit?: IntWithAggregatesFilter | number
    memoryLimit?: IntWithAggregatesFilter | number
    difficulty?: IntWithAggregatesFilter | number
    practicePoint?: IntWithAggregatesFilter | number
    totalPoint?: IntWithAggregatesFilter | number
    submissionNumber?: IntWithAggregatesFilter | number
    acceptedNumber?: IntWithAggregatesFilter | number
    contestId?: StringNullableWithAggregatesFilter | string | null
    visibleFrom?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type AuthorCodingProblemWhereInput = {
    AND?: Enumerable<AuthorCodingProblemWhereInput>
    OR?: Enumerable<AuthorCodingProblemWhereInput>
    NOT?: Enumerable<AuthorCodingProblemWhereInput>
    username?: StringFilter | string
    codingProblemId?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    codingProblem?: XOR<CodingProblemRelationFilter, CodingProblemWhereInput>
  }

  export type AuthorCodingProblemOrderByWithRelationInput = {
    username?: SortOrder
    codingProblemId?: SortOrder
    user?: UserOrderByWithRelationInput
    codingProblem?: CodingProblemOrderByWithRelationInput
  }

  export type AuthorCodingProblemWhereUniqueInput = {
    username_codingProblemId?: AuthorCodingProblemUsernameCodingProblemIdCompoundUniqueInput
  }

  export type AuthorCodingProblemOrderByWithAggregationInput = {
    username?: SortOrder
    codingProblemId?: SortOrder
    _count?: AuthorCodingProblemCountOrderByAggregateInput
    _max?: AuthorCodingProblemMaxOrderByAggregateInput
    _min?: AuthorCodingProblemMinOrderByAggregateInput
  }

  export type AuthorCodingProblemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AuthorCodingProblemScalarWhereWithAggregatesInput>
    OR?: Enumerable<AuthorCodingProblemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AuthorCodingProblemScalarWhereWithAggregatesInput>
    username?: StringWithAggregatesFilter | string
    codingProblemId?: StringWithAggregatesFilter | string
  }

  export type TagCodingProblemWhereInput = {
    AND?: Enumerable<TagCodingProblemWhereInput>
    OR?: Enumerable<TagCodingProblemWhereInput>
    NOT?: Enumerable<TagCodingProblemWhereInput>
    tagId?: IntFilter | number
    codingProblemId?: StringFilter | string
    tag?: XOR<CodingProblemTagRelationFilter, CodingProblemTagWhereInput>
    codingProblem?: XOR<CodingProblemRelationFilter, CodingProblemWhereInput>
  }

  export type TagCodingProblemOrderByWithRelationInput = {
    tagId?: SortOrder
    codingProblemId?: SortOrder
    tag?: CodingProblemTagOrderByWithRelationInput
    codingProblem?: CodingProblemOrderByWithRelationInput
  }

  export type TagCodingProblemWhereUniqueInput = {
    tagId_codingProblemId?: TagCodingProblemTagIdCodingProblemIdCompoundUniqueInput
  }

  export type TagCodingProblemOrderByWithAggregationInput = {
    tagId?: SortOrder
    codingProblemId?: SortOrder
    _count?: TagCodingProblemCountOrderByAggregateInput
    _avg?: TagCodingProblemAvgOrderByAggregateInput
    _max?: TagCodingProblemMaxOrderByAggregateInput
    _min?: TagCodingProblemMinOrderByAggregateInput
    _sum?: TagCodingProblemSumOrderByAggregateInput
  }

  export type TagCodingProblemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TagCodingProblemScalarWhereWithAggregatesInput>
    OR?: Enumerable<TagCodingProblemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TagCodingProblemScalarWhereWithAggregatesInput>
    tagId?: IntWithAggregatesFilter | number
    codingProblemId?: StringWithAggregatesFilter | string
  }

  export type ThreadWhereInput = {
    AND?: Enumerable<ThreadWhereInput>
    OR?: Enumerable<ThreadWhereInput>
    NOT?: Enumerable<ThreadWhereInput>
    id?: StringFilter | string
    authorId?: StringFilter | string
    parentId?: StringNullableFilter | string | null
    title?: StringFilter | string
    summary?: StringFilter | string
    published?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    lastUpdateAt?: DateTimeFilter | Date | string
    publishedAt?: DateTimeFilter | Date | string
    content?: StringFilter | string
    totalComments?: IntFilter | number
    totalRootComments?: IntFilter | number
    likes?: IntFilter | number
    views?: IntFilter | number
    categoryId?: IntNullableFilter | number | null
    author?: XOR<UserRelationFilter, UserWhereInput>
    comments?: CommentListRelationFilter
    category?: XOR<ThreadCategoryRelationFilter, ThreadCategoryWhereInput> | null
    tags?: ThreadTagRelListRelationFilter
    userLikes?: UserLikeThreadListRelationFilter
  }

  export type ThreadOrderByWithRelationInput = {
    id?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    lastUpdateAt?: SortOrder
    publishedAt?: SortOrder
    content?: SortOrder
    totalComments?: SortOrder
    totalRootComments?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    categoryId?: SortOrder
    author?: UserOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
    category?: ThreadCategoryOrderByWithRelationInput
    tags?: ThreadTagRelOrderByRelationAggregateInput
    userLikes?: UserLikeThreadOrderByRelationAggregateInput
  }

  export type ThreadWhereUniqueInput = {
    id?: string
  }

  export type ThreadOrderByWithAggregationInput = {
    id?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    lastUpdateAt?: SortOrder
    publishedAt?: SortOrder
    content?: SortOrder
    totalComments?: SortOrder
    totalRootComments?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    categoryId?: SortOrder
    _count?: ThreadCountOrderByAggregateInput
    _avg?: ThreadAvgOrderByAggregateInput
    _max?: ThreadMaxOrderByAggregateInput
    _min?: ThreadMinOrderByAggregateInput
    _sum?: ThreadSumOrderByAggregateInput
  }

  export type ThreadScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ThreadScalarWhereWithAggregatesInput>
    OR?: Enumerable<ThreadScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ThreadScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    authorId?: StringWithAggregatesFilter | string
    parentId?: StringNullableWithAggregatesFilter | string | null
    title?: StringWithAggregatesFilter | string
    summary?: StringWithAggregatesFilter | string
    published?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    lastUpdateAt?: DateTimeWithAggregatesFilter | Date | string
    publishedAt?: DateTimeWithAggregatesFilter | Date | string
    content?: StringWithAggregatesFilter | string
    totalComments?: IntWithAggregatesFilter | number
    totalRootComments?: IntWithAggregatesFilter | number
    likes?: IntWithAggregatesFilter | number
    views?: IntWithAggregatesFilter | number
    categoryId?: IntNullableWithAggregatesFilter | number | null
  }

  export type ThreadCategoryWhereInput = {
    AND?: Enumerable<ThreadCategoryWhereInput>
    OR?: Enumerable<ThreadCategoryWhereInput>
    NOT?: Enumerable<ThreadCategoryWhereInput>
    id?: IntFilter | number
    parentId?: StringNullableFilter | string | null
    title?: StringFilter | string
    threads?: ThreadListRelationFilter
  }

  export type ThreadCategoryOrderByWithRelationInput = {
    id?: SortOrder
    parentId?: SortOrder
    title?: SortOrder
    threads?: ThreadOrderByRelationAggregateInput
  }

  export type ThreadCategoryWhereUniqueInput = {
    id?: number
  }

  export type ThreadCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    parentId?: SortOrder
    title?: SortOrder
    _count?: ThreadCategoryCountOrderByAggregateInput
    _avg?: ThreadCategoryAvgOrderByAggregateInput
    _max?: ThreadCategoryMaxOrderByAggregateInput
    _min?: ThreadCategoryMinOrderByAggregateInput
    _sum?: ThreadCategorySumOrderByAggregateInput
  }

  export type ThreadCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ThreadCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<ThreadCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ThreadCategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    parentId?: StringNullableWithAggregatesFilter | string | null
    title?: StringWithAggregatesFilter | string
  }

  export type ThreadTagWhereInput = {
    AND?: Enumerable<ThreadTagWhereInput>
    OR?: Enumerable<ThreadTagWhereInput>
    NOT?: Enumerable<ThreadTagWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    threads?: ThreadTagRelListRelationFilter
  }

  export type ThreadTagOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    threads?: ThreadTagRelOrderByRelationAggregateInput
  }

  export type ThreadTagWhereUniqueInput = {
    id?: string
  }

  export type ThreadTagOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    _count?: ThreadTagCountOrderByAggregateInput
    _max?: ThreadTagMaxOrderByAggregateInput
    _min?: ThreadTagMinOrderByAggregateInput
  }

  export type ThreadTagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ThreadTagScalarWhereWithAggregatesInput>
    OR?: Enumerable<ThreadTagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ThreadTagScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
  }

  export type ThreadTagRelWhereInput = {
    AND?: Enumerable<ThreadTagRelWhereInput>
    OR?: Enumerable<ThreadTagRelWhereInput>
    NOT?: Enumerable<ThreadTagRelWhereInput>
    threadId?: StringFilter | string
    tagId?: StringFilter | string
    thread?: XOR<ThreadRelationFilter, ThreadWhereInput>
    tag?: XOR<ThreadTagRelationFilter, ThreadTagWhereInput>
  }

  export type ThreadTagRelOrderByWithRelationInput = {
    threadId?: SortOrder
    tagId?: SortOrder
    thread?: ThreadOrderByWithRelationInput
    tag?: ThreadTagOrderByWithRelationInput
  }

  export type ThreadTagRelWhereUniqueInput = {
    threadId_tagId?: ThreadTagRelThreadIdTagIdCompoundUniqueInput
  }

  export type ThreadTagRelOrderByWithAggregationInput = {
    threadId?: SortOrder
    tagId?: SortOrder
    _count?: ThreadTagRelCountOrderByAggregateInput
    _max?: ThreadTagRelMaxOrderByAggregateInput
    _min?: ThreadTagRelMinOrderByAggregateInput
  }

  export type ThreadTagRelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ThreadTagRelScalarWhereWithAggregatesInput>
    OR?: Enumerable<ThreadTagRelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ThreadTagRelScalarWhereWithAggregatesInput>
    threadId?: StringWithAggregatesFilter | string
    tagId?: StringWithAggregatesFilter | string
  }

  export type UserLikeThreadWhereInput = {
    AND?: Enumerable<UserLikeThreadWhereInput>
    OR?: Enumerable<UserLikeThreadWhereInput>
    NOT?: Enumerable<UserLikeThreadWhereInput>
    username?: StringFilter | string
    threadId?: StringFilter | string
    disable?: BoolFilter | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
    thread?: XOR<ThreadRelationFilter, ThreadWhereInput>
  }

  export type UserLikeThreadOrderByWithRelationInput = {
    username?: SortOrder
    threadId?: SortOrder
    disable?: SortOrder
    user?: UserOrderByWithRelationInput
    thread?: ThreadOrderByWithRelationInput
  }

  export type UserLikeThreadWhereUniqueInput = {
    username_threadId?: UserLikeThreadUsernameThreadIdCompoundUniqueInput
  }

  export type UserLikeThreadOrderByWithAggregationInput = {
    username?: SortOrder
    threadId?: SortOrder
    disable?: SortOrder
    _count?: UserLikeThreadCountOrderByAggregateInput
    _max?: UserLikeThreadMaxOrderByAggregateInput
    _min?: UserLikeThreadMinOrderByAggregateInput
  }

  export type UserLikeThreadScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserLikeThreadScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserLikeThreadScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserLikeThreadScalarWhereWithAggregatesInput>
    username?: StringWithAggregatesFilter | string
    threadId?: StringWithAggregatesFilter | string
    disable?: BoolWithAggregatesFilter | boolean
  }

  export type UserLikeCommentWhereInput = {
    AND?: Enumerable<UserLikeCommentWhereInput>
    OR?: Enumerable<UserLikeCommentWhereInput>
    NOT?: Enumerable<UserLikeCommentWhereInput>
    username?: StringFilter | string
    commentId?: StringFilter | string
    disable?: BoolFilter | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
    comment?: XOR<CommentRelationFilter, CommentWhereInput>
  }

  export type UserLikeCommentOrderByWithRelationInput = {
    username?: SortOrder
    commentId?: SortOrder
    disable?: SortOrder
    user?: UserOrderByWithRelationInput
    comment?: CommentOrderByWithRelationInput
  }

  export type UserLikeCommentWhereUniqueInput = {
    username_commentId?: UserLikeCommentUsernameCommentIdCompoundUniqueInput
  }

  export type UserLikeCommentOrderByWithAggregationInput = {
    username?: SortOrder
    commentId?: SortOrder
    disable?: SortOrder
    _count?: UserLikeCommentCountOrderByAggregateInput
    _max?: UserLikeCommentMaxOrderByAggregateInput
    _min?: UserLikeCommentMinOrderByAggregateInput
  }

  export type UserLikeCommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserLikeCommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserLikeCommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserLikeCommentScalarWhereWithAggregatesInput>
    username?: StringWithAggregatesFilter | string
    commentId?: StringWithAggregatesFilter | string
    disable?: BoolWithAggregatesFilter | boolean
  }

  export type CommentWhereInput = {
    AND?: Enumerable<CommentWhereInput>
    OR?: Enumerable<CommentWhereInput>
    NOT?: Enumerable<CommentWhereInput>
    id?: StringFilter | string
    threadId?: StringFilter | string
    parentId?: StringNullableFilter | string | null
    rootId?: StringFilter | string
    totalChildren?: IntFilter | number
    depth?: IntFilter | number
    likes?: IntFilter | number
    parentUsername?: StringNullableFilter | string | null
    creatorId?: StringFilter | string
    published?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    content?: StringFilter | string
    thread?: XOR<ThreadRelationFilter, ThreadWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
    usersLiked?: UserLikeCommentListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    threadId?: SortOrder
    parentId?: SortOrder
    rootId?: SortOrder
    totalChildren?: SortOrder
    depth?: SortOrder
    likes?: SortOrder
    parentUsername?: SortOrder
    creatorId?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    content?: SortOrder
    thread?: ThreadOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    usersLiked?: UserLikeCommentOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = {
    id?: string
  }

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    threadId?: SortOrder
    parentId?: SortOrder
    rootId?: SortOrder
    totalChildren?: SortOrder
    depth?: SortOrder
    likes?: SortOrder
    parentUsername?: SortOrder
    creatorId?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    content?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    threadId?: StringWithAggregatesFilter | string
    parentId?: StringNullableWithAggregatesFilter | string | null
    rootId?: StringWithAggregatesFilter | string
    totalChildren?: IntWithAggregatesFilter | number
    depth?: IntWithAggregatesFilter | number
    likes?: IntWithAggregatesFilter | number
    parentUsername?: StringNullableWithAggregatesFilter | string | null
    creatorId?: StringWithAggregatesFilter | string
    published?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    content?: StringWithAggregatesFilter | string
  }

  export type MathProblemCategoryWhereInput = {
    AND?: Enumerable<MathProblemCategoryWhereInput>
    OR?: Enumerable<MathProblemCategoryWhereInput>
    NOT?: Enumerable<MathProblemCategoryWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    mathProblems?: MathProblemListRelationFilter
  }

  export type MathProblemCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    mathProblems?: MathProblemOrderByRelationAggregateInput
  }

  export type MathProblemCategoryWhereUniqueInput = {
    id?: number
  }

  export type MathProblemCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: MathProblemCategoryCountOrderByAggregateInput
    _avg?: MathProblemCategoryAvgOrderByAggregateInput
    _max?: MathProblemCategoryMaxOrderByAggregateInput
    _min?: MathProblemCategoryMinOrderByAggregateInput
    _sum?: MathProblemCategorySumOrderByAggregateInput
  }

  export type MathProblemCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MathProblemCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<MathProblemCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MathProblemCategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type MathProblemTagWhereInput = {
    AND?: Enumerable<MathProblemTagWhereInput>
    OR?: Enumerable<MathProblemTagWhereInput>
    NOT?: Enumerable<MathProblemTagWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    parentId?: IntNullableFilter | number | null
    nextSibling?: IntNullableFilter | number | null
    prevSibling?: IntNullableFilter | number | null
    mathProblems?: TagMathProblemListRelationFilter
  }

  export type MathProblemTagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    nextSibling?: SortOrder
    prevSibling?: SortOrder
    mathProblems?: TagMathProblemOrderByRelationAggregateInput
  }

  export type MathProblemTagWhereUniqueInput = {
    id?: number
  }

  export type MathProblemTagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    nextSibling?: SortOrder
    prevSibling?: SortOrder
    _count?: MathProblemTagCountOrderByAggregateInput
    _avg?: MathProblemTagAvgOrderByAggregateInput
    _max?: MathProblemTagMaxOrderByAggregateInput
    _min?: MathProblemTagMinOrderByAggregateInput
    _sum?: MathProblemTagSumOrderByAggregateInput
  }

  export type MathProblemTagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MathProblemTagScalarWhereWithAggregatesInput>
    OR?: Enumerable<MathProblemTagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MathProblemTagScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    parentId?: IntNullableWithAggregatesFilter | number | null
    nextSibling?: IntNullableWithAggregatesFilter | number | null
    prevSibling?: IntNullableWithAggregatesFilter | number | null
  }

  export type MathProblemWhereInput = {
    AND?: Enumerable<MathProblemWhereInput>
    OR?: Enumerable<MathProblemWhereInput>
    NOT?: Enumerable<MathProblemWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    categoryId?: IntFilter | number
    link?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    hint?: StringNullableFilter | string | null
    difficulty?: IntFilter | number
    practicePoint?: IntNullableFilter | number | null
    totalPoint?: IntNullableFilter | number | null
    prevProblems?: StringNullableFilter | string | null
    nextProblems?: StringNullableFilter | string | null
    numSolution?: IntFilter | number
    numCheckedSolution?: IntFilter | number
    category?: XOR<MathProblemCategoryRelationFilter, MathProblemCategoryWhereInput>
    authors?: AuthorMathProblemListRelationFilter
    tags?: TagMathProblemListRelationFilter
    mathNotes?: MathNoteListRelationFilter
    mathSolutions?: MathSolutionListRelationFilter
    problemSet?: MathSetProbRelListRelationFilter
  }

  export type MathProblemOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    categoryId?: SortOrder
    link?: SortOrder
    description?: SortOrder
    hint?: SortOrder
    difficulty?: SortOrder
    practicePoint?: SortOrder
    totalPoint?: SortOrder
    prevProblems?: SortOrder
    nextProblems?: SortOrder
    numSolution?: SortOrder
    numCheckedSolution?: SortOrder
    category?: MathProblemCategoryOrderByWithRelationInput
    authors?: AuthorMathProblemOrderByRelationAggregateInput
    tags?: TagMathProblemOrderByRelationAggregateInput
    mathNotes?: MathNoteOrderByRelationAggregateInput
    mathSolutions?: MathSolutionOrderByRelationAggregateInput
    problemSet?: MathSetProbRelOrderByRelationAggregateInput
  }

  export type MathProblemWhereUniqueInput = {
    id?: string
  }

  export type MathProblemOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    categoryId?: SortOrder
    link?: SortOrder
    description?: SortOrder
    hint?: SortOrder
    difficulty?: SortOrder
    practicePoint?: SortOrder
    totalPoint?: SortOrder
    prevProblems?: SortOrder
    nextProblems?: SortOrder
    numSolution?: SortOrder
    numCheckedSolution?: SortOrder
    _count?: MathProblemCountOrderByAggregateInput
    _avg?: MathProblemAvgOrderByAggregateInput
    _max?: MathProblemMaxOrderByAggregateInput
    _min?: MathProblemMinOrderByAggregateInput
    _sum?: MathProblemSumOrderByAggregateInput
  }

  export type MathProblemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MathProblemScalarWhereWithAggregatesInput>
    OR?: Enumerable<MathProblemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MathProblemScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    categoryId?: IntWithAggregatesFilter | number
    link?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    hint?: StringNullableWithAggregatesFilter | string | null
    difficulty?: IntWithAggregatesFilter | number
    practicePoint?: IntNullableWithAggregatesFilter | number | null
    totalPoint?: IntNullableWithAggregatesFilter | number | null
    prevProblems?: StringNullableWithAggregatesFilter | string | null
    nextProblems?: StringNullableWithAggregatesFilter | string | null
    numSolution?: IntWithAggregatesFilter | number
    numCheckedSolution?: IntWithAggregatesFilter | number
  }

  export type MathProblemSetWhereInput = {
    AND?: Enumerable<MathProblemSetWhereInput>
    OR?: Enumerable<MathProblemSetWhereInput>
    NOT?: Enumerable<MathProblemSetWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    creatorId?: StringFilter | string
    numberProb?: IntFilter | number
    creator?: XOR<UserRelationFilter, UserWhereInput>
    problems?: MathSetProbRelListRelationFilter
  }

  export type MathProblemSetOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    creatorId?: SortOrder
    numberProb?: SortOrder
    creator?: UserOrderByWithRelationInput
    problems?: MathSetProbRelOrderByRelationAggregateInput
  }

  export type MathProblemSetWhereUniqueInput = {
    id?: string
  }

  export type MathProblemSetOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    creatorId?: SortOrder
    numberProb?: SortOrder
    _count?: MathProblemSetCountOrderByAggregateInput
    _avg?: MathProblemSetAvgOrderByAggregateInput
    _max?: MathProblemSetMaxOrderByAggregateInput
    _min?: MathProblemSetMinOrderByAggregateInput
    _sum?: MathProblemSetSumOrderByAggregateInput
  }

  export type MathProblemSetScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MathProblemSetScalarWhereWithAggregatesInput>
    OR?: Enumerable<MathProblemSetScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MathProblemSetScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    creatorId?: StringWithAggregatesFilter | string
    numberProb?: IntWithAggregatesFilter | number
  }

  export type MathSetProbRelWhereInput = {
    AND?: Enumerable<MathSetProbRelWhereInput>
    OR?: Enumerable<MathSetProbRelWhereInput>
    NOT?: Enumerable<MathSetProbRelWhereInput>
    problemId?: StringFilter | string
    setId?: StringFilter | string
    order?: StringFilter | string
    problem?: XOR<MathProblemRelationFilter, MathProblemWhereInput>
    mathProbSet?: XOR<MathProblemSetRelationFilter, MathProblemSetWhereInput>
  }

  export type MathSetProbRelOrderByWithRelationInput = {
    problemId?: SortOrder
    setId?: SortOrder
    order?: SortOrder
    problem?: MathProblemOrderByWithRelationInput
    mathProbSet?: MathProblemSetOrderByWithRelationInput
  }

  export type MathSetProbRelWhereUniqueInput = {
    setId_problemId?: MathSetProbRelSetIdProblemIdCompoundUniqueInput
  }

  export type MathSetProbRelOrderByWithAggregationInput = {
    problemId?: SortOrder
    setId?: SortOrder
    order?: SortOrder
    _count?: MathSetProbRelCountOrderByAggregateInput
    _max?: MathSetProbRelMaxOrderByAggregateInput
    _min?: MathSetProbRelMinOrderByAggregateInput
  }

  export type MathSetProbRelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MathSetProbRelScalarWhereWithAggregatesInput>
    OR?: Enumerable<MathSetProbRelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MathSetProbRelScalarWhereWithAggregatesInput>
    problemId?: StringWithAggregatesFilter | string
    setId?: StringWithAggregatesFilter | string
    order?: StringWithAggregatesFilter | string
  }

  export type AuthorMathProblemWhereInput = {
    AND?: Enumerable<AuthorMathProblemWhereInput>
    OR?: Enumerable<AuthorMathProblemWhereInput>
    NOT?: Enumerable<AuthorMathProblemWhereInput>
    username?: StringFilter | string
    mathProblemId?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    mathProblem?: XOR<MathProblemRelationFilter, MathProblemWhereInput>
  }

  export type AuthorMathProblemOrderByWithRelationInput = {
    username?: SortOrder
    mathProblemId?: SortOrder
    user?: UserOrderByWithRelationInput
    mathProblem?: MathProblemOrderByWithRelationInput
  }

  export type AuthorMathProblemWhereUniqueInput = {
    username_mathProblemId?: AuthorMathProblemUsernameMathProblemIdCompoundUniqueInput
  }

  export type AuthorMathProblemOrderByWithAggregationInput = {
    username?: SortOrder
    mathProblemId?: SortOrder
    _count?: AuthorMathProblemCountOrderByAggregateInput
    _max?: AuthorMathProblemMaxOrderByAggregateInput
    _min?: AuthorMathProblemMinOrderByAggregateInput
  }

  export type AuthorMathProblemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AuthorMathProblemScalarWhereWithAggregatesInput>
    OR?: Enumerable<AuthorMathProblemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AuthorMathProblemScalarWhereWithAggregatesInput>
    username?: StringWithAggregatesFilter | string
    mathProblemId?: StringWithAggregatesFilter | string
  }

  export type TagMathProblemWhereInput = {
    AND?: Enumerable<TagMathProblemWhereInput>
    OR?: Enumerable<TagMathProblemWhereInput>
    NOT?: Enumerable<TagMathProblemWhereInput>
    tagId?: IntFilter | number
    mathProblemId?: StringFilter | string
    tag?: XOR<MathProblemTagRelationFilter, MathProblemTagWhereInput>
    mathProblem?: XOR<MathProblemRelationFilter, MathProblemWhereInput>
  }

  export type TagMathProblemOrderByWithRelationInput = {
    tagId?: SortOrder
    mathProblemId?: SortOrder
    tag?: MathProblemTagOrderByWithRelationInput
    mathProblem?: MathProblemOrderByWithRelationInput
  }

  export type TagMathProblemWhereUniqueInput = {
    tagId_mathProblemId?: TagMathProblemTagIdMathProblemIdCompoundUniqueInput
  }

  export type TagMathProblemOrderByWithAggregationInput = {
    tagId?: SortOrder
    mathProblemId?: SortOrder
    _count?: TagMathProblemCountOrderByAggregateInput
    _avg?: TagMathProblemAvgOrderByAggregateInput
    _max?: TagMathProblemMaxOrderByAggregateInput
    _min?: TagMathProblemMinOrderByAggregateInput
    _sum?: TagMathProblemSumOrderByAggregateInput
  }

  export type TagMathProblemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TagMathProblemScalarWhereWithAggregatesInput>
    OR?: Enumerable<TagMathProblemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TagMathProblemScalarWhereWithAggregatesInput>
    tagId?: IntWithAggregatesFilter | number
    mathProblemId?: StringWithAggregatesFilter | string
  }

  export type GroupPostWhereInput = {
    AND?: Enumerable<GroupPostWhereInput>
    OR?: Enumerable<GroupPostWhereInput>
    NOT?: Enumerable<GroupPostWhereInput>
    id?: StringFilter | string
    content?: StringFilter | string
    authorId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    groupId?: StringFilter | string
    title?: StringFilter | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    group?: XOR<GroupRelationFilter, GroupWhereInput>
    messages?: GroupPostMessageListRelationFilter
  }

  export type GroupPostOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    groupId?: SortOrder
    title?: SortOrder
    author?: UserOrderByWithRelationInput
    group?: GroupOrderByWithRelationInput
    messages?: GroupPostMessageOrderByRelationAggregateInput
  }

  export type GroupPostWhereUniqueInput = {
    id?: string
  }

  export type GroupPostOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    groupId?: SortOrder
    title?: SortOrder
    _count?: GroupPostCountOrderByAggregateInput
    _max?: GroupPostMaxOrderByAggregateInput
    _min?: GroupPostMinOrderByAggregateInput
  }

  export type GroupPostScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GroupPostScalarWhereWithAggregatesInput>
    OR?: Enumerable<GroupPostScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GroupPostScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    authorId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    groupId?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
  }

  export type ChatMessageWhereInput = {
    AND?: Enumerable<ChatMessageWhereInput>
    OR?: Enumerable<ChatMessageWhereInput>
    NOT?: Enumerable<ChatMessageWhereInput>
    id?: StringFilter | string
    content?: StringFilter | string
    authorId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    referenceMessage?: JsonNullableFilter
    sessionId?: StringFilter | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    chatSession?: XOR<ChatSessionRelationFilter, ChatSessionWhereInput>
  }

  export type ChatMessageOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    referenceMessage?: SortOrder
    sessionId?: SortOrder
    author?: UserOrderByWithRelationInput
    chatSession?: ChatSessionOrderByWithRelationInput
  }

  export type ChatMessageWhereUniqueInput = {
    id?: string
  }

  export type ChatMessageOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    referenceMessage?: SortOrder
    sessionId?: SortOrder
    _count?: ChatMessageCountOrderByAggregateInput
    _max?: ChatMessageMaxOrderByAggregateInput
    _min?: ChatMessageMinOrderByAggregateInput
  }

  export type ChatMessageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ChatMessageScalarWhereWithAggregatesInput>
    OR?: Enumerable<ChatMessageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ChatMessageScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    authorId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    referenceMessage?: JsonNullableWithAggregatesFilter
    sessionId?: StringWithAggregatesFilter | string
  }

  export type GroupPostMessageWhereInput = {
    AND?: Enumerable<GroupPostMessageWhereInput>
    OR?: Enumerable<GroupPostMessageWhereInput>
    NOT?: Enumerable<GroupPostMessageWhereInput>
    id?: StringFilter | string
    content?: StringFilter | string
    authorId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    referenceMessage?: JsonNullableFilter
    postId?: StringFilter | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    post?: XOR<GroupPostRelationFilter, GroupPostWhereInput>
  }

  export type GroupPostMessageOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    referenceMessage?: SortOrder
    postId?: SortOrder
    author?: UserOrderByWithRelationInput
    post?: GroupPostOrderByWithRelationInput
  }

  export type GroupPostMessageWhereUniqueInput = {
    id?: string
  }

  export type GroupPostMessageOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    referenceMessage?: SortOrder
    postId?: SortOrder
    _count?: GroupPostMessageCountOrderByAggregateInput
    _max?: GroupPostMessageMaxOrderByAggregateInput
    _min?: GroupPostMessageMinOrderByAggregateInput
  }

  export type GroupPostMessageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GroupPostMessageScalarWhereWithAggregatesInput>
    OR?: Enumerable<GroupPostMessageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GroupPostMessageScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    authorId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    referenceMessage?: JsonNullableWithAggregatesFilter
    postId?: StringWithAggregatesFilter | string
  }

  export type ChatSessionWhereInput = {
    AND?: Enumerable<ChatSessionWhereInput>
    OR?: Enumerable<ChatSessionWhereInput>
    NOT?: Enumerable<ChatSessionWhereInput>
    id?: StringFilter | string
    lastMessage?: JsonFilter
    lastUpdate?: DateTimeFilter | Date | string
    groupId?: StringNullableFilter | string | null
    type?: EnumChatSessionTypeFilter | ChatSessionType
    usersInfo?: JsonNullableFilter
    chatMessages?: ChatMessageListRelationFilter
    users?: ChatSessionUserListRelationFilter
  }

  export type ChatSessionOrderByWithRelationInput = {
    id?: SortOrder
    lastMessage?: SortOrder
    lastUpdate?: SortOrder
    groupId?: SortOrder
    type?: SortOrder
    usersInfo?: SortOrder
    chatMessages?: ChatMessageOrderByRelationAggregateInput
    users?: ChatSessionUserOrderByRelationAggregateInput
  }

  export type ChatSessionWhereUniqueInput = {
    id?: string
  }

  export type ChatSessionOrderByWithAggregationInput = {
    id?: SortOrder
    lastMessage?: SortOrder
    lastUpdate?: SortOrder
    groupId?: SortOrder
    type?: SortOrder
    usersInfo?: SortOrder
    _count?: ChatSessionCountOrderByAggregateInput
    _max?: ChatSessionMaxOrderByAggregateInput
    _min?: ChatSessionMinOrderByAggregateInput
  }

  export type ChatSessionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ChatSessionScalarWhereWithAggregatesInput>
    OR?: Enumerable<ChatSessionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ChatSessionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    lastMessage?: JsonWithAggregatesFilter
    lastUpdate?: DateTimeWithAggregatesFilter | Date | string
    groupId?: StringNullableWithAggregatesFilter | string | null
    type?: EnumChatSessionTypeWithAggregatesFilter | ChatSessionType
    usersInfo?: JsonNullableWithAggregatesFilter
  }

  export type ChatSessionUserWhereInput = {
    AND?: Enumerable<ChatSessionUserWhereInput>
    OR?: Enumerable<ChatSessionUserWhereInput>
    NOT?: Enumerable<ChatSessionUserWhereInput>
    sessionId?: StringFilter | string
    username?: StringFilter | string
    unseenCnt?: IntFilter | number
    joinedAt?: DateTimeFilter | Date | string
    chatSession?: XOR<ChatSessionRelationFilter, ChatSessionWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ChatSessionUserOrderByWithRelationInput = {
    sessionId?: SortOrder
    username?: SortOrder
    unseenCnt?: SortOrder
    joinedAt?: SortOrder
    chatSession?: ChatSessionOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ChatSessionUserWhereUniqueInput = {
    sessionId_username?: ChatSessionUserSessionIdUsernameCompoundUniqueInput
  }

  export type ChatSessionUserOrderByWithAggregationInput = {
    sessionId?: SortOrder
    username?: SortOrder
    unseenCnt?: SortOrder
    joinedAt?: SortOrder
    _count?: ChatSessionUserCountOrderByAggregateInput
    _avg?: ChatSessionUserAvgOrderByAggregateInput
    _max?: ChatSessionUserMaxOrderByAggregateInput
    _min?: ChatSessionUserMinOrderByAggregateInput
    _sum?: ChatSessionUserSumOrderByAggregateInput
  }

  export type ChatSessionUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ChatSessionUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<ChatSessionUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ChatSessionUserScalarWhereWithAggregatesInput>
    sessionId?: StringWithAggregatesFilter | string
    username?: StringWithAggregatesFilter | string
    unseenCnt?: IntWithAggregatesFilter | number
    joinedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type MathNoteWhereInput = {
    AND?: Enumerable<MathNoteWhereInput>
    OR?: Enumerable<MathNoteWhereInput>
    NOT?: Enumerable<MathNoteWhereInput>
    creatorId?: StringFilter | string
    content?: StringFilter | string
    mathProblemId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    imageLink?: StringNullableFilter | string | null
    creator?: XOR<UserRelationFilter, UserWhereInput>
    mathProblem?: XOR<MathProblemRelationFilter, MathProblemWhereInput>
  }

  export type MathNoteOrderByWithRelationInput = {
    creatorId?: SortOrder
    content?: SortOrder
    mathProblemId?: SortOrder
    createdAt?: SortOrder
    imageLink?: SortOrder
    creator?: UserOrderByWithRelationInput
    mathProblem?: MathProblemOrderByWithRelationInput
  }

  export type MathNoteWhereUniqueInput = {
    mathProblemId_creatorId?: MathNoteMathProblemIdCreatorIdCompoundUniqueInput
  }

  export type MathNoteOrderByWithAggregationInput = {
    creatorId?: SortOrder
    content?: SortOrder
    mathProblemId?: SortOrder
    createdAt?: SortOrder
    imageLink?: SortOrder
    _count?: MathNoteCountOrderByAggregateInput
    _max?: MathNoteMaxOrderByAggregateInput
    _min?: MathNoteMinOrderByAggregateInput
  }

  export type MathNoteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MathNoteScalarWhereWithAggregatesInput>
    OR?: Enumerable<MathNoteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MathNoteScalarWhereWithAggregatesInput>
    creatorId?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    mathProblemId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    imageLink?: StringNullableWithAggregatesFilter | string | null
  }

  export type MathSolutionWhereInput = {
    AND?: Enumerable<MathSolutionWhereInput>
    OR?: Enumerable<MathSolutionWhereInput>
    NOT?: Enumerable<MathSolutionWhereInput>
    creatorId?: StringFilter | string
    content?: StringFilter | string
    mathProblemId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    checked?: BoolFilter | boolean
    imageLink?: StringNullableFilter | string | null
    creator?: XOR<UserRelationFilter, UserWhereInput>
    mathProblem?: XOR<MathProblemRelationFilter, MathProblemWhereInput>
  }

  export type MathSolutionOrderByWithRelationInput = {
    creatorId?: SortOrder
    content?: SortOrder
    mathProblemId?: SortOrder
    createdAt?: SortOrder
    checked?: SortOrder
    imageLink?: SortOrder
    creator?: UserOrderByWithRelationInput
    mathProblem?: MathProblemOrderByWithRelationInput
  }

  export type MathSolutionWhereUniqueInput = {
    mathProblemId_creatorId?: MathSolutionMathProblemIdCreatorIdCompoundUniqueInput
  }

  export type MathSolutionOrderByWithAggregationInput = {
    creatorId?: SortOrder
    content?: SortOrder
    mathProblemId?: SortOrder
    createdAt?: SortOrder
    checked?: SortOrder
    imageLink?: SortOrder
    _count?: MathSolutionCountOrderByAggregateInput
    _max?: MathSolutionMaxOrderByAggregateInput
    _min?: MathSolutionMinOrderByAggregateInput
  }

  export type MathSolutionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MathSolutionScalarWhereWithAggregatesInput>
    OR?: Enumerable<MathSolutionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MathSolutionScalarWhereWithAggregatesInput>
    creatorId?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    mathProblemId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    checked?: BoolWithAggregatesFilter | boolean
    imageLink?: StringNullableWithAggregatesFilter | string | null
  }

  export type ContestWhereInput = {
    AND?: Enumerable<ContestWhereInput>
    OR?: Enumerable<ContestWhereInput>
    NOT?: Enumerable<ContestWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    description?: StringFilter | string
    realTimeRank?: BoolFilter | boolean
    password?: StringNullableFilter | string | null
    ruleType?: EnumProblemRuleTypeFilter | ProblemRuleType
    startTime?: DateTimeFilter | Date | string
    duration?: IntFilter | number
    endTime?: DateTimeFilter | Date | string
    createTime?: DateTimeFilter | Date | string
    lastUpdateTime?: DateTimeFilter | Date | string
    visible?: BoolFilter | boolean
    codingProblems?: CodingProblemListRelationFilter
  }

  export type ContestOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    realTimeRank?: SortOrder
    password?: SortOrder
    ruleType?: SortOrder
    startTime?: SortOrder
    duration?: SortOrder
    endTime?: SortOrder
    createTime?: SortOrder
    lastUpdateTime?: SortOrder
    visible?: SortOrder
    codingProblems?: CodingProblemOrderByRelationAggregateInput
  }

  export type ContestWhereUniqueInput = {
    id?: string
  }

  export type ContestOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    realTimeRank?: SortOrder
    password?: SortOrder
    ruleType?: SortOrder
    startTime?: SortOrder
    duration?: SortOrder
    endTime?: SortOrder
    createTime?: SortOrder
    lastUpdateTime?: SortOrder
    visible?: SortOrder
    _count?: ContestCountOrderByAggregateInput
    _avg?: ContestAvgOrderByAggregateInput
    _max?: ContestMaxOrderByAggregateInput
    _min?: ContestMinOrderByAggregateInput
    _sum?: ContestSumOrderByAggregateInput
  }

  export type ContestScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ContestScalarWhereWithAggregatesInput>
    OR?: Enumerable<ContestScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ContestScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    realTimeRank?: BoolWithAggregatesFilter | boolean
    password?: StringNullableWithAggregatesFilter | string | null
    ruleType?: EnumProblemRuleTypeWithAggregatesFilter | ProblemRuleType
    startTime?: DateTimeWithAggregatesFilter | Date | string
    duration?: IntWithAggregatesFilter | number
    endTime?: DateTimeWithAggregatesFilter | Date | string
    createTime?: DateTimeWithAggregatesFilter | Date | string
    lastUpdateTime?: DateTimeWithAggregatesFilter | Date | string
    visible?: BoolWithAggregatesFilter | boolean
  }

  export type SubmissionWhereInput = {
    AND?: Enumerable<SubmissionWhereInput>
    OR?: Enumerable<SubmissionWhereInput>
    NOT?: Enumerable<SubmissionWhereInput>
    id?: StringFilter | string
    contestId?: StringNullableFilter | string | null
    problemId?: StringFilter | string
    createTime?: DateTimeFilter | Date | string
    username?: StringFilter | string
    code?: StringFilter | string
    result?: EnumJudgeStatusFilter | JudgeStatus
    language?: StringFilter | string
    shared?: BoolFilter | boolean
    status?: JsonNullableFilter
    statistic_info?: JsonFilter
  }

  export type SubmissionOrderByWithRelationInput = {
    id?: SortOrder
    contestId?: SortOrder
    problemId?: SortOrder
    createTime?: SortOrder
    username?: SortOrder
    code?: SortOrder
    result?: SortOrder
    language?: SortOrder
    shared?: SortOrder
    status?: SortOrder
    statistic_info?: SortOrder
  }

  export type SubmissionWhereUniqueInput = {
    id?: string
  }

  export type SubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    contestId?: SortOrder
    problemId?: SortOrder
    createTime?: SortOrder
    username?: SortOrder
    code?: SortOrder
    result?: SortOrder
    language?: SortOrder
    shared?: SortOrder
    status?: SortOrder
    statistic_info?: SortOrder
    _count?: SubmissionCountOrderByAggregateInput
    _max?: SubmissionMaxOrderByAggregateInput
    _min?: SubmissionMinOrderByAggregateInput
  }

  export type SubmissionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SubmissionScalarWhereWithAggregatesInput>
    OR?: Enumerable<SubmissionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SubmissionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    contestId?: StringNullableWithAggregatesFilter | string | null
    problemId?: StringWithAggregatesFilter | string
    createTime?: DateTimeWithAggregatesFilter | Date | string
    username?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    result?: EnumJudgeStatusWithAggregatesFilter | JudgeStatus
    language?: StringWithAggregatesFilter | string
    shared?: BoolWithAggregatesFilter | boolean
    status?: JsonNullableWithAggregatesFilter
    statistic_info?: JsonWithAggregatesFilter
  }

  export type ChildSubmissionWhereInput = {
    AND?: Enumerable<ChildSubmissionWhereInput>
    OR?: Enumerable<ChildSubmissionWhereInput>
    NOT?: Enumerable<ChildSubmissionWhereInput>
    id?: StringFilter | string
    parentId?: StringFilter | string
    status?: JsonFilter
    token?: StringFilter | string
    languageId?: IntFilter | number
  }

  export type ChildSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    parentId?: SortOrder
    status?: SortOrder
    token?: SortOrder
    languageId?: SortOrder
  }

  export type ChildSubmissionWhereUniqueInput = {
    id?: string
  }

  export type ChildSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    parentId?: SortOrder
    status?: SortOrder
    token?: SortOrder
    languageId?: SortOrder
    _count?: ChildSubmissionCountOrderByAggregateInput
    _avg?: ChildSubmissionAvgOrderByAggregateInput
    _max?: ChildSubmissionMaxOrderByAggregateInput
    _min?: ChildSubmissionMinOrderByAggregateInput
    _sum?: ChildSubmissionSumOrderByAggregateInput
  }

  export type ChildSubmissionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ChildSubmissionScalarWhereWithAggregatesInput>
    OR?: Enumerable<ChildSubmissionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ChildSubmissionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    parentId?: StringWithAggregatesFilter | string
    status?: JsonWithAggregatesFilter
    token?: StringWithAggregatesFilter | string
    languageId?: IntWithAggregatesFilter | number
  }

  export type LanguageWhereInput = {
    AND?: Enumerable<LanguageWhereInput>
    OR?: Enumerable<LanguageWhereInput>
    NOT?: Enumerable<LanguageWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
  }

  export type LanguageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type LanguageWhereUniqueInput = {
    id?: number
  }

  export type LanguageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: LanguageCountOrderByAggregateInput
    _avg?: LanguageAvgOrderByAggregateInput
    _max?: LanguageMaxOrderByAggregateInput
    _min?: LanguageMinOrderByAggregateInput
    _sum?: LanguageSumOrderByAggregateInput
  }

  export type LanguageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LanguageScalarWhereWithAggregatesInput>
    OR?: Enumerable<LanguageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LanguageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type TestcaseWhereInput = {
    AND?: Enumerable<TestcaseWhereInput>
    OR?: Enumerable<TestcaseWhereInput>
    NOT?: Enumerable<TestcaseWhereInput>
    id?: StringFilter | string
    problemId?: StringFilter | string
    subTestNumber?: IntFilter | number
    description?: JsonFilter
    problem?: XOR<CodingProblemRelationFilter, CodingProblemWhereInput>
  }

  export type TestcaseOrderByWithRelationInput = {
    id?: SortOrder
    problemId?: SortOrder
    subTestNumber?: SortOrder
    description?: SortOrder
    problem?: CodingProblemOrderByWithRelationInput
  }

  export type TestcaseWhereUniqueInput = {
    id?: string
  }

  export type TestcaseOrderByWithAggregationInput = {
    id?: SortOrder
    problemId?: SortOrder
    subTestNumber?: SortOrder
    description?: SortOrder
    _count?: TestcaseCountOrderByAggregateInput
    _avg?: TestcaseAvgOrderByAggregateInput
    _max?: TestcaseMaxOrderByAggregateInput
    _min?: TestcaseMinOrderByAggregateInput
    _sum?: TestcaseSumOrderByAggregateInput
  }

  export type TestcaseScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TestcaseScalarWhereWithAggregatesInput>
    OR?: Enumerable<TestcaseScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TestcaseScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    problemId?: StringWithAggregatesFilter | string
    subTestNumber?: IntWithAggregatesFilter | number
    description?: JsonWithAggregatesFilter
  }

  export type UserCreateInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemCreateNestedManyWithoutUserInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelCreateNestedManyWithoutUserInput
    posts?: GroupPostCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemUncheckedCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemUncheckedCreateNestedManyWithoutUserInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadUncheckedCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteUncheckedCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionUncheckedCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetUncheckedCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelUncheckedCreateNestedManyWithoutUserInput
    posts?: GroupPostUncheckedCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserUncheckedCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUpdateManyWithoutUserNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUpdateManyWithoutUserNestedInput
    posts?: GroupPostUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUncheckedUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUncheckedUpdateManyWithoutUserNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUncheckedUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUncheckedUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUncheckedUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUncheckedUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUncheckedUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUncheckedUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUncheckedUpdateManyWithoutUserNestedInput
    posts?: GroupPostUncheckedUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUncheckedUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateManyInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRatingCreateInput = {
    username: string
    rating: number
  }

  export type UserRatingUncheckedCreateInput = {
    username: string
    rating: number
  }

  export type UserRatingUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
  }

  export type UserRatingUncheckedUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
  }

  export type UserRatingCreateManyInput = {
    username: string
    rating: number
  }

  export type UserRatingUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
  }

  export type UserRatingUncheckedUpdateManyInput = {
    username?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
  }

  export type FriendShipCreateInput = {
    id?: string
    username1: string
    username2: string
    establishedAt?: Date | string
  }

  export type FriendShipUncheckedCreateInput = {
    id?: string
    username1: string
    username2: string
    establishedAt?: Date | string
  }

  export type FriendShipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username1?: StringFieldUpdateOperationsInput | string
    username2?: StringFieldUpdateOperationsInput | string
    establishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendShipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username1?: StringFieldUpdateOperationsInput | string
    username2?: StringFieldUpdateOperationsInput | string
    establishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendShipCreateManyInput = {
    id?: string
    username1: string
    username2: string
    establishedAt?: Date | string
  }

  export type FriendShipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username1?: StringFieldUpdateOperationsInput | string
    username2?: StringFieldUpdateOperationsInput | string
    establishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendShipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username1?: StringFieldUpdateOperationsInput | string
    username2?: StringFieldUpdateOperationsInput | string
    establishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendRequestCreateInput = {
    id?: string
    disable?: boolean
    sender: UserCreateNestedOneWithoutMyFriendReqsInput
    reciever: UserCreateNestedOneWithoutOtherFriendReqsInput
  }

  export type FriendRequestUncheckedCreateInput = {
    id?: string
    senderId: string
    recieverId: string
    disable?: boolean
  }

  export type FriendRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    sender?: UserUpdateOneRequiredWithoutMyFriendReqsNestedInput
    reciever?: UserUpdateOneRequiredWithoutOtherFriendReqsNestedInput
  }

  export type FriendRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recieverId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FriendRequestCreateManyInput = {
    id?: string
    senderId: string
    recieverId: string
    disable?: boolean
  }

  export type FriendRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FriendRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recieverId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SharePTPCreateInput = {
    id: string
    resourceId: string
    resourceType: string
    senderId: string
    receiverId: string
    resourceLink?: string | null
    look?: boolean
    createdAt?: Date | string
  }

  export type SharePTPUncheckedCreateInput = {
    id: string
    resourceId: string
    resourceType: string
    senderId: string
    receiverId: string
    resourceLink?: string | null
    look?: boolean
    createdAt?: Date | string
  }

  export type SharePTPUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    resourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    look?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharePTPUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    resourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    look?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharePTPCreateManyInput = {
    id: string
    resourceId: string
    resourceType: string
    senderId: string
    receiverId: string
    resourceLink?: string | null
    look?: boolean
    createdAt?: Date | string
  }

  export type SharePTPUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    resourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    look?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharePTPUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    resourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    look?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupCreateInput = {
    id?: string
    name: string
    generalChatSessionId?: string | null
    createdAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedGroupInput
    users?: UserGroupRelCreateNestedManyWithoutGroupInput
    posts?: GroupPostCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateInput = {
    id?: string
    name: string
    creatorId: string
    generalChatSessionId?: string | null
    createdAt?: Date | string
    users?: UserGroupRelUncheckedCreateNestedManyWithoutGroupInput
    posts?: GroupPostUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generalChatSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedGroupNestedInput
    users?: UserGroupRelUpdateManyWithoutGroupNestedInput
    posts?: GroupPostUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    generalChatSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserGroupRelUncheckedUpdateManyWithoutGroupNestedInput
    posts?: GroupPostUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupCreateManyInput = {
    id?: string
    name: string
    creatorId: string
    generalChatSessionId?: string | null
    createdAt?: Date | string
  }

  export type GroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generalChatSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    generalChatSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGroupRelCreateInput = {
    joinedAt: Date | string
    user: UserCreateNestedOneWithoutJoinedGroupsInput
    group: GroupCreateNestedOneWithoutUsersInput
  }

  export type UserGroupRelUncheckedCreateInput = {
    username: string
    groupId: string
    joinedAt: Date | string
  }

  export type UserGroupRelUpdateInput = {
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutJoinedGroupsNestedInput
    group?: GroupUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserGroupRelUncheckedUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGroupRelCreateManyInput = {
    username: string
    groupId: string
    joinedAt: Date | string
  }

  export type UserGroupRelUpdateManyMutationInput = {
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGroupRelUncheckedUpdateManyInput = {
    username?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileCreateInput = {
    id?: string
    real_name?: string | null
    avatar?: string | null
    blog?: string | null
    github?: string | null
    school?: string | null
    major?: string | null
    language?: string | null
    accepted_number?: number | null
    total_score?: number | null
    total_practice_score?: number | null
    submission_number?: number | null
    rating?: number | null
    user: UserCreateNestedOneWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateInput = {
    id?: string
    real_name?: string | null
    avatar?: string | null
    blog?: string | null
    github?: string | null
    school?: string | null
    major?: string | null
    language?: string | null
    accepted_number?: number | null
    total_score?: number | null
    total_practice_score?: number | null
    submission_number?: number | null
    rating?: number | null
    username: string
  }

  export type UserProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    real_name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    blog?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    accepted_number?: NullableIntFieldUpdateOperationsInput | number | null
    total_score?: NullableIntFieldUpdateOperationsInput | number | null
    total_practice_score?: NullableIntFieldUpdateOperationsInput | number | null
    submission_number?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    real_name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    blog?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    accepted_number?: NullableIntFieldUpdateOperationsInput | number | null
    total_score?: NullableIntFieldUpdateOperationsInput | number | null
    total_practice_score?: NullableIntFieldUpdateOperationsInput | number | null
    submission_number?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    username?: StringFieldUpdateOperationsInput | string
  }

  export type UserProfileCreateManyInput = {
    id?: string
    real_name?: string | null
    avatar?: string | null
    blog?: string | null
    github?: string | null
    school?: string | null
    major?: string | null
    language?: string | null
    accepted_number?: number | null
    total_score?: number | null
    total_practice_score?: number | null
    submission_number?: number | null
    rating?: number | null
    username: string
  }

  export type UserProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    real_name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    blog?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    accepted_number?: NullableIntFieldUpdateOperationsInput | number | null
    total_score?: NullableIntFieldUpdateOperationsInput | number | null
    total_practice_score?: NullableIntFieldUpdateOperationsInput | number | null
    submission_number?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    real_name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    blog?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    accepted_number?: NullableIntFieldUpdateOperationsInput | number | null
    total_score?: NullableIntFieldUpdateOperationsInput | number | null
    total_practice_score?: NullableIntFieldUpdateOperationsInput | number | null
    submission_number?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    username?: StringFieldUpdateOperationsInput | string
  }

  export type CodingProblemCategoryCreateInput = {
    name: string
    codingProblems?: CodingProblemCreateNestedManyWithoutCategoryInput
  }

  export type CodingProblemCategoryUncheckedCreateInput = {
    id?: number
    name: string
    codingProblems?: CodingProblemUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CodingProblemCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    codingProblems?: CodingProblemUpdateManyWithoutCategoryNestedInput
  }

  export type CodingProblemCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    codingProblems?: CodingProblemUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CodingProblemCategoryCreateManyInput = {
    id?: number
    name: string
  }

  export type CodingProblemCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CodingProblemCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CodingProblemTagCreateInput = {
    name: string
    codingProblems?: TagCodingProblemCreateNestedManyWithoutTagInput
  }

  export type CodingProblemTagUncheckedCreateInput = {
    id?: number
    name: string
    codingProblems?: TagCodingProblemUncheckedCreateNestedManyWithoutTagInput
  }

  export type CodingProblemTagUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    codingProblems?: TagCodingProblemUpdateManyWithoutTagNestedInput
  }

  export type CodingProblemTagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    codingProblems?: TagCodingProblemUncheckedUpdateManyWithoutTagNestedInput
  }

  export type CodingProblemTagCreateManyInput = {
    id?: number
    name: string
  }

  export type CodingProblemTagUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CodingProblemTagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CodeforcesTagCreateInput = {
    id: string
    name: string
    parentId?: string | null
    problems?: CodefocesTagProblemCreateNestedManyWithoutCodeforcesTagInput
  }

  export type CodeforcesTagUncheckedCreateInput = {
    id: string
    name: string
    parentId?: string | null
    problems?: CodefocesTagProblemUncheckedCreateNestedManyWithoutCodeforcesTagInput
  }

  export type CodeforcesTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    problems?: CodefocesTagProblemUpdateManyWithoutCodeforcesTagNestedInput
  }

  export type CodeforcesTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    problems?: CodefocesTagProblemUncheckedUpdateManyWithoutCodeforcesTagNestedInput
  }

  export type CodeforcesTagCreateManyInput = {
    id: string
    name: string
    parentId?: string | null
  }

  export type CodeforcesTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CodeforcesTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CodefocesTagProblemCreateInput = {
    problem: CodingProblemCreateNestedOneWithoutCodeforcesTagInput
    codeforcesTag: CodeforcesTagCreateNestedOneWithoutProblemsInput
  }

  export type CodefocesTagProblemUncheckedCreateInput = {
    problemId: string
    codeforcesTagId: string
  }

  export type CodefocesTagProblemUpdateInput = {
    problem?: CodingProblemUpdateOneRequiredWithoutCodeforcesTagNestedInput
    codeforcesTag?: CodeforcesTagUpdateOneRequiredWithoutProblemsNestedInput
  }

  export type CodefocesTagProblemUncheckedUpdateInput = {
    problemId?: StringFieldUpdateOperationsInput | string
    codeforcesTagId?: StringFieldUpdateOperationsInput | string
  }

  export type CodefocesTagProblemCreateManyInput = {
    problemId: string
    codeforcesTagId: string
  }

  export type CodefocesTagProblemUpdateManyMutationInput = {

  }

  export type CodefocesTagProblemUncheckedUpdateManyInput = {
    problemId?: StringFieldUpdateOperationsInput | string
    codeforcesTagId?: StringFieldUpdateOperationsInput | string
  }

  export type CodingProblemCreateInput = {
    id: string
    code: string
    title: string
    link?: string | null
    description?: string | null
    timeLimit?: number
    memoryLimit?: number
    difficulty?: number
    practicePoint?: number
    totalPoint?: number
    submissionNumber?: number
    acceptedNumber?: number
    visibleFrom?: Date | string | null
    category: CodingProblemCategoryCreateNestedOneWithoutCodingProblemsInput
    authors?: AuthorCodingProblemCreateNestedManyWithoutCodingProblemInput
    tags?: TagCodingProblemCreateNestedManyWithoutCodingProblemInput
    codeforcesTag?: CodefocesTagProblemCreateNestedManyWithoutProblemInput
    testCases?: TestcaseCreateNestedManyWithoutProblemInput
    contest?: ContestCreateNestedOneWithoutCodingProblemsInput
  }

  export type CodingProblemUncheckedCreateInput = {
    id: string
    code: string
    title: string
    categoryId: number
    link?: string | null
    description?: string | null
    timeLimit?: number
    memoryLimit?: number
    difficulty?: number
    practicePoint?: number
    totalPoint?: number
    submissionNumber?: number
    acceptedNumber?: number
    contestId?: string | null
    visibleFrom?: Date | string | null
    authors?: AuthorCodingProblemUncheckedCreateNestedManyWithoutCodingProblemInput
    tags?: TagCodingProblemUncheckedCreateNestedManyWithoutCodingProblemInput
    codeforcesTag?: CodefocesTagProblemUncheckedCreateNestedManyWithoutProblemInput
    testCases?: TestcaseUncheckedCreateNestedManyWithoutProblemInput
  }

  export type CodingProblemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: IntFieldUpdateOperationsInput | number
    memoryLimit?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: IntFieldUpdateOperationsInput | number
    totalPoint?: IntFieldUpdateOperationsInput | number
    submissionNumber?: IntFieldUpdateOperationsInput | number
    acceptedNumber?: IntFieldUpdateOperationsInput | number
    visibleFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CodingProblemCategoryUpdateOneRequiredWithoutCodingProblemsNestedInput
    authors?: AuthorCodingProblemUpdateManyWithoutCodingProblemNestedInput
    tags?: TagCodingProblemUpdateManyWithoutCodingProblemNestedInput
    codeforcesTag?: CodefocesTagProblemUpdateManyWithoutProblemNestedInput
    testCases?: TestcaseUpdateManyWithoutProblemNestedInput
    contest?: ContestUpdateOneWithoutCodingProblemsNestedInput
  }

  export type CodingProblemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: IntFieldUpdateOperationsInput | number
    memoryLimit?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: IntFieldUpdateOperationsInput | number
    totalPoint?: IntFieldUpdateOperationsInput | number
    submissionNumber?: IntFieldUpdateOperationsInput | number
    acceptedNumber?: IntFieldUpdateOperationsInput | number
    contestId?: NullableStringFieldUpdateOperationsInput | string | null
    visibleFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authors?: AuthorCodingProblemUncheckedUpdateManyWithoutCodingProblemNestedInput
    tags?: TagCodingProblemUncheckedUpdateManyWithoutCodingProblemNestedInput
    codeforcesTag?: CodefocesTagProblemUncheckedUpdateManyWithoutProblemNestedInput
    testCases?: TestcaseUncheckedUpdateManyWithoutProblemNestedInput
  }

  export type CodingProblemCreateManyInput = {
    id: string
    code: string
    title: string
    categoryId: number
    link?: string | null
    description?: string | null
    timeLimit?: number
    memoryLimit?: number
    difficulty?: number
    practicePoint?: number
    totalPoint?: number
    submissionNumber?: number
    acceptedNumber?: number
    contestId?: string | null
    visibleFrom?: Date | string | null
  }

  export type CodingProblemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: IntFieldUpdateOperationsInput | number
    memoryLimit?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: IntFieldUpdateOperationsInput | number
    totalPoint?: IntFieldUpdateOperationsInput | number
    submissionNumber?: IntFieldUpdateOperationsInput | number
    acceptedNumber?: IntFieldUpdateOperationsInput | number
    visibleFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CodingProblemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: IntFieldUpdateOperationsInput | number
    memoryLimit?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: IntFieldUpdateOperationsInput | number
    totalPoint?: IntFieldUpdateOperationsInput | number
    submissionNumber?: IntFieldUpdateOperationsInput | number
    acceptedNumber?: IntFieldUpdateOperationsInput | number
    contestId?: NullableStringFieldUpdateOperationsInput | string | null
    visibleFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuthorCodingProblemCreateInput = {
    user: UserCreateNestedOneWithoutCodingProblemsInput
    codingProblem: CodingProblemCreateNestedOneWithoutAuthorsInput
  }

  export type AuthorCodingProblemUncheckedCreateInput = {
    username: string
    codingProblemId: string
  }

  export type AuthorCodingProblemUpdateInput = {
    user?: UserUpdateOneRequiredWithoutCodingProblemsNestedInput
    codingProblem?: CodingProblemUpdateOneRequiredWithoutAuthorsNestedInput
  }

  export type AuthorCodingProblemUncheckedUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    codingProblemId?: StringFieldUpdateOperationsInput | string
  }

  export type AuthorCodingProblemCreateManyInput = {
    username: string
    codingProblemId: string
  }

  export type AuthorCodingProblemUpdateManyMutationInput = {

  }

  export type AuthorCodingProblemUncheckedUpdateManyInput = {
    username?: StringFieldUpdateOperationsInput | string
    codingProblemId?: StringFieldUpdateOperationsInput | string
  }

  export type TagCodingProblemCreateInput = {
    tag: CodingProblemTagCreateNestedOneWithoutCodingProblemsInput
    codingProblem: CodingProblemCreateNestedOneWithoutTagsInput
  }

  export type TagCodingProblemUncheckedCreateInput = {
    tagId: number
    codingProblemId: string
  }

  export type TagCodingProblemUpdateInput = {
    tag?: CodingProblemTagUpdateOneRequiredWithoutCodingProblemsNestedInput
    codingProblem?: CodingProblemUpdateOneRequiredWithoutTagsNestedInput
  }

  export type TagCodingProblemUncheckedUpdateInput = {
    tagId?: IntFieldUpdateOperationsInput | number
    codingProblemId?: StringFieldUpdateOperationsInput | string
  }

  export type TagCodingProblemCreateManyInput = {
    tagId: number
    codingProblemId: string
  }

  export type TagCodingProblemUpdateManyMutationInput = {

  }

  export type TagCodingProblemUncheckedUpdateManyInput = {
    tagId?: IntFieldUpdateOperationsInput | number
    codingProblemId?: StringFieldUpdateOperationsInput | string
  }

  export type ThreadCreateInput = {
    id: string
    parentId?: string | null
    title: string
    summary: string
    published: boolean
    createdAt?: Date | string
    lastUpdateAt?: Date | string
    publishedAt?: Date | string
    content: string
    totalComments?: number
    totalRootComments?: number
    likes?: number
    views?: number
    author: UserCreateNestedOneWithoutThreadsInput
    comments?: CommentCreateNestedManyWithoutThreadInput
    category?: ThreadCategoryCreateNestedOneWithoutThreadsInput
    tags?: ThreadTagRelCreateNestedManyWithoutThreadInput
    userLikes?: UserLikeThreadCreateNestedManyWithoutThreadInput
  }

  export type ThreadUncheckedCreateInput = {
    id: string
    authorId: string
    parentId?: string | null
    title: string
    summary: string
    published: boolean
    createdAt?: Date | string
    lastUpdateAt?: Date | string
    publishedAt?: Date | string
    content: string
    totalComments?: number
    totalRootComments?: number
    likes?: number
    views?: number
    categoryId?: number | null
    comments?: CommentUncheckedCreateNestedManyWithoutThreadInput
    tags?: ThreadTagRelUncheckedCreateNestedManyWithoutThreadInput
    userLikes?: UserLikeThreadUncheckedCreateNestedManyWithoutThreadInput
  }

  export type ThreadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    totalComments?: IntFieldUpdateOperationsInput | number
    totalRootComments?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    author?: UserUpdateOneRequiredWithoutThreadsNestedInput
    comments?: CommentUpdateManyWithoutThreadNestedInput
    category?: ThreadCategoryUpdateOneWithoutThreadsNestedInput
    tags?: ThreadTagRelUpdateManyWithoutThreadNestedInput
    userLikes?: UserLikeThreadUpdateManyWithoutThreadNestedInput
  }

  export type ThreadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    totalComments?: IntFieldUpdateOperationsInput | number
    totalRootComments?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: CommentUncheckedUpdateManyWithoutThreadNestedInput
    tags?: ThreadTagRelUncheckedUpdateManyWithoutThreadNestedInput
    userLikes?: UserLikeThreadUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type ThreadCreateManyInput = {
    id: string
    authorId: string
    parentId?: string | null
    title: string
    summary: string
    published: boolean
    createdAt?: Date | string
    lastUpdateAt?: Date | string
    publishedAt?: Date | string
    content: string
    totalComments?: number
    totalRootComments?: number
    likes?: number
    views?: number
    categoryId?: number | null
  }

  export type ThreadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    totalComments?: IntFieldUpdateOperationsInput | number
    totalRootComments?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
  }

  export type ThreadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    totalComments?: IntFieldUpdateOperationsInput | number
    totalRootComments?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ThreadCategoryCreateInput = {
    parentId?: string | null
    title: string
    threads?: ThreadCreateNestedManyWithoutCategoryInput
  }

  export type ThreadCategoryUncheckedCreateInput = {
    id?: number
    parentId?: string | null
    title: string
    threads?: ThreadUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ThreadCategoryUpdateInput = {
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    threads?: ThreadUpdateManyWithoutCategoryNestedInput
  }

  export type ThreadCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    threads?: ThreadUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ThreadCategoryCreateManyInput = {
    id?: number
    parentId?: string | null
    title: string
  }

  export type ThreadCategoryUpdateManyMutationInput = {
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
  }

  export type ThreadCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
  }

  export type ThreadTagCreateInput = {
    id: string
    title: string
    threads?: ThreadTagRelCreateNestedManyWithoutTagInput
  }

  export type ThreadTagUncheckedCreateInput = {
    id: string
    title: string
    threads?: ThreadTagRelUncheckedCreateNestedManyWithoutTagInput
  }

  export type ThreadTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    threads?: ThreadTagRelUpdateManyWithoutTagNestedInput
  }

  export type ThreadTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    threads?: ThreadTagRelUncheckedUpdateManyWithoutTagNestedInput
  }

  export type ThreadTagCreateManyInput = {
    id: string
    title: string
  }

  export type ThreadTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type ThreadTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type ThreadTagRelCreateInput = {
    thread: ThreadCreateNestedOneWithoutTagsInput
    tag: ThreadTagCreateNestedOneWithoutThreadsInput
  }

  export type ThreadTagRelUncheckedCreateInput = {
    threadId: string
    tagId: string
  }

  export type ThreadTagRelUpdateInput = {
    thread?: ThreadUpdateOneRequiredWithoutTagsNestedInput
    tag?: ThreadTagUpdateOneRequiredWithoutThreadsNestedInput
  }

  export type ThreadTagRelUncheckedUpdateInput = {
    threadId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ThreadTagRelCreateManyInput = {
    threadId: string
    tagId: string
  }

  export type ThreadTagRelUpdateManyMutationInput = {

  }

  export type ThreadTagRelUncheckedUpdateManyInput = {
    threadId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type UserLikeThreadCreateInput = {
    disable?: boolean
    user: UserCreateNestedOneWithoutThreadLikedInput
    thread: ThreadCreateNestedOneWithoutUserLikesInput
  }

  export type UserLikeThreadUncheckedCreateInput = {
    username: string
    threadId: string
    disable?: boolean
  }

  export type UserLikeThreadUpdateInput = {
    disable?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutThreadLikedNestedInput
    thread?: ThreadUpdateOneRequiredWithoutUserLikesNestedInput
  }

  export type UserLikeThreadUncheckedUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserLikeThreadCreateManyInput = {
    username: string
    threadId: string
    disable?: boolean
  }

  export type UserLikeThreadUpdateManyMutationInput = {
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserLikeThreadUncheckedUpdateManyInput = {
    username?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserLikeCommentCreateInput = {
    disable?: boolean
    user: UserCreateNestedOneWithoutCommentLikedInput
    comment: CommentCreateNestedOneWithoutUsersLikedInput
  }

  export type UserLikeCommentUncheckedCreateInput = {
    username: string
    commentId: string
    disable?: boolean
  }

  export type UserLikeCommentUpdateInput = {
    disable?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutCommentLikedNestedInput
    comment?: CommentUpdateOneRequiredWithoutUsersLikedNestedInput
  }

  export type UserLikeCommentUncheckedUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserLikeCommentCreateManyInput = {
    username: string
    commentId: string
    disable?: boolean
  }

  export type UserLikeCommentUpdateManyMutationInput = {
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserLikeCommentUncheckedUpdateManyInput = {
    username?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommentCreateInput = {
    id: string
    parentId?: string | null
    rootId: string
    totalChildren?: number
    depth?: number
    likes?: number
    parentUsername?: string | null
    published?: boolean
    createdAt?: Date | string
    content: string
    thread: ThreadCreateNestedOneWithoutCommentsInput
    creator: UserCreateNestedOneWithoutCommentsInput
    usersLiked?: UserLikeCommentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateInput = {
    id: string
    threadId: string
    parentId?: string | null
    rootId: string
    totalChildren?: number
    depth?: number
    likes?: number
    parentUsername?: string | null
    creatorId: string
    published?: boolean
    createdAt?: Date | string
    content: string
    usersLiked?: UserLikeCommentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: StringFieldUpdateOperationsInput | string
    totalChildren?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    parentUsername?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    thread?: ThreadUpdateOneRequiredWithoutCommentsNestedInput
    creator?: UserUpdateOneRequiredWithoutCommentsNestedInput
    usersLiked?: UserLikeCommentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: StringFieldUpdateOperationsInput | string
    totalChildren?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    parentUsername?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    usersLiked?: UserLikeCommentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentCreateManyInput = {
    id: string
    threadId: string
    parentId?: string | null
    rootId: string
    totalChildren?: number
    depth?: number
    likes?: number
    parentUsername?: string | null
    creatorId: string
    published?: boolean
    createdAt?: Date | string
    content: string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: StringFieldUpdateOperationsInput | string
    totalChildren?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    parentUsername?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: StringFieldUpdateOperationsInput | string
    totalChildren?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    parentUsername?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type MathProblemCategoryCreateInput = {
    name: string
    mathProblems?: MathProblemCreateNestedManyWithoutCategoryInput
  }

  export type MathProblemCategoryUncheckedCreateInput = {
    id?: number
    name: string
    mathProblems?: MathProblemUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type MathProblemCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    mathProblems?: MathProblemUpdateManyWithoutCategoryNestedInput
  }

  export type MathProblemCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    mathProblems?: MathProblemUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type MathProblemCategoryCreateManyInput = {
    id?: number
    name: string
  }

  export type MathProblemCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MathProblemCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MathProblemTagCreateInput = {
    name: string
    parentId?: number | null
    nextSibling?: number | null
    prevSibling?: number | null
    mathProblems?: TagMathProblemCreateNestedManyWithoutTagInput
  }

  export type MathProblemTagUncheckedCreateInput = {
    id?: number
    name: string
    parentId?: number | null
    nextSibling?: number | null
    prevSibling?: number | null
    mathProblems?: TagMathProblemUncheckedCreateNestedManyWithoutTagInput
  }

  export type MathProblemTagUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    nextSibling?: NullableIntFieldUpdateOperationsInput | number | null
    prevSibling?: NullableIntFieldUpdateOperationsInput | number | null
    mathProblems?: TagMathProblemUpdateManyWithoutTagNestedInput
  }

  export type MathProblemTagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    nextSibling?: NullableIntFieldUpdateOperationsInput | number | null
    prevSibling?: NullableIntFieldUpdateOperationsInput | number | null
    mathProblems?: TagMathProblemUncheckedUpdateManyWithoutTagNestedInput
  }

  export type MathProblemTagCreateManyInput = {
    id?: number
    name: string
    parentId?: number | null
    nextSibling?: number | null
    prevSibling?: number | null
  }

  export type MathProblemTagUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    nextSibling?: NullableIntFieldUpdateOperationsInput | number | null
    prevSibling?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MathProblemTagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    nextSibling?: NullableIntFieldUpdateOperationsInput | number | null
    prevSibling?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MathProblemCreateInput = {
    id: string
    title: string
    link?: string | null
    description?: string | null
    hint?: string | null
    difficulty?: number
    practicePoint?: number | null
    totalPoint?: number | null
    prevProblems?: string | null
    nextProblems?: string | null
    numSolution?: number
    numCheckedSolution?: number
    category: MathProblemCategoryCreateNestedOneWithoutMathProblemsInput
    authors?: AuthorMathProblemCreateNestedManyWithoutMathProblemInput
    tags?: TagMathProblemCreateNestedManyWithoutMathProblemInput
    mathNotes?: MathNoteCreateNestedManyWithoutMathProblemInput
    mathSolutions?: MathSolutionCreateNestedManyWithoutMathProblemInput
    problemSet?: MathSetProbRelCreateNestedManyWithoutProblemInput
  }

  export type MathProblemUncheckedCreateInput = {
    id: string
    title: string
    categoryId: number
    link?: string | null
    description?: string | null
    hint?: string | null
    difficulty?: number
    practicePoint?: number | null
    totalPoint?: number | null
    prevProblems?: string | null
    nextProblems?: string | null
    numSolution?: number
    numCheckedSolution?: number
    authors?: AuthorMathProblemUncheckedCreateNestedManyWithoutMathProblemInput
    tags?: TagMathProblemUncheckedCreateNestedManyWithoutMathProblemInput
    mathNotes?: MathNoteUncheckedCreateNestedManyWithoutMathProblemInput
    mathSolutions?: MathSolutionUncheckedCreateNestedManyWithoutMathProblemInput
    problemSet?: MathSetProbRelUncheckedCreateNestedManyWithoutProblemInput
  }

  export type MathProblemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: NullableIntFieldUpdateOperationsInput | number | null
    totalPoint?: NullableIntFieldUpdateOperationsInput | number | null
    prevProblems?: NullableStringFieldUpdateOperationsInput | string | null
    nextProblems?: NullableStringFieldUpdateOperationsInput | string | null
    numSolution?: IntFieldUpdateOperationsInput | number
    numCheckedSolution?: IntFieldUpdateOperationsInput | number
    category?: MathProblemCategoryUpdateOneRequiredWithoutMathProblemsNestedInput
    authors?: AuthorMathProblemUpdateManyWithoutMathProblemNestedInput
    tags?: TagMathProblemUpdateManyWithoutMathProblemNestedInput
    mathNotes?: MathNoteUpdateManyWithoutMathProblemNestedInput
    mathSolutions?: MathSolutionUpdateManyWithoutMathProblemNestedInput
    problemSet?: MathSetProbRelUpdateManyWithoutProblemNestedInput
  }

  export type MathProblemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: NullableIntFieldUpdateOperationsInput | number | null
    totalPoint?: NullableIntFieldUpdateOperationsInput | number | null
    prevProblems?: NullableStringFieldUpdateOperationsInput | string | null
    nextProblems?: NullableStringFieldUpdateOperationsInput | string | null
    numSolution?: IntFieldUpdateOperationsInput | number
    numCheckedSolution?: IntFieldUpdateOperationsInput | number
    authors?: AuthorMathProblemUncheckedUpdateManyWithoutMathProblemNestedInput
    tags?: TagMathProblemUncheckedUpdateManyWithoutMathProblemNestedInput
    mathNotes?: MathNoteUncheckedUpdateManyWithoutMathProblemNestedInput
    mathSolutions?: MathSolutionUncheckedUpdateManyWithoutMathProblemNestedInput
    problemSet?: MathSetProbRelUncheckedUpdateManyWithoutProblemNestedInput
  }

  export type MathProblemCreateManyInput = {
    id: string
    title: string
    categoryId: number
    link?: string | null
    description?: string | null
    hint?: string | null
    difficulty?: number
    practicePoint?: number | null
    totalPoint?: number | null
    prevProblems?: string | null
    nextProblems?: string | null
    numSolution?: number
    numCheckedSolution?: number
  }

  export type MathProblemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: NullableIntFieldUpdateOperationsInput | number | null
    totalPoint?: NullableIntFieldUpdateOperationsInput | number | null
    prevProblems?: NullableStringFieldUpdateOperationsInput | string | null
    nextProblems?: NullableStringFieldUpdateOperationsInput | string | null
    numSolution?: IntFieldUpdateOperationsInput | number
    numCheckedSolution?: IntFieldUpdateOperationsInput | number
  }

  export type MathProblemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: NullableIntFieldUpdateOperationsInput | number | null
    totalPoint?: NullableIntFieldUpdateOperationsInput | number | null
    prevProblems?: NullableStringFieldUpdateOperationsInput | string | null
    nextProblems?: NullableStringFieldUpdateOperationsInput | string | null
    numSolution?: IntFieldUpdateOperationsInput | number
    numCheckedSolution?: IntFieldUpdateOperationsInput | number
  }

  export type MathProblemSetCreateInput = {
    id: string
    title: string
    numberProb: number
    creator: UserCreateNestedOneWithoutMathProbSetListInput
    problems?: MathSetProbRelCreateNestedManyWithoutMathProbSetInput
  }

  export type MathProblemSetUncheckedCreateInput = {
    id: string
    title: string
    creatorId: string
    numberProb: number
    problems?: MathSetProbRelUncheckedCreateNestedManyWithoutMathProbSetInput
  }

  export type MathProblemSetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    numberProb?: IntFieldUpdateOperationsInput | number
    creator?: UserUpdateOneRequiredWithoutMathProbSetListNestedInput
    problems?: MathSetProbRelUpdateManyWithoutMathProbSetNestedInput
  }

  export type MathProblemSetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    numberProb?: IntFieldUpdateOperationsInput | number
    problems?: MathSetProbRelUncheckedUpdateManyWithoutMathProbSetNestedInput
  }

  export type MathProblemSetCreateManyInput = {
    id: string
    title: string
    creatorId: string
    numberProb: number
  }

  export type MathProblemSetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    numberProb?: IntFieldUpdateOperationsInput | number
  }

  export type MathProblemSetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    numberProb?: IntFieldUpdateOperationsInput | number
  }

  export type MathSetProbRelCreateInput = {
    order: string
    problem: MathProblemCreateNestedOneWithoutProblemSetInput
    mathProbSet: MathProblemSetCreateNestedOneWithoutProblemsInput
  }

  export type MathSetProbRelUncheckedCreateInput = {
    problemId: string
    setId: string
    order: string
  }

  export type MathSetProbRelUpdateInput = {
    order?: StringFieldUpdateOperationsInput | string
    problem?: MathProblemUpdateOneRequiredWithoutProblemSetNestedInput
    mathProbSet?: MathProblemSetUpdateOneRequiredWithoutProblemsNestedInput
  }

  export type MathSetProbRelUncheckedUpdateInput = {
    problemId?: StringFieldUpdateOperationsInput | string
    setId?: StringFieldUpdateOperationsInput | string
    order?: StringFieldUpdateOperationsInput | string
  }

  export type MathSetProbRelCreateManyInput = {
    problemId: string
    setId: string
    order: string
  }

  export type MathSetProbRelUpdateManyMutationInput = {
    order?: StringFieldUpdateOperationsInput | string
  }

  export type MathSetProbRelUncheckedUpdateManyInput = {
    problemId?: StringFieldUpdateOperationsInput | string
    setId?: StringFieldUpdateOperationsInput | string
    order?: StringFieldUpdateOperationsInput | string
  }

  export type AuthorMathProblemCreateInput = {
    user: UserCreateNestedOneWithoutAuthorMathProblemsInput
    mathProblem: MathProblemCreateNestedOneWithoutAuthorsInput
  }

  export type AuthorMathProblemUncheckedCreateInput = {
    username: string
    mathProblemId: string
  }

  export type AuthorMathProblemUpdateInput = {
    user?: UserUpdateOneRequiredWithoutAuthorMathProblemsNestedInput
    mathProblem?: MathProblemUpdateOneRequiredWithoutAuthorsNestedInput
  }

  export type AuthorMathProblemUncheckedUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    mathProblemId?: StringFieldUpdateOperationsInput | string
  }

  export type AuthorMathProblemCreateManyInput = {
    username: string
    mathProblemId: string
  }

  export type AuthorMathProblemUpdateManyMutationInput = {

  }

  export type AuthorMathProblemUncheckedUpdateManyInput = {
    username?: StringFieldUpdateOperationsInput | string
    mathProblemId?: StringFieldUpdateOperationsInput | string
  }

  export type TagMathProblemCreateInput = {
    tag: MathProblemTagCreateNestedOneWithoutMathProblemsInput
    mathProblem: MathProblemCreateNestedOneWithoutTagsInput
  }

  export type TagMathProblemUncheckedCreateInput = {
    tagId: number
    mathProblemId: string
  }

  export type TagMathProblemUpdateInput = {
    tag?: MathProblemTagUpdateOneRequiredWithoutMathProblemsNestedInput
    mathProblem?: MathProblemUpdateOneRequiredWithoutTagsNestedInput
  }

  export type TagMathProblemUncheckedUpdateInput = {
    tagId?: IntFieldUpdateOperationsInput | number
    mathProblemId?: StringFieldUpdateOperationsInput | string
  }

  export type TagMathProblemCreateManyInput = {
    tagId: number
    mathProblemId: string
  }

  export type TagMathProblemUpdateManyMutationInput = {

  }

  export type TagMathProblemUncheckedUpdateManyInput = {
    tagId?: IntFieldUpdateOperationsInput | number
    mathProblemId?: StringFieldUpdateOperationsInput | string
  }

  export type GroupPostCreateInput = {
    id: string
    content: string
    createdAt?: Date | string
    title: string
    author: UserCreateNestedOneWithoutPostsInput
    group: GroupCreateNestedOneWithoutPostsInput
    messages?: GroupPostMessageCreateNestedManyWithoutPostInput
  }

  export type GroupPostUncheckedCreateInput = {
    id: string
    content: string
    authorId: string
    createdAt?: Date | string
    groupId: string
    title: string
    messages?: GroupPostMessageUncheckedCreateNestedManyWithoutPostInput
  }

  export type GroupPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
    group?: GroupUpdateOneRequiredWithoutPostsNestedInput
    messages?: GroupPostMessageUpdateManyWithoutPostNestedInput
  }

  export type GroupPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    messages?: GroupPostMessageUncheckedUpdateManyWithoutPostNestedInput
  }

  export type GroupPostCreateManyInput = {
    id: string
    content: string
    authorId: string
    createdAt?: Date | string
    groupId: string
    title: string
  }

  export type GroupPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type GroupPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type ChatMessageCreateInput = {
    id: string
    content: string
    createdAt?: Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
    author: UserCreateNestedOneWithoutChatMessagesInput
    chatSession: ChatSessionCreateNestedOneWithoutChatMessagesInput
  }

  export type ChatMessageUncheckedCreateInput = {
    id: string
    content: string
    authorId: string
    createdAt?: Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
    sessionId: string
  }

  export type ChatMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
    author?: UserUpdateOneRequiredWithoutChatMessagesNestedInput
    chatSession?: ChatSessionUpdateOneRequiredWithoutChatMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: StringFieldUpdateOperationsInput | string
  }

  export type ChatMessageCreateManyInput = {
    id: string
    content: string
    authorId: string
    createdAt?: Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
    sessionId: string
  }

  export type ChatMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ChatMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: StringFieldUpdateOperationsInput | string
  }

  export type GroupPostMessageCreateInput = {
    id: string
    content: string
    createdAt?: Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
    author: UserCreateNestedOneWithoutGroupPostMessagesInput
    post: GroupPostCreateNestedOneWithoutMessagesInput
  }

  export type GroupPostMessageUncheckedCreateInput = {
    id: string
    content: string
    authorId: string
    createdAt?: Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
    postId: string
  }

  export type GroupPostMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
    author?: UserUpdateOneRequiredWithoutGroupPostMessagesNestedInput
    post?: GroupPostUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type GroupPostMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type GroupPostMessageCreateManyInput = {
    id: string
    content: string
    authorId: string
    createdAt?: Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
    postId: string
  }

  export type GroupPostMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GroupPostMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type ChatSessionCreateInput = {
    id: string
    lastMessage: JsonNullValueInput | InputJsonValue
    lastUpdate: Date | string
    groupId?: string | null
    type: ChatSessionType
    usersInfo?: NullableJsonNullValueInput | InputJsonValue
    chatMessages?: ChatMessageCreateNestedManyWithoutChatSessionInput
    users?: ChatSessionUserCreateNestedManyWithoutChatSessionInput
  }

  export type ChatSessionUncheckedCreateInput = {
    id: string
    lastMessage: JsonNullValueInput | InputJsonValue
    lastUpdate: Date | string
    groupId?: string | null
    type: ChatSessionType
    usersInfo?: NullableJsonNullValueInput | InputJsonValue
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutChatSessionInput
    users?: ChatSessionUserUncheckedCreateNestedManyWithoutChatSessionInput
  }

  export type ChatSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessage?: JsonNullValueInput | InputJsonValue
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChatSessionTypeFieldUpdateOperationsInput | ChatSessionType
    usersInfo?: NullableJsonNullValueInput | InputJsonValue
    chatMessages?: ChatMessageUpdateManyWithoutChatSessionNestedInput
    users?: ChatSessionUserUpdateManyWithoutChatSessionNestedInput
  }

  export type ChatSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessage?: JsonNullValueInput | InputJsonValue
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChatSessionTypeFieldUpdateOperationsInput | ChatSessionType
    usersInfo?: NullableJsonNullValueInput | InputJsonValue
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutChatSessionNestedInput
    users?: ChatSessionUserUncheckedUpdateManyWithoutChatSessionNestedInput
  }

  export type ChatSessionCreateManyInput = {
    id: string
    lastMessage: JsonNullValueInput | InputJsonValue
    lastUpdate: Date | string
    groupId?: string | null
    type: ChatSessionType
    usersInfo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ChatSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessage?: JsonNullValueInput | InputJsonValue
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChatSessionTypeFieldUpdateOperationsInput | ChatSessionType
    usersInfo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ChatSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessage?: JsonNullValueInput | InputJsonValue
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChatSessionTypeFieldUpdateOperationsInput | ChatSessionType
    usersInfo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ChatSessionUserCreateInput = {
    unseenCnt?: number
    joinedAt: Date | string
    chatSession: ChatSessionCreateNestedOneWithoutUsersInput
    user: UserCreateNestedOneWithoutChatSessionsInput
  }

  export type ChatSessionUserUncheckedCreateInput = {
    sessionId: string
    username: string
    unseenCnt?: number
    joinedAt: Date | string
  }

  export type ChatSessionUserUpdateInput = {
    unseenCnt?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatSession?: ChatSessionUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneRequiredWithoutChatSessionsNestedInput
  }

  export type ChatSessionUserUncheckedUpdateInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    unseenCnt?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatSessionUserCreateManyInput = {
    sessionId: string
    username: string
    unseenCnt?: number
    joinedAt: Date | string
  }

  export type ChatSessionUserUpdateManyMutationInput = {
    unseenCnt?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatSessionUserUncheckedUpdateManyInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    unseenCnt?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MathNoteCreateInput = {
    content: string
    createdAt?: Date | string
    imageLink?: string | null
    creator: UserCreateNestedOneWithoutMathNotesInput
    mathProblem: MathProblemCreateNestedOneWithoutMathNotesInput
  }

  export type MathNoteUncheckedCreateInput = {
    creatorId: string
    content: string
    mathProblemId: string
    createdAt?: Date | string
    imageLink?: string | null
  }

  export type MathNoteUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageLink?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: UserUpdateOneRequiredWithoutMathNotesNestedInput
    mathProblem?: MathProblemUpdateOneRequiredWithoutMathNotesNestedInput
  }

  export type MathNoteUncheckedUpdateInput = {
    creatorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    mathProblemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MathNoteCreateManyInput = {
    creatorId: string
    content: string
    mathProblemId: string
    createdAt?: Date | string
    imageLink?: string | null
  }

  export type MathNoteUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MathNoteUncheckedUpdateManyInput = {
    creatorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    mathProblemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MathSolutionCreateInput = {
    content: string
    createdAt?: Date | string
    checked?: boolean
    imageLink?: string | null
    creator: UserCreateNestedOneWithoutMathSolutionsInput
    mathProblem: MathProblemCreateNestedOneWithoutMathSolutionsInput
  }

  export type MathSolutionUncheckedCreateInput = {
    creatorId: string
    content: string
    mathProblemId: string
    createdAt?: Date | string
    checked?: boolean
    imageLink?: string | null
  }

  export type MathSolutionUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checked?: BoolFieldUpdateOperationsInput | boolean
    imageLink?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: UserUpdateOneRequiredWithoutMathSolutionsNestedInput
    mathProblem?: MathProblemUpdateOneRequiredWithoutMathSolutionsNestedInput
  }

  export type MathSolutionUncheckedUpdateInput = {
    creatorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    mathProblemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checked?: BoolFieldUpdateOperationsInput | boolean
    imageLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MathSolutionCreateManyInput = {
    creatorId: string
    content: string
    mathProblemId: string
    createdAt?: Date | string
    checked?: boolean
    imageLink?: string | null
  }

  export type MathSolutionUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checked?: BoolFieldUpdateOperationsInput | boolean
    imageLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MathSolutionUncheckedUpdateManyInput = {
    creatorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    mathProblemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checked?: BoolFieldUpdateOperationsInput | boolean
    imageLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContestCreateInput = {
    id: string
    title: string
    description: string
    realTimeRank: boolean
    password?: string | null
    ruleType: ProblemRuleType
    startTime: Date | string
    duration: number
    endTime: Date | string
    createTime?: Date | string
    lastUpdateTime?: Date | string
    visible?: boolean
    codingProblems?: CodingProblemCreateNestedManyWithoutContestInput
  }

  export type ContestUncheckedCreateInput = {
    id: string
    title: string
    description: string
    realTimeRank: boolean
    password?: string | null
    ruleType: ProblemRuleType
    startTime: Date | string
    duration: number
    endTime: Date | string
    createTime?: Date | string
    lastUpdateTime?: Date | string
    visible?: boolean
    codingProblems?: CodingProblemUncheckedCreateNestedManyWithoutContestInput
  }

  export type ContestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    realTimeRank?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ruleType?: EnumProblemRuleTypeFieldUpdateOperationsInput | ProblemRuleType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createTime?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    codingProblems?: CodingProblemUpdateManyWithoutContestNestedInput
  }

  export type ContestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    realTimeRank?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ruleType?: EnumProblemRuleTypeFieldUpdateOperationsInput | ProblemRuleType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createTime?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    codingProblems?: CodingProblemUncheckedUpdateManyWithoutContestNestedInput
  }

  export type ContestCreateManyInput = {
    id: string
    title: string
    description: string
    realTimeRank: boolean
    password?: string | null
    ruleType: ProblemRuleType
    startTime: Date | string
    duration: number
    endTime: Date | string
    createTime?: Date | string
    lastUpdateTime?: Date | string
    visible?: boolean
  }

  export type ContestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    realTimeRank?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ruleType?: EnumProblemRuleTypeFieldUpdateOperationsInput | ProblemRuleType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createTime?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    visible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ContestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    realTimeRank?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ruleType?: EnumProblemRuleTypeFieldUpdateOperationsInput | ProblemRuleType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createTime?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    visible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SubmissionCreateInput = {
    id: string
    contestId?: string | null
    problemId: string
    createTime: Date | string
    username: string
    code: string
    result?: JudgeStatus
    language: string
    shared: boolean
    status?: NullableJsonNullValueInput | InputJsonValue
    statistic_info: JsonNullValueInput | InputJsonValue
  }

  export type SubmissionUncheckedCreateInput = {
    id: string
    contestId?: string | null
    problemId: string
    createTime: Date | string
    username: string
    code: string
    result?: JudgeStatus
    language: string
    shared: boolean
    status?: NullableJsonNullValueInput | InputJsonValue
    statistic_info: JsonNullValueInput | InputJsonValue
  }

  export type SubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contestId?: NullableStringFieldUpdateOperationsInput | string | null
    problemId?: StringFieldUpdateOperationsInput | string
    createTime?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    result?: EnumJudgeStatusFieldUpdateOperationsInput | JudgeStatus
    language?: StringFieldUpdateOperationsInput | string
    shared?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableJsonNullValueInput | InputJsonValue
    statistic_info?: JsonNullValueInput | InputJsonValue
  }

  export type SubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contestId?: NullableStringFieldUpdateOperationsInput | string | null
    problemId?: StringFieldUpdateOperationsInput | string
    createTime?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    result?: EnumJudgeStatusFieldUpdateOperationsInput | JudgeStatus
    language?: StringFieldUpdateOperationsInput | string
    shared?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableJsonNullValueInput | InputJsonValue
    statistic_info?: JsonNullValueInput | InputJsonValue
  }

  export type SubmissionCreateManyInput = {
    id: string
    contestId?: string | null
    problemId: string
    createTime: Date | string
    username: string
    code: string
    result?: JudgeStatus
    language: string
    shared: boolean
    status?: NullableJsonNullValueInput | InputJsonValue
    statistic_info: JsonNullValueInput | InputJsonValue
  }

  export type SubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contestId?: NullableStringFieldUpdateOperationsInput | string | null
    problemId?: StringFieldUpdateOperationsInput | string
    createTime?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    result?: EnumJudgeStatusFieldUpdateOperationsInput | JudgeStatus
    language?: StringFieldUpdateOperationsInput | string
    shared?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableJsonNullValueInput | InputJsonValue
    statistic_info?: JsonNullValueInput | InputJsonValue
  }

  export type SubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contestId?: NullableStringFieldUpdateOperationsInput | string | null
    problemId?: StringFieldUpdateOperationsInput | string
    createTime?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    result?: EnumJudgeStatusFieldUpdateOperationsInput | JudgeStatus
    language?: StringFieldUpdateOperationsInput | string
    shared?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableJsonNullValueInput | InputJsonValue
    statistic_info?: JsonNullValueInput | InputJsonValue
  }

  export type ChildSubmissionCreateInput = {
    id: string
    parentId: string
    status: JsonNullValueInput | InputJsonValue
    token: string
    languageId: number
  }

  export type ChildSubmissionUncheckedCreateInput = {
    id: string
    parentId: string
    status: JsonNullValueInput | InputJsonValue
    token: string
    languageId: number
  }

  export type ChildSubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    status?: JsonNullValueInput | InputJsonValue
    token?: StringFieldUpdateOperationsInput | string
    languageId?: IntFieldUpdateOperationsInput | number
  }

  export type ChildSubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    status?: JsonNullValueInput | InputJsonValue
    token?: StringFieldUpdateOperationsInput | string
    languageId?: IntFieldUpdateOperationsInput | number
  }

  export type ChildSubmissionCreateManyInput = {
    id: string
    parentId: string
    status: JsonNullValueInput | InputJsonValue
    token: string
    languageId: number
  }

  export type ChildSubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    status?: JsonNullValueInput | InputJsonValue
    token?: StringFieldUpdateOperationsInput | string
    languageId?: IntFieldUpdateOperationsInput | number
  }

  export type ChildSubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    status?: JsonNullValueInput | InputJsonValue
    token?: StringFieldUpdateOperationsInput | string
    languageId?: IntFieldUpdateOperationsInput | number
  }

  export type LanguageCreateInput = {
    id: number
    name: string
  }

  export type LanguageUncheckedCreateInput = {
    id: number
    name: string
  }

  export type LanguageUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LanguageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LanguageCreateManyInput = {
    id: number
    name: string
  }

  export type LanguageUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LanguageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TestcaseCreateInput = {
    id: string
    subTestNumber: number
    description: JsonNullValueInput | InputJsonValue
    problem: CodingProblemCreateNestedOneWithoutTestCasesInput
  }

  export type TestcaseUncheckedCreateInput = {
    id: string
    problemId: string
    subTestNumber: number
    description: JsonNullValueInput | InputJsonValue
  }

  export type TestcaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subTestNumber?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
    problem?: CodingProblemUpdateOneRequiredWithoutTestCasesNestedInput
  }

  export type TestcaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    problemId?: StringFieldUpdateOperationsInput | string
    subTestNumber?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
  }

  export type TestcaseCreateManyInput = {
    id: string
    problemId: string
    subTestNumber: number
    description: JsonNullValueInput | InputJsonValue
  }

  export type TestcaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subTestNumber?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
  }

  export type TestcaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    problemId?: StringFieldUpdateOperationsInput | string
    subTestNumber?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type Enumadmin_typeFilter = {
    equals?: admin_type
    in?: Enumerable<admin_type>
    notIn?: Enumerable<admin_type>
    not?: NestedEnumadmin_typeFilter | admin_type
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type AuthorCodingProblemListRelationFilter = {
    every?: AuthorCodingProblemWhereInput
    some?: AuthorCodingProblemWhereInput
    none?: AuthorCodingProblemWhereInput
  }

  export type AuthorMathProblemListRelationFilter = {
    every?: AuthorMathProblemWhereInput
    some?: AuthorMathProblemWhereInput
    none?: AuthorMathProblemWhereInput
  }

  export type ThreadListRelationFilter = {
    every?: ThreadWhereInput
    some?: ThreadWhereInput
    none?: ThreadWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type UserLikeThreadListRelationFilter = {
    every?: UserLikeThreadWhereInput
    some?: UserLikeThreadWhereInput
    none?: UserLikeThreadWhereInput
  }

  export type UserLikeCommentListRelationFilter = {
    every?: UserLikeCommentWhereInput
    some?: UserLikeCommentWhereInput
    none?: UserLikeCommentWhereInput
  }

  export type UserProfileRelationFilter = {
    is?: UserProfileWhereInput | null
    isNot?: UserProfileWhereInput | null
  }

  export type MathNoteListRelationFilter = {
    every?: MathNoteWhereInput
    some?: MathNoteWhereInput
    none?: MathNoteWhereInput
  }

  export type MathSolutionListRelationFilter = {
    every?: MathSolutionWhereInput
    some?: MathSolutionWhereInput
    none?: MathSolutionWhereInput
  }

  export type MathProblemSetListRelationFilter = {
    every?: MathProblemSetWhereInput
    some?: MathProblemSetWhereInput
    none?: MathProblemSetWhereInput
  }

  export type FriendRequestListRelationFilter = {
    every?: FriendRequestWhereInput
    some?: FriendRequestWhereInput
    none?: FriendRequestWhereInput
  }

  export type GroupListRelationFilter = {
    every?: GroupWhereInput
    some?: GroupWhereInput
    none?: GroupWhereInput
  }

  export type UserGroupRelListRelationFilter = {
    every?: UserGroupRelWhereInput
    some?: UserGroupRelWhereInput
    none?: UserGroupRelWhereInput
  }

  export type GroupPostListRelationFilter = {
    every?: GroupPostWhereInput
    some?: GroupPostWhereInput
    none?: GroupPostWhereInput
  }

  export type ChatMessageListRelationFilter = {
    every?: ChatMessageWhereInput
    some?: ChatMessageWhereInput
    none?: ChatMessageWhereInput
  }

  export type ChatSessionUserListRelationFilter = {
    every?: ChatSessionUserWhereInput
    some?: ChatSessionUserWhereInput
    none?: ChatSessionUserWhereInput
  }

  export type GroupPostMessageListRelationFilter = {
    every?: GroupPostMessageWhereInput
    some?: GroupPostMessageWhereInput
    none?: GroupPostMessageWhereInput
  }

  export type AuthorCodingProblemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuthorMathProblemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ThreadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserLikeThreadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserLikeCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MathNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MathSolutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MathProblemSetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FriendRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserGroupRelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatSessionUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupPostMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    username?: SortOrder
    email?: SortOrder
    create_time?: SortOrder
    admin_type?: SortOrder
    is_disabled?: SortOrder
    auth0_id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    username?: SortOrder
    email?: SortOrder
    create_time?: SortOrder
    admin_type?: SortOrder
    is_disabled?: SortOrder
    auth0_id?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    username?: SortOrder
    email?: SortOrder
    create_time?: SortOrder
    admin_type?: SortOrder
    is_disabled?: SortOrder
    auth0_id?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type Enumadmin_typeWithAggregatesFilter = {
    equals?: admin_type
    in?: Enumerable<admin_type>
    notIn?: Enumerable<admin_type>
    not?: NestedEnumadmin_typeWithAggregatesFilter | admin_type
    _count?: NestedIntFilter
    _min?: NestedEnumadmin_typeFilter
    _max?: NestedEnumadmin_typeFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type UserRatingCountOrderByAggregateInput = {
    username?: SortOrder
    rating?: SortOrder
  }

  export type UserRatingAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type UserRatingMaxOrderByAggregateInput = {
    username?: SortOrder
    rating?: SortOrder
  }

  export type UserRatingMinOrderByAggregateInput = {
    username?: SortOrder
    rating?: SortOrder
  }

  export type UserRatingSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type FriendShipCountOrderByAggregateInput = {
    id?: SortOrder
    username1?: SortOrder
    username2?: SortOrder
    establishedAt?: SortOrder
  }

  export type FriendShipMaxOrderByAggregateInput = {
    id?: SortOrder
    username1?: SortOrder
    username2?: SortOrder
    establishedAt?: SortOrder
  }

  export type FriendShipMinOrderByAggregateInput = {
    id?: SortOrder
    username1?: SortOrder
    username2?: SortOrder
    establishedAt?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type FriendRequestCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    recieverId?: SortOrder
    disable?: SortOrder
  }

  export type FriendRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    recieverId?: SortOrder
    disable?: SortOrder
  }

  export type FriendRequestMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    recieverId?: SortOrder
    disable?: SortOrder
  }

  export type SharePTPCountOrderByAggregateInput = {
    id?: SortOrder
    resourceId?: SortOrder
    resourceType?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    resourceLink?: SortOrder
    look?: SortOrder
    createdAt?: SortOrder
  }

  export type SharePTPMaxOrderByAggregateInput = {
    id?: SortOrder
    resourceId?: SortOrder
    resourceType?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    resourceLink?: SortOrder
    look?: SortOrder
    createdAt?: SortOrder
  }

  export type SharePTPMinOrderByAggregateInput = {
    id?: SortOrder
    resourceId?: SortOrder
    resourceType?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    resourceLink?: SortOrder
    look?: SortOrder
    createdAt?: SortOrder
  }

  export type GroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    creatorId?: SortOrder
    generalChatSessionId?: SortOrder
    createdAt?: SortOrder
  }

  export type GroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    creatorId?: SortOrder
    generalChatSessionId?: SortOrder
    createdAt?: SortOrder
  }

  export type GroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    creatorId?: SortOrder
    generalChatSessionId?: SortOrder
    createdAt?: SortOrder
  }

  export type GroupRelationFilter = {
    is?: GroupWhereInput
    isNot?: GroupWhereInput
  }

  export type UserGroupRelUsernameGroupIdCompoundUniqueInput = {
    username: string
    groupId: string
  }

  export type UserGroupRelCountOrderByAggregateInput = {
    username?: SortOrder
    groupId?: SortOrder
    joinedAt?: SortOrder
  }

  export type UserGroupRelMaxOrderByAggregateInput = {
    username?: SortOrder
    groupId?: SortOrder
    joinedAt?: SortOrder
  }

  export type UserGroupRelMinOrderByAggregateInput = {
    username?: SortOrder
    groupId?: SortOrder
    joinedAt?: SortOrder
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type UserProfileCountOrderByAggregateInput = {
    id?: SortOrder
    real_name?: SortOrder
    avatar?: SortOrder
    blog?: SortOrder
    github?: SortOrder
    school?: SortOrder
    major?: SortOrder
    language?: SortOrder
    accepted_number?: SortOrder
    total_score?: SortOrder
    total_practice_score?: SortOrder
    submission_number?: SortOrder
    rating?: SortOrder
    username?: SortOrder
  }

  export type UserProfileAvgOrderByAggregateInput = {
    accepted_number?: SortOrder
    total_score?: SortOrder
    total_practice_score?: SortOrder
    submission_number?: SortOrder
    rating?: SortOrder
  }

  export type UserProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    real_name?: SortOrder
    avatar?: SortOrder
    blog?: SortOrder
    github?: SortOrder
    school?: SortOrder
    major?: SortOrder
    language?: SortOrder
    accepted_number?: SortOrder
    total_score?: SortOrder
    total_practice_score?: SortOrder
    submission_number?: SortOrder
    rating?: SortOrder
    username?: SortOrder
  }

  export type UserProfileMinOrderByAggregateInput = {
    id?: SortOrder
    real_name?: SortOrder
    avatar?: SortOrder
    blog?: SortOrder
    github?: SortOrder
    school?: SortOrder
    major?: SortOrder
    language?: SortOrder
    accepted_number?: SortOrder
    total_score?: SortOrder
    total_practice_score?: SortOrder
    submission_number?: SortOrder
    rating?: SortOrder
    username?: SortOrder
  }

  export type UserProfileSumOrderByAggregateInput = {
    accepted_number?: SortOrder
    total_score?: SortOrder
    total_practice_score?: SortOrder
    submission_number?: SortOrder
    rating?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type CodingProblemListRelationFilter = {
    every?: CodingProblemWhereInput
    some?: CodingProblemWhereInput
    none?: CodingProblemWhereInput
  }

  export type CodingProblemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CodingProblemCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CodingProblemCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CodingProblemCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CodingProblemCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CodingProblemCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TagCodingProblemListRelationFilter = {
    every?: TagCodingProblemWhereInput
    some?: TagCodingProblemWhereInput
    none?: TagCodingProblemWhereInput
  }

  export type TagCodingProblemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CodingProblemTagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CodingProblemTagAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CodingProblemTagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CodingProblemTagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CodingProblemTagSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CodefocesTagProblemListRelationFilter = {
    every?: CodefocesTagProblemWhereInput
    some?: CodefocesTagProblemWhereInput
    none?: CodefocesTagProblemWhereInput
  }

  export type CodefocesTagProblemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CodeforcesTagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
  }

  export type CodeforcesTagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
  }

  export type CodeforcesTagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
  }

  export type CodingProblemRelationFilter = {
    is?: CodingProblemWhereInput
    isNot?: CodingProblemWhereInput
  }

  export type CodeforcesTagRelationFilter = {
    is?: CodeforcesTagWhereInput
    isNot?: CodeforcesTagWhereInput
  }

  export type CodefocesTagProblemProblemIdCodeforcesTagIdCompoundUniqueInput = {
    problemId: string
    codeforcesTagId: string
  }

  export type CodefocesTagProblemCountOrderByAggregateInput = {
    problemId?: SortOrder
    codeforcesTagId?: SortOrder
  }

  export type CodefocesTagProblemMaxOrderByAggregateInput = {
    problemId?: SortOrder
    codeforcesTagId?: SortOrder
  }

  export type CodefocesTagProblemMinOrderByAggregateInput = {
    problemId?: SortOrder
    codeforcesTagId?: SortOrder
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type CodingProblemCategoryRelationFilter = {
    is?: CodingProblemCategoryWhereInput
    isNot?: CodingProblemCategoryWhereInput
  }

  export type TestcaseListRelationFilter = {
    every?: TestcaseWhereInput
    some?: TestcaseWhereInput
    none?: TestcaseWhereInput
  }

  export type ContestRelationFilter = {
    is?: ContestWhereInput | null
    isNot?: ContestWhereInput | null
  }

  export type TestcaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CodingProblemCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    categoryId?: SortOrder
    link?: SortOrder
    description?: SortOrder
    timeLimit?: SortOrder
    memoryLimit?: SortOrder
    difficulty?: SortOrder
    practicePoint?: SortOrder
    totalPoint?: SortOrder
    submissionNumber?: SortOrder
    acceptedNumber?: SortOrder
    contestId?: SortOrder
    visibleFrom?: SortOrder
  }

  export type CodingProblemAvgOrderByAggregateInput = {
    categoryId?: SortOrder
    timeLimit?: SortOrder
    memoryLimit?: SortOrder
    difficulty?: SortOrder
    practicePoint?: SortOrder
    totalPoint?: SortOrder
    submissionNumber?: SortOrder
    acceptedNumber?: SortOrder
  }

  export type CodingProblemMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    categoryId?: SortOrder
    link?: SortOrder
    description?: SortOrder
    timeLimit?: SortOrder
    memoryLimit?: SortOrder
    difficulty?: SortOrder
    practicePoint?: SortOrder
    totalPoint?: SortOrder
    submissionNumber?: SortOrder
    acceptedNumber?: SortOrder
    contestId?: SortOrder
    visibleFrom?: SortOrder
  }

  export type CodingProblemMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    categoryId?: SortOrder
    link?: SortOrder
    description?: SortOrder
    timeLimit?: SortOrder
    memoryLimit?: SortOrder
    difficulty?: SortOrder
    practicePoint?: SortOrder
    totalPoint?: SortOrder
    submissionNumber?: SortOrder
    acceptedNumber?: SortOrder
    contestId?: SortOrder
    visibleFrom?: SortOrder
  }

  export type CodingProblemSumOrderByAggregateInput = {
    categoryId?: SortOrder
    timeLimit?: SortOrder
    memoryLimit?: SortOrder
    difficulty?: SortOrder
    practicePoint?: SortOrder
    totalPoint?: SortOrder
    submissionNumber?: SortOrder
    acceptedNumber?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type AuthorCodingProblemUsernameCodingProblemIdCompoundUniqueInput = {
    username: string
    codingProblemId: string
  }

  export type AuthorCodingProblemCountOrderByAggregateInput = {
    username?: SortOrder
    codingProblemId?: SortOrder
  }

  export type AuthorCodingProblemMaxOrderByAggregateInput = {
    username?: SortOrder
    codingProblemId?: SortOrder
  }

  export type AuthorCodingProblemMinOrderByAggregateInput = {
    username?: SortOrder
    codingProblemId?: SortOrder
  }

  export type CodingProblemTagRelationFilter = {
    is?: CodingProblemTagWhereInput
    isNot?: CodingProblemTagWhereInput
  }

  export type TagCodingProblemTagIdCodingProblemIdCompoundUniqueInput = {
    tagId: number
    codingProblemId: string
  }

  export type TagCodingProblemCountOrderByAggregateInput = {
    tagId?: SortOrder
    codingProblemId?: SortOrder
  }

  export type TagCodingProblemAvgOrderByAggregateInput = {
    tagId?: SortOrder
  }

  export type TagCodingProblemMaxOrderByAggregateInput = {
    tagId?: SortOrder
    codingProblemId?: SortOrder
  }

  export type TagCodingProblemMinOrderByAggregateInput = {
    tagId?: SortOrder
    codingProblemId?: SortOrder
  }

  export type TagCodingProblemSumOrderByAggregateInput = {
    tagId?: SortOrder
  }

  export type ThreadCategoryRelationFilter = {
    is?: ThreadCategoryWhereInput | null
    isNot?: ThreadCategoryWhereInput | null
  }

  export type ThreadTagRelListRelationFilter = {
    every?: ThreadTagRelWhereInput
    some?: ThreadTagRelWhereInput
    none?: ThreadTagRelWhereInput
  }

  export type ThreadTagRelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ThreadCountOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    lastUpdateAt?: SortOrder
    publishedAt?: SortOrder
    content?: SortOrder
    totalComments?: SortOrder
    totalRootComments?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    categoryId?: SortOrder
  }

  export type ThreadAvgOrderByAggregateInput = {
    totalComments?: SortOrder
    totalRootComments?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    categoryId?: SortOrder
  }

  export type ThreadMaxOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    lastUpdateAt?: SortOrder
    publishedAt?: SortOrder
    content?: SortOrder
    totalComments?: SortOrder
    totalRootComments?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    categoryId?: SortOrder
  }

  export type ThreadMinOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    lastUpdateAt?: SortOrder
    publishedAt?: SortOrder
    content?: SortOrder
    totalComments?: SortOrder
    totalRootComments?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    categoryId?: SortOrder
  }

  export type ThreadSumOrderByAggregateInput = {
    totalComments?: SortOrder
    totalRootComments?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    categoryId?: SortOrder
  }

  export type ThreadCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    title?: SortOrder
  }

  export type ThreadCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ThreadCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    title?: SortOrder
  }

  export type ThreadCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    title?: SortOrder
  }

  export type ThreadCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ThreadTagCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type ThreadTagMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type ThreadTagMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type ThreadRelationFilter = {
    is?: ThreadWhereInput
    isNot?: ThreadWhereInput
  }

  export type ThreadTagRelationFilter = {
    is?: ThreadTagWhereInput
    isNot?: ThreadTagWhereInput
  }

  export type ThreadTagRelThreadIdTagIdCompoundUniqueInput = {
    threadId: string
    tagId: string
  }

  export type ThreadTagRelCountOrderByAggregateInput = {
    threadId?: SortOrder
    tagId?: SortOrder
  }

  export type ThreadTagRelMaxOrderByAggregateInput = {
    threadId?: SortOrder
    tagId?: SortOrder
  }

  export type ThreadTagRelMinOrderByAggregateInput = {
    threadId?: SortOrder
    tagId?: SortOrder
  }

  export type UserLikeThreadUsernameThreadIdCompoundUniqueInput = {
    username: string
    threadId: string
  }

  export type UserLikeThreadCountOrderByAggregateInput = {
    username?: SortOrder
    threadId?: SortOrder
    disable?: SortOrder
  }

  export type UserLikeThreadMaxOrderByAggregateInput = {
    username?: SortOrder
    threadId?: SortOrder
    disable?: SortOrder
  }

  export type UserLikeThreadMinOrderByAggregateInput = {
    username?: SortOrder
    threadId?: SortOrder
    disable?: SortOrder
  }

  export type CommentRelationFilter = {
    is?: CommentWhereInput
    isNot?: CommentWhereInput
  }

  export type UserLikeCommentUsernameCommentIdCompoundUniqueInput = {
    username: string
    commentId: string
  }

  export type UserLikeCommentCountOrderByAggregateInput = {
    username?: SortOrder
    commentId?: SortOrder
    disable?: SortOrder
  }

  export type UserLikeCommentMaxOrderByAggregateInput = {
    username?: SortOrder
    commentId?: SortOrder
    disable?: SortOrder
  }

  export type UserLikeCommentMinOrderByAggregateInput = {
    username?: SortOrder
    commentId?: SortOrder
    disable?: SortOrder
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    parentId?: SortOrder
    rootId?: SortOrder
    totalChildren?: SortOrder
    depth?: SortOrder
    likes?: SortOrder
    parentUsername?: SortOrder
    creatorId?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    content?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    totalChildren?: SortOrder
    depth?: SortOrder
    likes?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    parentId?: SortOrder
    rootId?: SortOrder
    totalChildren?: SortOrder
    depth?: SortOrder
    likes?: SortOrder
    parentUsername?: SortOrder
    creatorId?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    content?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    parentId?: SortOrder
    rootId?: SortOrder
    totalChildren?: SortOrder
    depth?: SortOrder
    likes?: SortOrder
    parentUsername?: SortOrder
    creatorId?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    content?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    totalChildren?: SortOrder
    depth?: SortOrder
    likes?: SortOrder
  }

  export type MathProblemListRelationFilter = {
    every?: MathProblemWhereInput
    some?: MathProblemWhereInput
    none?: MathProblemWhereInput
  }

  export type MathProblemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MathProblemCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type MathProblemCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MathProblemCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type MathProblemCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type MathProblemCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TagMathProblemListRelationFilter = {
    every?: TagMathProblemWhereInput
    some?: TagMathProblemWhereInput
    none?: TagMathProblemWhereInput
  }

  export type TagMathProblemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MathProblemTagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    nextSibling?: SortOrder
    prevSibling?: SortOrder
  }

  export type MathProblemTagAvgOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    nextSibling?: SortOrder
    prevSibling?: SortOrder
  }

  export type MathProblemTagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    nextSibling?: SortOrder
    prevSibling?: SortOrder
  }

  export type MathProblemTagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    nextSibling?: SortOrder
    prevSibling?: SortOrder
  }

  export type MathProblemTagSumOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    nextSibling?: SortOrder
    prevSibling?: SortOrder
  }

  export type MathProblemCategoryRelationFilter = {
    is?: MathProblemCategoryWhereInput
    isNot?: MathProblemCategoryWhereInput
  }

  export type MathSetProbRelListRelationFilter = {
    every?: MathSetProbRelWhereInput
    some?: MathSetProbRelWhereInput
    none?: MathSetProbRelWhereInput
  }

  export type MathSetProbRelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MathProblemCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    categoryId?: SortOrder
    link?: SortOrder
    description?: SortOrder
    hint?: SortOrder
    difficulty?: SortOrder
    practicePoint?: SortOrder
    totalPoint?: SortOrder
    prevProblems?: SortOrder
    nextProblems?: SortOrder
    numSolution?: SortOrder
    numCheckedSolution?: SortOrder
  }

  export type MathProblemAvgOrderByAggregateInput = {
    categoryId?: SortOrder
    difficulty?: SortOrder
    practicePoint?: SortOrder
    totalPoint?: SortOrder
    numSolution?: SortOrder
    numCheckedSolution?: SortOrder
  }

  export type MathProblemMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    categoryId?: SortOrder
    link?: SortOrder
    description?: SortOrder
    hint?: SortOrder
    difficulty?: SortOrder
    practicePoint?: SortOrder
    totalPoint?: SortOrder
    prevProblems?: SortOrder
    nextProblems?: SortOrder
    numSolution?: SortOrder
    numCheckedSolution?: SortOrder
  }

  export type MathProblemMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    categoryId?: SortOrder
    link?: SortOrder
    description?: SortOrder
    hint?: SortOrder
    difficulty?: SortOrder
    practicePoint?: SortOrder
    totalPoint?: SortOrder
    prevProblems?: SortOrder
    nextProblems?: SortOrder
    numSolution?: SortOrder
    numCheckedSolution?: SortOrder
  }

  export type MathProblemSumOrderByAggregateInput = {
    categoryId?: SortOrder
    difficulty?: SortOrder
    practicePoint?: SortOrder
    totalPoint?: SortOrder
    numSolution?: SortOrder
    numCheckedSolution?: SortOrder
  }

  export type MathProblemSetCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    creatorId?: SortOrder
    numberProb?: SortOrder
  }

  export type MathProblemSetAvgOrderByAggregateInput = {
    numberProb?: SortOrder
  }

  export type MathProblemSetMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    creatorId?: SortOrder
    numberProb?: SortOrder
  }

  export type MathProblemSetMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    creatorId?: SortOrder
    numberProb?: SortOrder
  }

  export type MathProblemSetSumOrderByAggregateInput = {
    numberProb?: SortOrder
  }

  export type MathProblemRelationFilter = {
    is?: MathProblemWhereInput
    isNot?: MathProblemWhereInput
  }

  export type MathProblemSetRelationFilter = {
    is?: MathProblemSetWhereInput
    isNot?: MathProblemSetWhereInput
  }

  export type MathSetProbRelSetIdProblemIdCompoundUniqueInput = {
    setId: string
    problemId: string
  }

  export type MathSetProbRelCountOrderByAggregateInput = {
    problemId?: SortOrder
    setId?: SortOrder
    order?: SortOrder
  }

  export type MathSetProbRelMaxOrderByAggregateInput = {
    problemId?: SortOrder
    setId?: SortOrder
    order?: SortOrder
  }

  export type MathSetProbRelMinOrderByAggregateInput = {
    problemId?: SortOrder
    setId?: SortOrder
    order?: SortOrder
  }

  export type AuthorMathProblemUsernameMathProblemIdCompoundUniqueInput = {
    username: string
    mathProblemId: string
  }

  export type AuthorMathProblemCountOrderByAggregateInput = {
    username?: SortOrder
    mathProblemId?: SortOrder
  }

  export type AuthorMathProblemMaxOrderByAggregateInput = {
    username?: SortOrder
    mathProblemId?: SortOrder
  }

  export type AuthorMathProblemMinOrderByAggregateInput = {
    username?: SortOrder
    mathProblemId?: SortOrder
  }

  export type MathProblemTagRelationFilter = {
    is?: MathProblemTagWhereInput
    isNot?: MathProblemTagWhereInput
  }

  export type TagMathProblemTagIdMathProblemIdCompoundUniqueInput = {
    tagId: number
    mathProblemId: string
  }

  export type TagMathProblemCountOrderByAggregateInput = {
    tagId?: SortOrder
    mathProblemId?: SortOrder
  }

  export type TagMathProblemAvgOrderByAggregateInput = {
    tagId?: SortOrder
  }

  export type TagMathProblemMaxOrderByAggregateInput = {
    tagId?: SortOrder
    mathProblemId?: SortOrder
  }

  export type TagMathProblemMinOrderByAggregateInput = {
    tagId?: SortOrder
    mathProblemId?: SortOrder
  }

  export type TagMathProblemSumOrderByAggregateInput = {
    tagId?: SortOrder
  }

  export type GroupPostCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    groupId?: SortOrder
    title?: SortOrder
  }

  export type GroupPostMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    groupId?: SortOrder
    title?: SortOrder
  }

  export type GroupPostMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    groupId?: SortOrder
    title?: SortOrder
  }
  export type JsonNullableFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase>, Exclude<keyof Required<JsonNullableFilterBase>, 'path'>>,
        Required<JsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase>, 'path'>>

  export type JsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type ChatSessionRelationFilter = {
    is?: ChatSessionWhereInput
    isNot?: ChatSessionWhereInput
  }

  export type ChatMessageCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    referenceMessage?: SortOrder
    sessionId?: SortOrder
  }

  export type ChatMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    sessionId?: SortOrder
  }

  export type ChatMessageMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    sessionId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntNullableFilter
    _min?: NestedJsonNullableFilter
    _max?: NestedJsonNullableFilter
  }

  export type GroupPostRelationFilter = {
    is?: GroupPostWhereInput
    isNot?: GroupPostWhereInput
  }

  export type GroupPostMessageCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    referenceMessage?: SortOrder
    postId?: SortOrder
  }

  export type GroupPostMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    postId?: SortOrder
  }

  export type GroupPostMessageMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    postId?: SortOrder
  }
  export type JsonFilter = 
    | PatchUndefined<
        Either<Required<JsonFilterBase>, Exclude<keyof Required<JsonFilterBase>, 'path'>>,
        Required<JsonFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase>, 'path'>>

  export type JsonFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type EnumChatSessionTypeFilter = {
    equals?: ChatSessionType
    in?: Enumerable<ChatSessionType>
    notIn?: Enumerable<ChatSessionType>
    not?: NestedEnumChatSessionTypeFilter | ChatSessionType
  }

  export type ChatSessionCountOrderByAggregateInput = {
    id?: SortOrder
    lastMessage?: SortOrder
    lastUpdate?: SortOrder
    groupId?: SortOrder
    type?: SortOrder
    usersInfo?: SortOrder
  }

  export type ChatSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    lastUpdate?: SortOrder
    groupId?: SortOrder
    type?: SortOrder
  }

  export type ChatSessionMinOrderByAggregateInput = {
    id?: SortOrder
    lastUpdate?: SortOrder
    groupId?: SortOrder
    type?: SortOrder
  }
  export type JsonWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase>, Exclude<keyof Required<JsonWithAggregatesFilterBase>, 'path'>>,
        Required<JsonWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase>, 'path'>>

  export type JsonWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntFilter
    _min?: NestedJsonFilter
    _max?: NestedJsonFilter
  }

  export type EnumChatSessionTypeWithAggregatesFilter = {
    equals?: ChatSessionType
    in?: Enumerable<ChatSessionType>
    notIn?: Enumerable<ChatSessionType>
    not?: NestedEnumChatSessionTypeWithAggregatesFilter | ChatSessionType
    _count?: NestedIntFilter
    _min?: NestedEnumChatSessionTypeFilter
    _max?: NestedEnumChatSessionTypeFilter
  }

  export type ChatSessionUserSessionIdUsernameCompoundUniqueInput = {
    sessionId: string
    username: string
  }

  export type ChatSessionUserCountOrderByAggregateInput = {
    sessionId?: SortOrder
    username?: SortOrder
    unseenCnt?: SortOrder
    joinedAt?: SortOrder
  }

  export type ChatSessionUserAvgOrderByAggregateInput = {
    unseenCnt?: SortOrder
  }

  export type ChatSessionUserMaxOrderByAggregateInput = {
    sessionId?: SortOrder
    username?: SortOrder
    unseenCnt?: SortOrder
    joinedAt?: SortOrder
  }

  export type ChatSessionUserMinOrderByAggregateInput = {
    sessionId?: SortOrder
    username?: SortOrder
    unseenCnt?: SortOrder
    joinedAt?: SortOrder
  }

  export type ChatSessionUserSumOrderByAggregateInput = {
    unseenCnt?: SortOrder
  }

  export type MathNoteMathProblemIdCreatorIdCompoundUniqueInput = {
    mathProblemId: string
    creatorId: string
  }

  export type MathNoteCountOrderByAggregateInput = {
    creatorId?: SortOrder
    content?: SortOrder
    mathProblemId?: SortOrder
    createdAt?: SortOrder
    imageLink?: SortOrder
  }

  export type MathNoteMaxOrderByAggregateInput = {
    creatorId?: SortOrder
    content?: SortOrder
    mathProblemId?: SortOrder
    createdAt?: SortOrder
    imageLink?: SortOrder
  }

  export type MathNoteMinOrderByAggregateInput = {
    creatorId?: SortOrder
    content?: SortOrder
    mathProblemId?: SortOrder
    createdAt?: SortOrder
    imageLink?: SortOrder
  }

  export type MathSolutionMathProblemIdCreatorIdCompoundUniqueInput = {
    mathProblemId: string
    creatorId: string
  }

  export type MathSolutionCountOrderByAggregateInput = {
    creatorId?: SortOrder
    content?: SortOrder
    mathProblemId?: SortOrder
    createdAt?: SortOrder
    checked?: SortOrder
    imageLink?: SortOrder
  }

  export type MathSolutionMaxOrderByAggregateInput = {
    creatorId?: SortOrder
    content?: SortOrder
    mathProblemId?: SortOrder
    createdAt?: SortOrder
    checked?: SortOrder
    imageLink?: SortOrder
  }

  export type MathSolutionMinOrderByAggregateInput = {
    creatorId?: SortOrder
    content?: SortOrder
    mathProblemId?: SortOrder
    createdAt?: SortOrder
    checked?: SortOrder
    imageLink?: SortOrder
  }

  export type EnumProblemRuleTypeFilter = {
    equals?: ProblemRuleType
    in?: Enumerable<ProblemRuleType>
    notIn?: Enumerable<ProblemRuleType>
    not?: NestedEnumProblemRuleTypeFilter | ProblemRuleType
  }

  export type ContestCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    realTimeRank?: SortOrder
    password?: SortOrder
    ruleType?: SortOrder
    startTime?: SortOrder
    duration?: SortOrder
    endTime?: SortOrder
    createTime?: SortOrder
    lastUpdateTime?: SortOrder
    visible?: SortOrder
  }

  export type ContestAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type ContestMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    realTimeRank?: SortOrder
    password?: SortOrder
    ruleType?: SortOrder
    startTime?: SortOrder
    duration?: SortOrder
    endTime?: SortOrder
    createTime?: SortOrder
    lastUpdateTime?: SortOrder
    visible?: SortOrder
  }

  export type ContestMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    realTimeRank?: SortOrder
    password?: SortOrder
    ruleType?: SortOrder
    startTime?: SortOrder
    duration?: SortOrder
    endTime?: SortOrder
    createTime?: SortOrder
    lastUpdateTime?: SortOrder
    visible?: SortOrder
  }

  export type ContestSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type EnumProblemRuleTypeWithAggregatesFilter = {
    equals?: ProblemRuleType
    in?: Enumerable<ProblemRuleType>
    notIn?: Enumerable<ProblemRuleType>
    not?: NestedEnumProblemRuleTypeWithAggregatesFilter | ProblemRuleType
    _count?: NestedIntFilter
    _min?: NestedEnumProblemRuleTypeFilter
    _max?: NestedEnumProblemRuleTypeFilter
  }

  export type EnumJudgeStatusFilter = {
    equals?: JudgeStatus
    in?: Enumerable<JudgeStatus>
    notIn?: Enumerable<JudgeStatus>
    not?: NestedEnumJudgeStatusFilter | JudgeStatus
  }

  export type SubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    contestId?: SortOrder
    problemId?: SortOrder
    createTime?: SortOrder
    username?: SortOrder
    code?: SortOrder
    result?: SortOrder
    language?: SortOrder
    shared?: SortOrder
    status?: SortOrder
    statistic_info?: SortOrder
  }

  export type SubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    contestId?: SortOrder
    problemId?: SortOrder
    createTime?: SortOrder
    username?: SortOrder
    code?: SortOrder
    result?: SortOrder
    language?: SortOrder
    shared?: SortOrder
  }

  export type SubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    contestId?: SortOrder
    problemId?: SortOrder
    createTime?: SortOrder
    username?: SortOrder
    code?: SortOrder
    result?: SortOrder
    language?: SortOrder
    shared?: SortOrder
  }

  export type EnumJudgeStatusWithAggregatesFilter = {
    equals?: JudgeStatus
    in?: Enumerable<JudgeStatus>
    notIn?: Enumerable<JudgeStatus>
    not?: NestedEnumJudgeStatusWithAggregatesFilter | JudgeStatus
    _count?: NestedIntFilter
    _min?: NestedEnumJudgeStatusFilter
    _max?: NestedEnumJudgeStatusFilter
  }

  export type ChildSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    status?: SortOrder
    token?: SortOrder
    languageId?: SortOrder
  }

  export type ChildSubmissionAvgOrderByAggregateInput = {
    languageId?: SortOrder
  }

  export type ChildSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    token?: SortOrder
    languageId?: SortOrder
  }

  export type ChildSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    token?: SortOrder
    languageId?: SortOrder
  }

  export type ChildSubmissionSumOrderByAggregateInput = {
    languageId?: SortOrder
  }

  export type LanguageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type LanguageAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LanguageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type LanguageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type LanguageSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TestcaseCountOrderByAggregateInput = {
    id?: SortOrder
    problemId?: SortOrder
    subTestNumber?: SortOrder
    description?: SortOrder
  }

  export type TestcaseAvgOrderByAggregateInput = {
    subTestNumber?: SortOrder
  }

  export type TestcaseMaxOrderByAggregateInput = {
    id?: SortOrder
    problemId?: SortOrder
    subTestNumber?: SortOrder
  }

  export type TestcaseMinOrderByAggregateInput = {
    id?: SortOrder
    problemId?: SortOrder
    subTestNumber?: SortOrder
  }

  export type TestcaseSumOrderByAggregateInput = {
    subTestNumber?: SortOrder
  }

  export type AuthorCodingProblemCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AuthorCodingProblemCreateWithoutUserInput>, Enumerable<AuthorCodingProblemUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AuthorCodingProblemCreateOrConnectWithoutUserInput>
    createMany?: AuthorCodingProblemCreateManyUserInputEnvelope
    connect?: Enumerable<AuthorCodingProblemWhereUniqueInput>
  }

  export type AuthorMathProblemCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AuthorMathProblemCreateWithoutUserInput>, Enumerable<AuthorMathProblemUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AuthorMathProblemCreateOrConnectWithoutUserInput>
    createMany?: AuthorMathProblemCreateManyUserInputEnvelope
    connect?: Enumerable<AuthorMathProblemWhereUniqueInput>
  }

  export type ThreadCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<ThreadCreateWithoutAuthorInput>, Enumerable<ThreadUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ThreadCreateOrConnectWithoutAuthorInput>
    createMany?: ThreadCreateManyAuthorInputEnvelope
    connect?: Enumerable<ThreadWhereUniqueInput>
  }

  export type CommentCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<CommentCreateWithoutCreatorInput>, Enumerable<CommentUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutCreatorInput>
    createMany?: CommentCreateManyCreatorInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type UserLikeThreadCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserLikeThreadCreateWithoutUserInput>, Enumerable<UserLikeThreadUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserLikeThreadCreateOrConnectWithoutUserInput>
    createMany?: UserLikeThreadCreateManyUserInputEnvelope
    connect?: Enumerable<UserLikeThreadWhereUniqueInput>
  }

  export type UserLikeCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserLikeCommentCreateWithoutUserInput>, Enumerable<UserLikeCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserLikeCommentCreateOrConnectWithoutUserInput>
    createMany?: UserLikeCommentCreateManyUserInputEnvelope
    connect?: Enumerable<UserLikeCommentWhereUniqueInput>
  }

  export type UserProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type MathNoteCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<MathNoteCreateWithoutCreatorInput>, Enumerable<MathNoteUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<MathNoteCreateOrConnectWithoutCreatorInput>
    createMany?: MathNoteCreateManyCreatorInputEnvelope
    connect?: Enumerable<MathNoteWhereUniqueInput>
  }

  export type MathSolutionCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<MathSolutionCreateWithoutCreatorInput>, Enumerable<MathSolutionUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<MathSolutionCreateOrConnectWithoutCreatorInput>
    createMany?: MathSolutionCreateManyCreatorInputEnvelope
    connect?: Enumerable<MathSolutionWhereUniqueInput>
  }

  export type MathProblemSetCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<MathProblemSetCreateWithoutCreatorInput>, Enumerable<MathProblemSetUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<MathProblemSetCreateOrConnectWithoutCreatorInput>
    createMany?: MathProblemSetCreateManyCreatorInputEnvelope
    connect?: Enumerable<MathProblemSetWhereUniqueInput>
  }

  export type FriendRequestCreateNestedManyWithoutSenderInput = {
    create?: XOR<Enumerable<FriendRequestCreateWithoutSenderInput>, Enumerable<FriendRequestUncheckedCreateWithoutSenderInput>>
    connectOrCreate?: Enumerable<FriendRequestCreateOrConnectWithoutSenderInput>
    createMany?: FriendRequestCreateManySenderInputEnvelope
    connect?: Enumerable<FriendRequestWhereUniqueInput>
  }

  export type FriendRequestCreateNestedManyWithoutRecieverInput = {
    create?: XOR<Enumerable<FriendRequestCreateWithoutRecieverInput>, Enumerable<FriendRequestUncheckedCreateWithoutRecieverInput>>
    connectOrCreate?: Enumerable<FriendRequestCreateOrConnectWithoutRecieverInput>
    createMany?: FriendRequestCreateManyRecieverInputEnvelope
    connect?: Enumerable<FriendRequestWhereUniqueInput>
  }

  export type GroupCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<GroupCreateWithoutCreatorInput>, Enumerable<GroupUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<GroupCreateOrConnectWithoutCreatorInput>
    createMany?: GroupCreateManyCreatorInputEnvelope
    connect?: Enumerable<GroupWhereUniqueInput>
  }

  export type UserGroupRelCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserGroupRelCreateWithoutUserInput>, Enumerable<UserGroupRelUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserGroupRelCreateOrConnectWithoutUserInput>
    createMany?: UserGroupRelCreateManyUserInputEnvelope
    connect?: Enumerable<UserGroupRelWhereUniqueInput>
  }

  export type GroupPostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<GroupPostCreateWithoutAuthorInput>, Enumerable<GroupPostUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<GroupPostCreateOrConnectWithoutAuthorInput>
    createMany?: GroupPostCreateManyAuthorInputEnvelope
    connect?: Enumerable<GroupPostWhereUniqueInput>
  }

  export type ChatMessageCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<ChatMessageCreateWithoutAuthorInput>, Enumerable<ChatMessageUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ChatMessageCreateOrConnectWithoutAuthorInput>
    createMany?: ChatMessageCreateManyAuthorInputEnvelope
    connect?: Enumerable<ChatMessageWhereUniqueInput>
  }

  export type ChatSessionUserCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ChatSessionUserCreateWithoutUserInput>, Enumerable<ChatSessionUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ChatSessionUserCreateOrConnectWithoutUserInput>
    createMany?: ChatSessionUserCreateManyUserInputEnvelope
    connect?: Enumerable<ChatSessionUserWhereUniqueInput>
  }

  export type GroupPostMessageCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<GroupPostMessageCreateWithoutAuthorInput>, Enumerable<GroupPostMessageUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<GroupPostMessageCreateOrConnectWithoutAuthorInput>
    createMany?: GroupPostMessageCreateManyAuthorInputEnvelope
    connect?: Enumerable<GroupPostMessageWhereUniqueInput>
  }

  export type AuthorCodingProblemUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AuthorCodingProblemCreateWithoutUserInput>, Enumerable<AuthorCodingProblemUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AuthorCodingProblemCreateOrConnectWithoutUserInput>
    createMany?: AuthorCodingProblemCreateManyUserInputEnvelope
    connect?: Enumerable<AuthorCodingProblemWhereUniqueInput>
  }

  export type AuthorMathProblemUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AuthorMathProblemCreateWithoutUserInput>, Enumerable<AuthorMathProblemUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AuthorMathProblemCreateOrConnectWithoutUserInput>
    createMany?: AuthorMathProblemCreateManyUserInputEnvelope
    connect?: Enumerable<AuthorMathProblemWhereUniqueInput>
  }

  export type ThreadUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<ThreadCreateWithoutAuthorInput>, Enumerable<ThreadUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ThreadCreateOrConnectWithoutAuthorInput>
    createMany?: ThreadCreateManyAuthorInputEnvelope
    connect?: Enumerable<ThreadWhereUniqueInput>
  }

  export type CommentUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<CommentCreateWithoutCreatorInput>, Enumerable<CommentUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutCreatorInput>
    createMany?: CommentCreateManyCreatorInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type UserLikeThreadUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserLikeThreadCreateWithoutUserInput>, Enumerable<UserLikeThreadUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserLikeThreadCreateOrConnectWithoutUserInput>
    createMany?: UserLikeThreadCreateManyUserInputEnvelope
    connect?: Enumerable<UserLikeThreadWhereUniqueInput>
  }

  export type UserLikeCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserLikeCommentCreateWithoutUserInput>, Enumerable<UserLikeCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserLikeCommentCreateOrConnectWithoutUserInput>
    createMany?: UserLikeCommentCreateManyUserInputEnvelope
    connect?: Enumerable<UserLikeCommentWhereUniqueInput>
  }

  export type UserProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type MathNoteUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<MathNoteCreateWithoutCreatorInput>, Enumerable<MathNoteUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<MathNoteCreateOrConnectWithoutCreatorInput>
    createMany?: MathNoteCreateManyCreatorInputEnvelope
    connect?: Enumerable<MathNoteWhereUniqueInput>
  }

  export type MathSolutionUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<MathSolutionCreateWithoutCreatorInput>, Enumerable<MathSolutionUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<MathSolutionCreateOrConnectWithoutCreatorInput>
    createMany?: MathSolutionCreateManyCreatorInputEnvelope
    connect?: Enumerable<MathSolutionWhereUniqueInput>
  }

  export type MathProblemSetUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<MathProblemSetCreateWithoutCreatorInput>, Enumerable<MathProblemSetUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<MathProblemSetCreateOrConnectWithoutCreatorInput>
    createMany?: MathProblemSetCreateManyCreatorInputEnvelope
    connect?: Enumerable<MathProblemSetWhereUniqueInput>
  }

  export type FriendRequestUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<Enumerable<FriendRequestCreateWithoutSenderInput>, Enumerable<FriendRequestUncheckedCreateWithoutSenderInput>>
    connectOrCreate?: Enumerable<FriendRequestCreateOrConnectWithoutSenderInput>
    createMany?: FriendRequestCreateManySenderInputEnvelope
    connect?: Enumerable<FriendRequestWhereUniqueInput>
  }

  export type FriendRequestUncheckedCreateNestedManyWithoutRecieverInput = {
    create?: XOR<Enumerable<FriendRequestCreateWithoutRecieverInput>, Enumerable<FriendRequestUncheckedCreateWithoutRecieverInput>>
    connectOrCreate?: Enumerable<FriendRequestCreateOrConnectWithoutRecieverInput>
    createMany?: FriendRequestCreateManyRecieverInputEnvelope
    connect?: Enumerable<FriendRequestWhereUniqueInput>
  }

  export type GroupUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<GroupCreateWithoutCreatorInput>, Enumerable<GroupUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<GroupCreateOrConnectWithoutCreatorInput>
    createMany?: GroupCreateManyCreatorInputEnvelope
    connect?: Enumerable<GroupWhereUniqueInput>
  }

  export type UserGroupRelUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserGroupRelCreateWithoutUserInput>, Enumerable<UserGroupRelUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserGroupRelCreateOrConnectWithoutUserInput>
    createMany?: UserGroupRelCreateManyUserInputEnvelope
    connect?: Enumerable<UserGroupRelWhereUniqueInput>
  }

  export type GroupPostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<GroupPostCreateWithoutAuthorInput>, Enumerable<GroupPostUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<GroupPostCreateOrConnectWithoutAuthorInput>
    createMany?: GroupPostCreateManyAuthorInputEnvelope
    connect?: Enumerable<GroupPostWhereUniqueInput>
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<ChatMessageCreateWithoutAuthorInput>, Enumerable<ChatMessageUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ChatMessageCreateOrConnectWithoutAuthorInput>
    createMany?: ChatMessageCreateManyAuthorInputEnvelope
    connect?: Enumerable<ChatMessageWhereUniqueInput>
  }

  export type ChatSessionUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ChatSessionUserCreateWithoutUserInput>, Enumerable<ChatSessionUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ChatSessionUserCreateOrConnectWithoutUserInput>
    createMany?: ChatSessionUserCreateManyUserInputEnvelope
    connect?: Enumerable<ChatSessionUserWhereUniqueInput>
  }

  export type GroupPostMessageUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<GroupPostMessageCreateWithoutAuthorInput>, Enumerable<GroupPostMessageUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<GroupPostMessageCreateOrConnectWithoutAuthorInput>
    createMany?: GroupPostMessageCreateManyAuthorInputEnvelope
    connect?: Enumerable<GroupPostMessageWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type Enumadmin_typeFieldUpdateOperationsInput = {
    set?: admin_type
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type AuthorCodingProblemUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AuthorCodingProblemCreateWithoutUserInput>, Enumerable<AuthorCodingProblemUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AuthorCodingProblemCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AuthorCodingProblemUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AuthorCodingProblemCreateManyUserInputEnvelope
    set?: Enumerable<AuthorCodingProblemWhereUniqueInput>
    disconnect?: Enumerable<AuthorCodingProblemWhereUniqueInput>
    delete?: Enumerable<AuthorCodingProblemWhereUniqueInput>
    connect?: Enumerable<AuthorCodingProblemWhereUniqueInput>
    update?: Enumerable<AuthorCodingProblemUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AuthorCodingProblemUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AuthorCodingProblemScalarWhereInput>
  }

  export type AuthorMathProblemUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AuthorMathProblemCreateWithoutUserInput>, Enumerable<AuthorMathProblemUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AuthorMathProblemCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AuthorMathProblemUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AuthorMathProblemCreateManyUserInputEnvelope
    set?: Enumerable<AuthorMathProblemWhereUniqueInput>
    disconnect?: Enumerable<AuthorMathProblemWhereUniqueInput>
    delete?: Enumerable<AuthorMathProblemWhereUniqueInput>
    connect?: Enumerable<AuthorMathProblemWhereUniqueInput>
    update?: Enumerable<AuthorMathProblemUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AuthorMathProblemUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AuthorMathProblemScalarWhereInput>
  }

  export type ThreadUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<ThreadCreateWithoutAuthorInput>, Enumerable<ThreadUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ThreadCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<ThreadUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: ThreadCreateManyAuthorInputEnvelope
    set?: Enumerable<ThreadWhereUniqueInput>
    disconnect?: Enumerable<ThreadWhereUniqueInput>
    delete?: Enumerable<ThreadWhereUniqueInput>
    connect?: Enumerable<ThreadWhereUniqueInput>
    update?: Enumerable<ThreadUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<ThreadUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<ThreadScalarWhereInput>
  }

  export type CommentUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<CommentCreateWithoutCreatorInput>, Enumerable<CommentUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: CommentCreateManyCreatorInputEnvelope
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    connect?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type UserLikeThreadUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserLikeThreadCreateWithoutUserInput>, Enumerable<UserLikeThreadUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserLikeThreadCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserLikeThreadUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserLikeThreadCreateManyUserInputEnvelope
    set?: Enumerable<UserLikeThreadWhereUniqueInput>
    disconnect?: Enumerable<UserLikeThreadWhereUniqueInput>
    delete?: Enumerable<UserLikeThreadWhereUniqueInput>
    connect?: Enumerable<UserLikeThreadWhereUniqueInput>
    update?: Enumerable<UserLikeThreadUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserLikeThreadUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserLikeThreadScalarWhereInput>
  }

  export type UserLikeCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserLikeCommentCreateWithoutUserInput>, Enumerable<UserLikeCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserLikeCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserLikeCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserLikeCommentCreateManyUserInputEnvelope
    set?: Enumerable<UserLikeCommentWhereUniqueInput>
    disconnect?: Enumerable<UserLikeCommentWhereUniqueInput>
    delete?: Enumerable<UserLikeCommentWhereUniqueInput>
    connect?: Enumerable<UserLikeCommentWhereUniqueInput>
    update?: Enumerable<UserLikeCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserLikeCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserLikeCommentScalarWhereInput>
  }

  export type UserProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type MathNoteUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<MathNoteCreateWithoutCreatorInput>, Enumerable<MathNoteUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<MathNoteCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<MathNoteUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: MathNoteCreateManyCreatorInputEnvelope
    set?: Enumerable<MathNoteWhereUniqueInput>
    disconnect?: Enumerable<MathNoteWhereUniqueInput>
    delete?: Enumerable<MathNoteWhereUniqueInput>
    connect?: Enumerable<MathNoteWhereUniqueInput>
    update?: Enumerable<MathNoteUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<MathNoteUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<MathNoteScalarWhereInput>
  }

  export type MathSolutionUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<MathSolutionCreateWithoutCreatorInput>, Enumerable<MathSolutionUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<MathSolutionCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<MathSolutionUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: MathSolutionCreateManyCreatorInputEnvelope
    set?: Enumerable<MathSolutionWhereUniqueInput>
    disconnect?: Enumerable<MathSolutionWhereUniqueInput>
    delete?: Enumerable<MathSolutionWhereUniqueInput>
    connect?: Enumerable<MathSolutionWhereUniqueInput>
    update?: Enumerable<MathSolutionUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<MathSolutionUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<MathSolutionScalarWhereInput>
  }

  export type MathProblemSetUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<MathProblemSetCreateWithoutCreatorInput>, Enumerable<MathProblemSetUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<MathProblemSetCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<MathProblemSetUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: MathProblemSetCreateManyCreatorInputEnvelope
    set?: Enumerable<MathProblemSetWhereUniqueInput>
    disconnect?: Enumerable<MathProblemSetWhereUniqueInput>
    delete?: Enumerable<MathProblemSetWhereUniqueInput>
    connect?: Enumerable<MathProblemSetWhereUniqueInput>
    update?: Enumerable<MathProblemSetUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<MathProblemSetUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<MathProblemSetScalarWhereInput>
  }

  export type FriendRequestUpdateManyWithoutSenderNestedInput = {
    create?: XOR<Enumerable<FriendRequestCreateWithoutSenderInput>, Enumerable<FriendRequestUncheckedCreateWithoutSenderInput>>
    connectOrCreate?: Enumerable<FriendRequestCreateOrConnectWithoutSenderInput>
    upsert?: Enumerable<FriendRequestUpsertWithWhereUniqueWithoutSenderInput>
    createMany?: FriendRequestCreateManySenderInputEnvelope
    set?: Enumerable<FriendRequestWhereUniqueInput>
    disconnect?: Enumerable<FriendRequestWhereUniqueInput>
    delete?: Enumerable<FriendRequestWhereUniqueInput>
    connect?: Enumerable<FriendRequestWhereUniqueInput>
    update?: Enumerable<FriendRequestUpdateWithWhereUniqueWithoutSenderInput>
    updateMany?: Enumerable<FriendRequestUpdateManyWithWhereWithoutSenderInput>
    deleteMany?: Enumerable<FriendRequestScalarWhereInput>
  }

  export type FriendRequestUpdateManyWithoutRecieverNestedInput = {
    create?: XOR<Enumerable<FriendRequestCreateWithoutRecieverInput>, Enumerable<FriendRequestUncheckedCreateWithoutRecieverInput>>
    connectOrCreate?: Enumerable<FriendRequestCreateOrConnectWithoutRecieverInput>
    upsert?: Enumerable<FriendRequestUpsertWithWhereUniqueWithoutRecieverInput>
    createMany?: FriendRequestCreateManyRecieverInputEnvelope
    set?: Enumerable<FriendRequestWhereUniqueInput>
    disconnect?: Enumerable<FriendRequestWhereUniqueInput>
    delete?: Enumerable<FriendRequestWhereUniqueInput>
    connect?: Enumerable<FriendRequestWhereUniqueInput>
    update?: Enumerable<FriendRequestUpdateWithWhereUniqueWithoutRecieverInput>
    updateMany?: Enumerable<FriendRequestUpdateManyWithWhereWithoutRecieverInput>
    deleteMany?: Enumerable<FriendRequestScalarWhereInput>
  }

  export type GroupUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<GroupCreateWithoutCreatorInput>, Enumerable<GroupUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<GroupCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<GroupUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: GroupCreateManyCreatorInputEnvelope
    set?: Enumerable<GroupWhereUniqueInput>
    disconnect?: Enumerable<GroupWhereUniqueInput>
    delete?: Enumerable<GroupWhereUniqueInput>
    connect?: Enumerable<GroupWhereUniqueInput>
    update?: Enumerable<GroupUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<GroupUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<GroupScalarWhereInput>
  }

  export type UserGroupRelUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserGroupRelCreateWithoutUserInput>, Enumerable<UserGroupRelUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserGroupRelCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserGroupRelUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserGroupRelCreateManyUserInputEnvelope
    set?: Enumerable<UserGroupRelWhereUniqueInput>
    disconnect?: Enumerable<UserGroupRelWhereUniqueInput>
    delete?: Enumerable<UserGroupRelWhereUniqueInput>
    connect?: Enumerable<UserGroupRelWhereUniqueInput>
    update?: Enumerable<UserGroupRelUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserGroupRelUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserGroupRelScalarWhereInput>
  }

  export type GroupPostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<GroupPostCreateWithoutAuthorInput>, Enumerable<GroupPostUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<GroupPostCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<GroupPostUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: GroupPostCreateManyAuthorInputEnvelope
    set?: Enumerable<GroupPostWhereUniqueInput>
    disconnect?: Enumerable<GroupPostWhereUniqueInput>
    delete?: Enumerable<GroupPostWhereUniqueInput>
    connect?: Enumerable<GroupPostWhereUniqueInput>
    update?: Enumerable<GroupPostUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<GroupPostUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<GroupPostScalarWhereInput>
  }

  export type ChatMessageUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<ChatMessageCreateWithoutAuthorInput>, Enumerable<ChatMessageUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ChatMessageCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<ChatMessageUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: ChatMessageCreateManyAuthorInputEnvelope
    set?: Enumerable<ChatMessageWhereUniqueInput>
    disconnect?: Enumerable<ChatMessageWhereUniqueInput>
    delete?: Enumerable<ChatMessageWhereUniqueInput>
    connect?: Enumerable<ChatMessageWhereUniqueInput>
    update?: Enumerable<ChatMessageUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<ChatMessageUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<ChatMessageScalarWhereInput>
  }

  export type ChatSessionUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ChatSessionUserCreateWithoutUserInput>, Enumerable<ChatSessionUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ChatSessionUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ChatSessionUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ChatSessionUserCreateManyUserInputEnvelope
    set?: Enumerable<ChatSessionUserWhereUniqueInput>
    disconnect?: Enumerable<ChatSessionUserWhereUniqueInput>
    delete?: Enumerable<ChatSessionUserWhereUniqueInput>
    connect?: Enumerable<ChatSessionUserWhereUniqueInput>
    update?: Enumerable<ChatSessionUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ChatSessionUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ChatSessionUserScalarWhereInput>
  }

  export type GroupPostMessageUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<GroupPostMessageCreateWithoutAuthorInput>, Enumerable<GroupPostMessageUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<GroupPostMessageCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<GroupPostMessageUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: GroupPostMessageCreateManyAuthorInputEnvelope
    set?: Enumerable<GroupPostMessageWhereUniqueInput>
    disconnect?: Enumerable<GroupPostMessageWhereUniqueInput>
    delete?: Enumerable<GroupPostMessageWhereUniqueInput>
    connect?: Enumerable<GroupPostMessageWhereUniqueInput>
    update?: Enumerable<GroupPostMessageUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<GroupPostMessageUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<GroupPostMessageScalarWhereInput>
  }

  export type AuthorCodingProblemUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AuthorCodingProblemCreateWithoutUserInput>, Enumerable<AuthorCodingProblemUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AuthorCodingProblemCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AuthorCodingProblemUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AuthorCodingProblemCreateManyUserInputEnvelope
    set?: Enumerable<AuthorCodingProblemWhereUniqueInput>
    disconnect?: Enumerable<AuthorCodingProblemWhereUniqueInput>
    delete?: Enumerable<AuthorCodingProblemWhereUniqueInput>
    connect?: Enumerable<AuthorCodingProblemWhereUniqueInput>
    update?: Enumerable<AuthorCodingProblemUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AuthorCodingProblemUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AuthorCodingProblemScalarWhereInput>
  }

  export type AuthorMathProblemUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AuthorMathProblemCreateWithoutUserInput>, Enumerable<AuthorMathProblemUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AuthorMathProblemCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AuthorMathProblemUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AuthorMathProblemCreateManyUserInputEnvelope
    set?: Enumerable<AuthorMathProblemWhereUniqueInput>
    disconnect?: Enumerable<AuthorMathProblemWhereUniqueInput>
    delete?: Enumerable<AuthorMathProblemWhereUniqueInput>
    connect?: Enumerable<AuthorMathProblemWhereUniqueInput>
    update?: Enumerable<AuthorMathProblemUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AuthorMathProblemUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AuthorMathProblemScalarWhereInput>
  }

  export type ThreadUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<ThreadCreateWithoutAuthorInput>, Enumerable<ThreadUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ThreadCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<ThreadUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: ThreadCreateManyAuthorInputEnvelope
    set?: Enumerable<ThreadWhereUniqueInput>
    disconnect?: Enumerable<ThreadWhereUniqueInput>
    delete?: Enumerable<ThreadWhereUniqueInput>
    connect?: Enumerable<ThreadWhereUniqueInput>
    update?: Enumerable<ThreadUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<ThreadUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<ThreadScalarWhereInput>
  }

  export type CommentUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<CommentCreateWithoutCreatorInput>, Enumerable<CommentUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: CommentCreateManyCreatorInputEnvelope
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    connect?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type UserLikeThreadUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserLikeThreadCreateWithoutUserInput>, Enumerable<UserLikeThreadUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserLikeThreadCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserLikeThreadUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserLikeThreadCreateManyUserInputEnvelope
    set?: Enumerable<UserLikeThreadWhereUniqueInput>
    disconnect?: Enumerable<UserLikeThreadWhereUniqueInput>
    delete?: Enumerable<UserLikeThreadWhereUniqueInput>
    connect?: Enumerable<UserLikeThreadWhereUniqueInput>
    update?: Enumerable<UserLikeThreadUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserLikeThreadUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserLikeThreadScalarWhereInput>
  }

  export type UserLikeCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserLikeCommentCreateWithoutUserInput>, Enumerable<UserLikeCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserLikeCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserLikeCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserLikeCommentCreateManyUserInputEnvelope
    set?: Enumerable<UserLikeCommentWhereUniqueInput>
    disconnect?: Enumerable<UserLikeCommentWhereUniqueInput>
    delete?: Enumerable<UserLikeCommentWhereUniqueInput>
    connect?: Enumerable<UserLikeCommentWhereUniqueInput>
    update?: Enumerable<UserLikeCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserLikeCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserLikeCommentScalarWhereInput>
  }

  export type UserProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type MathNoteUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<MathNoteCreateWithoutCreatorInput>, Enumerable<MathNoteUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<MathNoteCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<MathNoteUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: MathNoteCreateManyCreatorInputEnvelope
    set?: Enumerable<MathNoteWhereUniqueInput>
    disconnect?: Enumerable<MathNoteWhereUniqueInput>
    delete?: Enumerable<MathNoteWhereUniqueInput>
    connect?: Enumerable<MathNoteWhereUniqueInput>
    update?: Enumerable<MathNoteUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<MathNoteUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<MathNoteScalarWhereInput>
  }

  export type MathSolutionUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<MathSolutionCreateWithoutCreatorInput>, Enumerable<MathSolutionUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<MathSolutionCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<MathSolutionUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: MathSolutionCreateManyCreatorInputEnvelope
    set?: Enumerable<MathSolutionWhereUniqueInput>
    disconnect?: Enumerable<MathSolutionWhereUniqueInput>
    delete?: Enumerable<MathSolutionWhereUniqueInput>
    connect?: Enumerable<MathSolutionWhereUniqueInput>
    update?: Enumerable<MathSolutionUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<MathSolutionUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<MathSolutionScalarWhereInput>
  }

  export type MathProblemSetUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<MathProblemSetCreateWithoutCreatorInput>, Enumerable<MathProblemSetUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<MathProblemSetCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<MathProblemSetUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: MathProblemSetCreateManyCreatorInputEnvelope
    set?: Enumerable<MathProblemSetWhereUniqueInput>
    disconnect?: Enumerable<MathProblemSetWhereUniqueInput>
    delete?: Enumerable<MathProblemSetWhereUniqueInput>
    connect?: Enumerable<MathProblemSetWhereUniqueInput>
    update?: Enumerable<MathProblemSetUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<MathProblemSetUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<MathProblemSetScalarWhereInput>
  }

  export type FriendRequestUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<Enumerable<FriendRequestCreateWithoutSenderInput>, Enumerable<FriendRequestUncheckedCreateWithoutSenderInput>>
    connectOrCreate?: Enumerable<FriendRequestCreateOrConnectWithoutSenderInput>
    upsert?: Enumerable<FriendRequestUpsertWithWhereUniqueWithoutSenderInput>
    createMany?: FriendRequestCreateManySenderInputEnvelope
    set?: Enumerable<FriendRequestWhereUniqueInput>
    disconnect?: Enumerable<FriendRequestWhereUniqueInput>
    delete?: Enumerable<FriendRequestWhereUniqueInput>
    connect?: Enumerable<FriendRequestWhereUniqueInput>
    update?: Enumerable<FriendRequestUpdateWithWhereUniqueWithoutSenderInput>
    updateMany?: Enumerable<FriendRequestUpdateManyWithWhereWithoutSenderInput>
    deleteMany?: Enumerable<FriendRequestScalarWhereInput>
  }

  export type FriendRequestUncheckedUpdateManyWithoutRecieverNestedInput = {
    create?: XOR<Enumerable<FriendRequestCreateWithoutRecieverInput>, Enumerable<FriendRequestUncheckedCreateWithoutRecieverInput>>
    connectOrCreate?: Enumerable<FriendRequestCreateOrConnectWithoutRecieverInput>
    upsert?: Enumerable<FriendRequestUpsertWithWhereUniqueWithoutRecieverInput>
    createMany?: FriendRequestCreateManyRecieverInputEnvelope
    set?: Enumerable<FriendRequestWhereUniqueInput>
    disconnect?: Enumerable<FriendRequestWhereUniqueInput>
    delete?: Enumerable<FriendRequestWhereUniqueInput>
    connect?: Enumerable<FriendRequestWhereUniqueInput>
    update?: Enumerable<FriendRequestUpdateWithWhereUniqueWithoutRecieverInput>
    updateMany?: Enumerable<FriendRequestUpdateManyWithWhereWithoutRecieverInput>
    deleteMany?: Enumerable<FriendRequestScalarWhereInput>
  }

  export type GroupUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<GroupCreateWithoutCreatorInput>, Enumerable<GroupUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<GroupCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<GroupUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: GroupCreateManyCreatorInputEnvelope
    set?: Enumerable<GroupWhereUniqueInput>
    disconnect?: Enumerable<GroupWhereUniqueInput>
    delete?: Enumerable<GroupWhereUniqueInput>
    connect?: Enumerable<GroupWhereUniqueInput>
    update?: Enumerable<GroupUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<GroupUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<GroupScalarWhereInput>
  }

  export type UserGroupRelUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserGroupRelCreateWithoutUserInput>, Enumerable<UserGroupRelUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserGroupRelCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserGroupRelUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserGroupRelCreateManyUserInputEnvelope
    set?: Enumerable<UserGroupRelWhereUniqueInput>
    disconnect?: Enumerable<UserGroupRelWhereUniqueInput>
    delete?: Enumerable<UserGroupRelWhereUniqueInput>
    connect?: Enumerable<UserGroupRelWhereUniqueInput>
    update?: Enumerable<UserGroupRelUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserGroupRelUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserGroupRelScalarWhereInput>
  }

  export type GroupPostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<GroupPostCreateWithoutAuthorInput>, Enumerable<GroupPostUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<GroupPostCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<GroupPostUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: GroupPostCreateManyAuthorInputEnvelope
    set?: Enumerable<GroupPostWhereUniqueInput>
    disconnect?: Enumerable<GroupPostWhereUniqueInput>
    delete?: Enumerable<GroupPostWhereUniqueInput>
    connect?: Enumerable<GroupPostWhereUniqueInput>
    update?: Enumerable<GroupPostUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<GroupPostUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<GroupPostScalarWhereInput>
  }

  export type ChatMessageUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<ChatMessageCreateWithoutAuthorInput>, Enumerable<ChatMessageUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ChatMessageCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<ChatMessageUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: ChatMessageCreateManyAuthorInputEnvelope
    set?: Enumerable<ChatMessageWhereUniqueInput>
    disconnect?: Enumerable<ChatMessageWhereUniqueInput>
    delete?: Enumerable<ChatMessageWhereUniqueInput>
    connect?: Enumerable<ChatMessageWhereUniqueInput>
    update?: Enumerable<ChatMessageUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<ChatMessageUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<ChatMessageScalarWhereInput>
  }

  export type ChatSessionUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ChatSessionUserCreateWithoutUserInput>, Enumerable<ChatSessionUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ChatSessionUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ChatSessionUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ChatSessionUserCreateManyUserInputEnvelope
    set?: Enumerable<ChatSessionUserWhereUniqueInput>
    disconnect?: Enumerable<ChatSessionUserWhereUniqueInput>
    delete?: Enumerable<ChatSessionUserWhereUniqueInput>
    connect?: Enumerable<ChatSessionUserWhereUniqueInput>
    update?: Enumerable<ChatSessionUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ChatSessionUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ChatSessionUserScalarWhereInput>
  }

  export type GroupPostMessageUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<GroupPostMessageCreateWithoutAuthorInput>, Enumerable<GroupPostMessageUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<GroupPostMessageCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<GroupPostMessageUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: GroupPostMessageCreateManyAuthorInputEnvelope
    set?: Enumerable<GroupPostMessageWhereUniqueInput>
    disconnect?: Enumerable<GroupPostMessageWhereUniqueInput>
    delete?: Enumerable<GroupPostMessageWhereUniqueInput>
    connect?: Enumerable<GroupPostMessageWhereUniqueInput>
    update?: Enumerable<GroupPostMessageUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<GroupPostMessageUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<GroupPostMessageScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutMyFriendReqsInput = {
    create?: XOR<UserCreateWithoutMyFriendReqsInput, UserUncheckedCreateWithoutMyFriendReqsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMyFriendReqsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOtherFriendReqsInput = {
    create?: XOR<UserCreateWithoutOtherFriendReqsInput, UserUncheckedCreateWithoutOtherFriendReqsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtherFriendReqsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMyFriendReqsNestedInput = {
    create?: XOR<UserCreateWithoutMyFriendReqsInput, UserUncheckedCreateWithoutMyFriendReqsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMyFriendReqsInput
    upsert?: UserUpsertWithoutMyFriendReqsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutMyFriendReqsInput, UserUncheckedUpdateWithoutMyFriendReqsInput>
  }

  export type UserUpdateOneRequiredWithoutOtherFriendReqsNestedInput = {
    create?: XOR<UserCreateWithoutOtherFriendReqsInput, UserUncheckedCreateWithoutOtherFriendReqsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtherFriendReqsInput
    upsert?: UserUpsertWithoutOtherFriendReqsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutOtherFriendReqsInput, UserUncheckedUpdateWithoutOtherFriendReqsInput>
  }

  export type UserCreateNestedOneWithoutCreatedGroupInput = {
    create?: XOR<UserCreateWithoutCreatedGroupInput, UserUncheckedCreateWithoutCreatedGroupInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedGroupInput
    connect?: UserWhereUniqueInput
  }

  export type UserGroupRelCreateNestedManyWithoutGroupInput = {
    create?: XOR<Enumerable<UserGroupRelCreateWithoutGroupInput>, Enumerable<UserGroupRelUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<UserGroupRelCreateOrConnectWithoutGroupInput>
    createMany?: UserGroupRelCreateManyGroupInputEnvelope
    connect?: Enumerable<UserGroupRelWhereUniqueInput>
  }

  export type GroupPostCreateNestedManyWithoutGroupInput = {
    create?: XOR<Enumerable<GroupPostCreateWithoutGroupInput>, Enumerable<GroupPostUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<GroupPostCreateOrConnectWithoutGroupInput>
    createMany?: GroupPostCreateManyGroupInputEnvelope
    connect?: Enumerable<GroupPostWhereUniqueInput>
  }

  export type UserGroupRelUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<Enumerable<UserGroupRelCreateWithoutGroupInput>, Enumerable<UserGroupRelUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<UserGroupRelCreateOrConnectWithoutGroupInput>
    createMany?: UserGroupRelCreateManyGroupInputEnvelope
    connect?: Enumerable<UserGroupRelWhereUniqueInput>
  }

  export type GroupPostUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<Enumerable<GroupPostCreateWithoutGroupInput>, Enumerable<GroupPostUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<GroupPostCreateOrConnectWithoutGroupInput>
    createMany?: GroupPostCreateManyGroupInputEnvelope
    connect?: Enumerable<GroupPostWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedGroupNestedInput = {
    create?: XOR<UserCreateWithoutCreatedGroupInput, UserUncheckedCreateWithoutCreatedGroupInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedGroupInput
    upsert?: UserUpsertWithoutCreatedGroupInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCreatedGroupInput, UserUncheckedUpdateWithoutCreatedGroupInput>
  }

  export type UserGroupRelUpdateManyWithoutGroupNestedInput = {
    create?: XOR<Enumerable<UserGroupRelCreateWithoutGroupInput>, Enumerable<UserGroupRelUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<UserGroupRelCreateOrConnectWithoutGroupInput>
    upsert?: Enumerable<UserGroupRelUpsertWithWhereUniqueWithoutGroupInput>
    createMany?: UserGroupRelCreateManyGroupInputEnvelope
    set?: Enumerable<UserGroupRelWhereUniqueInput>
    disconnect?: Enumerable<UserGroupRelWhereUniqueInput>
    delete?: Enumerable<UserGroupRelWhereUniqueInput>
    connect?: Enumerable<UserGroupRelWhereUniqueInput>
    update?: Enumerable<UserGroupRelUpdateWithWhereUniqueWithoutGroupInput>
    updateMany?: Enumerable<UserGroupRelUpdateManyWithWhereWithoutGroupInput>
    deleteMany?: Enumerable<UserGroupRelScalarWhereInput>
  }

  export type GroupPostUpdateManyWithoutGroupNestedInput = {
    create?: XOR<Enumerable<GroupPostCreateWithoutGroupInput>, Enumerable<GroupPostUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<GroupPostCreateOrConnectWithoutGroupInput>
    upsert?: Enumerable<GroupPostUpsertWithWhereUniqueWithoutGroupInput>
    createMany?: GroupPostCreateManyGroupInputEnvelope
    set?: Enumerable<GroupPostWhereUniqueInput>
    disconnect?: Enumerable<GroupPostWhereUniqueInput>
    delete?: Enumerable<GroupPostWhereUniqueInput>
    connect?: Enumerable<GroupPostWhereUniqueInput>
    update?: Enumerable<GroupPostUpdateWithWhereUniqueWithoutGroupInput>
    updateMany?: Enumerable<GroupPostUpdateManyWithWhereWithoutGroupInput>
    deleteMany?: Enumerable<GroupPostScalarWhereInput>
  }

  export type UserGroupRelUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<Enumerable<UserGroupRelCreateWithoutGroupInput>, Enumerable<UserGroupRelUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<UserGroupRelCreateOrConnectWithoutGroupInput>
    upsert?: Enumerable<UserGroupRelUpsertWithWhereUniqueWithoutGroupInput>
    createMany?: UserGroupRelCreateManyGroupInputEnvelope
    set?: Enumerable<UserGroupRelWhereUniqueInput>
    disconnect?: Enumerable<UserGroupRelWhereUniqueInput>
    delete?: Enumerable<UserGroupRelWhereUniqueInput>
    connect?: Enumerable<UserGroupRelWhereUniqueInput>
    update?: Enumerable<UserGroupRelUpdateWithWhereUniqueWithoutGroupInput>
    updateMany?: Enumerable<UserGroupRelUpdateManyWithWhereWithoutGroupInput>
    deleteMany?: Enumerable<UserGroupRelScalarWhereInput>
  }

  export type GroupPostUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<Enumerable<GroupPostCreateWithoutGroupInput>, Enumerable<GroupPostUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<GroupPostCreateOrConnectWithoutGroupInput>
    upsert?: Enumerable<GroupPostUpsertWithWhereUniqueWithoutGroupInput>
    createMany?: GroupPostCreateManyGroupInputEnvelope
    set?: Enumerable<GroupPostWhereUniqueInput>
    disconnect?: Enumerable<GroupPostWhereUniqueInput>
    delete?: Enumerable<GroupPostWhereUniqueInput>
    connect?: Enumerable<GroupPostWhereUniqueInput>
    update?: Enumerable<GroupPostUpdateWithWhereUniqueWithoutGroupInput>
    updateMany?: Enumerable<GroupPostUpdateManyWithWhereWithoutGroupInput>
    deleteMany?: Enumerable<GroupPostScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutJoinedGroupsInput = {
    create?: XOR<UserCreateWithoutJoinedGroupsInput, UserUncheckedCreateWithoutJoinedGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutJoinedGroupsInput
    connect?: UserWhereUniqueInput
  }

  export type GroupCreateNestedOneWithoutUsersInput = {
    create?: XOR<GroupCreateWithoutUsersInput, GroupUncheckedCreateWithoutUsersInput>
    connectOrCreate?: GroupCreateOrConnectWithoutUsersInput
    connect?: GroupWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutJoinedGroupsNestedInput = {
    create?: XOR<UserCreateWithoutJoinedGroupsInput, UserUncheckedCreateWithoutJoinedGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutJoinedGroupsInput
    upsert?: UserUpsertWithoutJoinedGroupsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutJoinedGroupsInput, UserUncheckedUpdateWithoutJoinedGroupsInput>
  }

  export type GroupUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<GroupCreateWithoutUsersInput, GroupUncheckedCreateWithoutUsersInput>
    connectOrCreate?: GroupCreateOrConnectWithoutUsersInput
    upsert?: GroupUpsertWithoutUsersInput
    connect?: GroupWhereUniqueInput
    update?: XOR<GroupUpdateWithoutUsersInput, GroupUncheckedUpdateWithoutUsersInput>
  }

  export type UserCreateNestedOneWithoutUserProfileInput = {
    create?: XOR<UserCreateWithoutUserProfileInput, UserUncheckedCreateWithoutUserProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserProfileInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutUserProfileNestedInput = {
    create?: XOR<UserCreateWithoutUserProfileInput, UserUncheckedCreateWithoutUserProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserProfileInput
    upsert?: UserUpsertWithoutUserProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserProfileInput, UserUncheckedUpdateWithoutUserProfileInput>
  }

  export type CodingProblemCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<CodingProblemCreateWithoutCategoryInput>, Enumerable<CodingProblemUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<CodingProblemCreateOrConnectWithoutCategoryInput>
    createMany?: CodingProblemCreateManyCategoryInputEnvelope
    connect?: Enumerable<CodingProblemWhereUniqueInput>
  }

  export type CodingProblemUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<CodingProblemCreateWithoutCategoryInput>, Enumerable<CodingProblemUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<CodingProblemCreateOrConnectWithoutCategoryInput>
    createMany?: CodingProblemCreateManyCategoryInputEnvelope
    connect?: Enumerable<CodingProblemWhereUniqueInput>
  }

  export type CodingProblemUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<CodingProblemCreateWithoutCategoryInput>, Enumerable<CodingProblemUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<CodingProblemCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<CodingProblemUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: CodingProblemCreateManyCategoryInputEnvelope
    set?: Enumerable<CodingProblemWhereUniqueInput>
    disconnect?: Enumerable<CodingProblemWhereUniqueInput>
    delete?: Enumerable<CodingProblemWhereUniqueInput>
    connect?: Enumerable<CodingProblemWhereUniqueInput>
    update?: Enumerable<CodingProblemUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<CodingProblemUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<CodingProblemScalarWhereInput>
  }

  export type CodingProblemUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<CodingProblemCreateWithoutCategoryInput>, Enumerable<CodingProblemUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<CodingProblemCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<CodingProblemUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: CodingProblemCreateManyCategoryInputEnvelope
    set?: Enumerable<CodingProblemWhereUniqueInput>
    disconnect?: Enumerable<CodingProblemWhereUniqueInput>
    delete?: Enumerable<CodingProblemWhereUniqueInput>
    connect?: Enumerable<CodingProblemWhereUniqueInput>
    update?: Enumerable<CodingProblemUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<CodingProblemUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<CodingProblemScalarWhereInput>
  }

  export type TagCodingProblemCreateNestedManyWithoutTagInput = {
    create?: XOR<Enumerable<TagCodingProblemCreateWithoutTagInput>, Enumerable<TagCodingProblemUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<TagCodingProblemCreateOrConnectWithoutTagInput>
    createMany?: TagCodingProblemCreateManyTagInputEnvelope
    connect?: Enumerable<TagCodingProblemWhereUniqueInput>
  }

  export type TagCodingProblemUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<Enumerable<TagCodingProblemCreateWithoutTagInput>, Enumerable<TagCodingProblemUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<TagCodingProblemCreateOrConnectWithoutTagInput>
    createMany?: TagCodingProblemCreateManyTagInputEnvelope
    connect?: Enumerable<TagCodingProblemWhereUniqueInput>
  }

  export type TagCodingProblemUpdateManyWithoutTagNestedInput = {
    create?: XOR<Enumerable<TagCodingProblemCreateWithoutTagInput>, Enumerable<TagCodingProblemUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<TagCodingProblemCreateOrConnectWithoutTagInput>
    upsert?: Enumerable<TagCodingProblemUpsertWithWhereUniqueWithoutTagInput>
    createMany?: TagCodingProblemCreateManyTagInputEnvelope
    set?: Enumerable<TagCodingProblemWhereUniqueInput>
    disconnect?: Enumerable<TagCodingProblemWhereUniqueInput>
    delete?: Enumerable<TagCodingProblemWhereUniqueInput>
    connect?: Enumerable<TagCodingProblemWhereUniqueInput>
    update?: Enumerable<TagCodingProblemUpdateWithWhereUniqueWithoutTagInput>
    updateMany?: Enumerable<TagCodingProblemUpdateManyWithWhereWithoutTagInput>
    deleteMany?: Enumerable<TagCodingProblemScalarWhereInput>
  }

  export type TagCodingProblemUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<Enumerable<TagCodingProblemCreateWithoutTagInput>, Enumerable<TagCodingProblemUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<TagCodingProblemCreateOrConnectWithoutTagInput>
    upsert?: Enumerable<TagCodingProblemUpsertWithWhereUniqueWithoutTagInput>
    createMany?: TagCodingProblemCreateManyTagInputEnvelope
    set?: Enumerable<TagCodingProblemWhereUniqueInput>
    disconnect?: Enumerable<TagCodingProblemWhereUniqueInput>
    delete?: Enumerable<TagCodingProblemWhereUniqueInput>
    connect?: Enumerable<TagCodingProblemWhereUniqueInput>
    update?: Enumerable<TagCodingProblemUpdateWithWhereUniqueWithoutTagInput>
    updateMany?: Enumerable<TagCodingProblemUpdateManyWithWhereWithoutTagInput>
    deleteMany?: Enumerable<TagCodingProblemScalarWhereInput>
  }

  export type CodefocesTagProblemCreateNestedManyWithoutCodeforcesTagInput = {
    create?: XOR<Enumerable<CodefocesTagProblemCreateWithoutCodeforcesTagInput>, Enumerable<CodefocesTagProblemUncheckedCreateWithoutCodeforcesTagInput>>
    connectOrCreate?: Enumerable<CodefocesTagProblemCreateOrConnectWithoutCodeforcesTagInput>
    createMany?: CodefocesTagProblemCreateManyCodeforcesTagInputEnvelope
    connect?: Enumerable<CodefocesTagProblemWhereUniqueInput>
  }

  export type CodefocesTagProblemUncheckedCreateNestedManyWithoutCodeforcesTagInput = {
    create?: XOR<Enumerable<CodefocesTagProblemCreateWithoutCodeforcesTagInput>, Enumerable<CodefocesTagProblemUncheckedCreateWithoutCodeforcesTagInput>>
    connectOrCreate?: Enumerable<CodefocesTagProblemCreateOrConnectWithoutCodeforcesTagInput>
    createMany?: CodefocesTagProblemCreateManyCodeforcesTagInputEnvelope
    connect?: Enumerable<CodefocesTagProblemWhereUniqueInput>
  }

  export type CodefocesTagProblemUpdateManyWithoutCodeforcesTagNestedInput = {
    create?: XOR<Enumerable<CodefocesTagProblemCreateWithoutCodeforcesTagInput>, Enumerable<CodefocesTagProblemUncheckedCreateWithoutCodeforcesTagInput>>
    connectOrCreate?: Enumerable<CodefocesTagProblemCreateOrConnectWithoutCodeforcesTagInput>
    upsert?: Enumerable<CodefocesTagProblemUpsertWithWhereUniqueWithoutCodeforcesTagInput>
    createMany?: CodefocesTagProblemCreateManyCodeforcesTagInputEnvelope
    set?: Enumerable<CodefocesTagProblemWhereUniqueInput>
    disconnect?: Enumerable<CodefocesTagProblemWhereUniqueInput>
    delete?: Enumerable<CodefocesTagProblemWhereUniqueInput>
    connect?: Enumerable<CodefocesTagProblemWhereUniqueInput>
    update?: Enumerable<CodefocesTagProblemUpdateWithWhereUniqueWithoutCodeforcesTagInput>
    updateMany?: Enumerable<CodefocesTagProblemUpdateManyWithWhereWithoutCodeforcesTagInput>
    deleteMany?: Enumerable<CodefocesTagProblemScalarWhereInput>
  }

  export type CodefocesTagProblemUncheckedUpdateManyWithoutCodeforcesTagNestedInput = {
    create?: XOR<Enumerable<CodefocesTagProblemCreateWithoutCodeforcesTagInput>, Enumerable<CodefocesTagProblemUncheckedCreateWithoutCodeforcesTagInput>>
    connectOrCreate?: Enumerable<CodefocesTagProblemCreateOrConnectWithoutCodeforcesTagInput>
    upsert?: Enumerable<CodefocesTagProblemUpsertWithWhereUniqueWithoutCodeforcesTagInput>
    createMany?: CodefocesTagProblemCreateManyCodeforcesTagInputEnvelope
    set?: Enumerable<CodefocesTagProblemWhereUniqueInput>
    disconnect?: Enumerable<CodefocesTagProblemWhereUniqueInput>
    delete?: Enumerable<CodefocesTagProblemWhereUniqueInput>
    connect?: Enumerable<CodefocesTagProblemWhereUniqueInput>
    update?: Enumerable<CodefocesTagProblemUpdateWithWhereUniqueWithoutCodeforcesTagInput>
    updateMany?: Enumerable<CodefocesTagProblemUpdateManyWithWhereWithoutCodeforcesTagInput>
    deleteMany?: Enumerable<CodefocesTagProblemScalarWhereInput>
  }

  export type CodingProblemCreateNestedOneWithoutCodeforcesTagInput = {
    create?: XOR<CodingProblemCreateWithoutCodeforcesTagInput, CodingProblemUncheckedCreateWithoutCodeforcesTagInput>
    connectOrCreate?: CodingProblemCreateOrConnectWithoutCodeforcesTagInput
    connect?: CodingProblemWhereUniqueInput
  }

  export type CodeforcesTagCreateNestedOneWithoutProblemsInput = {
    create?: XOR<CodeforcesTagCreateWithoutProblemsInput, CodeforcesTagUncheckedCreateWithoutProblemsInput>
    connectOrCreate?: CodeforcesTagCreateOrConnectWithoutProblemsInput
    connect?: CodeforcesTagWhereUniqueInput
  }

  export type CodingProblemUpdateOneRequiredWithoutCodeforcesTagNestedInput = {
    create?: XOR<CodingProblemCreateWithoutCodeforcesTagInput, CodingProblemUncheckedCreateWithoutCodeforcesTagInput>
    connectOrCreate?: CodingProblemCreateOrConnectWithoutCodeforcesTagInput
    upsert?: CodingProblemUpsertWithoutCodeforcesTagInput
    connect?: CodingProblemWhereUniqueInput
    update?: XOR<CodingProblemUpdateWithoutCodeforcesTagInput, CodingProblemUncheckedUpdateWithoutCodeforcesTagInput>
  }

  export type CodeforcesTagUpdateOneRequiredWithoutProblemsNestedInput = {
    create?: XOR<CodeforcesTagCreateWithoutProblemsInput, CodeforcesTagUncheckedCreateWithoutProblemsInput>
    connectOrCreate?: CodeforcesTagCreateOrConnectWithoutProblemsInput
    upsert?: CodeforcesTagUpsertWithoutProblemsInput
    connect?: CodeforcesTagWhereUniqueInput
    update?: XOR<CodeforcesTagUpdateWithoutProblemsInput, CodeforcesTagUncheckedUpdateWithoutProblemsInput>
  }

  export type CodingProblemCategoryCreateNestedOneWithoutCodingProblemsInput = {
    create?: XOR<CodingProblemCategoryCreateWithoutCodingProblemsInput, CodingProblemCategoryUncheckedCreateWithoutCodingProblemsInput>
    connectOrCreate?: CodingProblemCategoryCreateOrConnectWithoutCodingProblemsInput
    connect?: CodingProblemCategoryWhereUniqueInput
  }

  export type AuthorCodingProblemCreateNestedManyWithoutCodingProblemInput = {
    create?: XOR<Enumerable<AuthorCodingProblemCreateWithoutCodingProblemInput>, Enumerable<AuthorCodingProblemUncheckedCreateWithoutCodingProblemInput>>
    connectOrCreate?: Enumerable<AuthorCodingProblemCreateOrConnectWithoutCodingProblemInput>
    createMany?: AuthorCodingProblemCreateManyCodingProblemInputEnvelope
    connect?: Enumerable<AuthorCodingProblemWhereUniqueInput>
  }

  export type TagCodingProblemCreateNestedManyWithoutCodingProblemInput = {
    create?: XOR<Enumerable<TagCodingProblemCreateWithoutCodingProblemInput>, Enumerable<TagCodingProblemUncheckedCreateWithoutCodingProblemInput>>
    connectOrCreate?: Enumerable<TagCodingProblemCreateOrConnectWithoutCodingProblemInput>
    createMany?: TagCodingProblemCreateManyCodingProblemInputEnvelope
    connect?: Enumerable<TagCodingProblemWhereUniqueInput>
  }

  export type CodefocesTagProblemCreateNestedManyWithoutProblemInput = {
    create?: XOR<Enumerable<CodefocesTagProblemCreateWithoutProblemInput>, Enumerable<CodefocesTagProblemUncheckedCreateWithoutProblemInput>>
    connectOrCreate?: Enumerable<CodefocesTagProblemCreateOrConnectWithoutProblemInput>
    createMany?: CodefocesTagProblemCreateManyProblemInputEnvelope
    connect?: Enumerable<CodefocesTagProblemWhereUniqueInput>
  }

  export type TestcaseCreateNestedManyWithoutProblemInput = {
    create?: XOR<Enumerable<TestcaseCreateWithoutProblemInput>, Enumerable<TestcaseUncheckedCreateWithoutProblemInput>>
    connectOrCreate?: Enumerable<TestcaseCreateOrConnectWithoutProblemInput>
    createMany?: TestcaseCreateManyProblemInputEnvelope
    connect?: Enumerable<TestcaseWhereUniqueInput>
  }

  export type ContestCreateNestedOneWithoutCodingProblemsInput = {
    create?: XOR<ContestCreateWithoutCodingProblemsInput, ContestUncheckedCreateWithoutCodingProblemsInput>
    connectOrCreate?: ContestCreateOrConnectWithoutCodingProblemsInput
    connect?: ContestWhereUniqueInput
  }

  export type AuthorCodingProblemUncheckedCreateNestedManyWithoutCodingProblemInput = {
    create?: XOR<Enumerable<AuthorCodingProblemCreateWithoutCodingProblemInput>, Enumerable<AuthorCodingProblemUncheckedCreateWithoutCodingProblemInput>>
    connectOrCreate?: Enumerable<AuthorCodingProblemCreateOrConnectWithoutCodingProblemInput>
    createMany?: AuthorCodingProblemCreateManyCodingProblemInputEnvelope
    connect?: Enumerable<AuthorCodingProblemWhereUniqueInput>
  }

  export type TagCodingProblemUncheckedCreateNestedManyWithoutCodingProblemInput = {
    create?: XOR<Enumerable<TagCodingProblemCreateWithoutCodingProblemInput>, Enumerable<TagCodingProblemUncheckedCreateWithoutCodingProblemInput>>
    connectOrCreate?: Enumerable<TagCodingProblemCreateOrConnectWithoutCodingProblemInput>
    createMany?: TagCodingProblemCreateManyCodingProblemInputEnvelope
    connect?: Enumerable<TagCodingProblemWhereUniqueInput>
  }

  export type CodefocesTagProblemUncheckedCreateNestedManyWithoutProblemInput = {
    create?: XOR<Enumerable<CodefocesTagProblemCreateWithoutProblemInput>, Enumerable<CodefocesTagProblemUncheckedCreateWithoutProblemInput>>
    connectOrCreate?: Enumerable<CodefocesTagProblemCreateOrConnectWithoutProblemInput>
    createMany?: CodefocesTagProblemCreateManyProblemInputEnvelope
    connect?: Enumerable<CodefocesTagProblemWhereUniqueInput>
  }

  export type TestcaseUncheckedCreateNestedManyWithoutProblemInput = {
    create?: XOR<Enumerable<TestcaseCreateWithoutProblemInput>, Enumerable<TestcaseUncheckedCreateWithoutProblemInput>>
    connectOrCreate?: Enumerable<TestcaseCreateOrConnectWithoutProblemInput>
    createMany?: TestcaseCreateManyProblemInputEnvelope
    connect?: Enumerable<TestcaseWhereUniqueInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CodingProblemCategoryUpdateOneRequiredWithoutCodingProblemsNestedInput = {
    create?: XOR<CodingProblemCategoryCreateWithoutCodingProblemsInput, CodingProblemCategoryUncheckedCreateWithoutCodingProblemsInput>
    connectOrCreate?: CodingProblemCategoryCreateOrConnectWithoutCodingProblemsInput
    upsert?: CodingProblemCategoryUpsertWithoutCodingProblemsInput
    connect?: CodingProblemCategoryWhereUniqueInput
    update?: XOR<CodingProblemCategoryUpdateWithoutCodingProblemsInput, CodingProblemCategoryUncheckedUpdateWithoutCodingProblemsInput>
  }

  export type AuthorCodingProblemUpdateManyWithoutCodingProblemNestedInput = {
    create?: XOR<Enumerable<AuthorCodingProblemCreateWithoutCodingProblemInput>, Enumerable<AuthorCodingProblemUncheckedCreateWithoutCodingProblemInput>>
    connectOrCreate?: Enumerable<AuthorCodingProblemCreateOrConnectWithoutCodingProblemInput>
    upsert?: Enumerable<AuthorCodingProblemUpsertWithWhereUniqueWithoutCodingProblemInput>
    createMany?: AuthorCodingProblemCreateManyCodingProblemInputEnvelope
    set?: Enumerable<AuthorCodingProblemWhereUniqueInput>
    disconnect?: Enumerable<AuthorCodingProblemWhereUniqueInput>
    delete?: Enumerable<AuthorCodingProblemWhereUniqueInput>
    connect?: Enumerable<AuthorCodingProblemWhereUniqueInput>
    update?: Enumerable<AuthorCodingProblemUpdateWithWhereUniqueWithoutCodingProblemInput>
    updateMany?: Enumerable<AuthorCodingProblemUpdateManyWithWhereWithoutCodingProblemInput>
    deleteMany?: Enumerable<AuthorCodingProblemScalarWhereInput>
  }

  export type TagCodingProblemUpdateManyWithoutCodingProblemNestedInput = {
    create?: XOR<Enumerable<TagCodingProblemCreateWithoutCodingProblemInput>, Enumerable<TagCodingProblemUncheckedCreateWithoutCodingProblemInput>>
    connectOrCreate?: Enumerable<TagCodingProblemCreateOrConnectWithoutCodingProblemInput>
    upsert?: Enumerable<TagCodingProblemUpsertWithWhereUniqueWithoutCodingProblemInput>
    createMany?: TagCodingProblemCreateManyCodingProblemInputEnvelope
    set?: Enumerable<TagCodingProblemWhereUniqueInput>
    disconnect?: Enumerable<TagCodingProblemWhereUniqueInput>
    delete?: Enumerable<TagCodingProblemWhereUniqueInput>
    connect?: Enumerable<TagCodingProblemWhereUniqueInput>
    update?: Enumerable<TagCodingProblemUpdateWithWhereUniqueWithoutCodingProblemInput>
    updateMany?: Enumerable<TagCodingProblemUpdateManyWithWhereWithoutCodingProblemInput>
    deleteMany?: Enumerable<TagCodingProblemScalarWhereInput>
  }

  export type CodefocesTagProblemUpdateManyWithoutProblemNestedInput = {
    create?: XOR<Enumerable<CodefocesTagProblemCreateWithoutProblemInput>, Enumerable<CodefocesTagProblemUncheckedCreateWithoutProblemInput>>
    connectOrCreate?: Enumerable<CodefocesTagProblemCreateOrConnectWithoutProblemInput>
    upsert?: Enumerable<CodefocesTagProblemUpsertWithWhereUniqueWithoutProblemInput>
    createMany?: CodefocesTagProblemCreateManyProblemInputEnvelope
    set?: Enumerable<CodefocesTagProblemWhereUniqueInput>
    disconnect?: Enumerable<CodefocesTagProblemWhereUniqueInput>
    delete?: Enumerable<CodefocesTagProblemWhereUniqueInput>
    connect?: Enumerable<CodefocesTagProblemWhereUniqueInput>
    update?: Enumerable<CodefocesTagProblemUpdateWithWhereUniqueWithoutProblemInput>
    updateMany?: Enumerable<CodefocesTagProblemUpdateManyWithWhereWithoutProblemInput>
    deleteMany?: Enumerable<CodefocesTagProblemScalarWhereInput>
  }

  export type TestcaseUpdateManyWithoutProblemNestedInput = {
    create?: XOR<Enumerable<TestcaseCreateWithoutProblemInput>, Enumerable<TestcaseUncheckedCreateWithoutProblemInput>>
    connectOrCreate?: Enumerable<TestcaseCreateOrConnectWithoutProblemInput>
    upsert?: Enumerable<TestcaseUpsertWithWhereUniqueWithoutProblemInput>
    createMany?: TestcaseCreateManyProblemInputEnvelope
    set?: Enumerable<TestcaseWhereUniqueInput>
    disconnect?: Enumerable<TestcaseWhereUniqueInput>
    delete?: Enumerable<TestcaseWhereUniqueInput>
    connect?: Enumerable<TestcaseWhereUniqueInput>
    update?: Enumerable<TestcaseUpdateWithWhereUniqueWithoutProblemInput>
    updateMany?: Enumerable<TestcaseUpdateManyWithWhereWithoutProblemInput>
    deleteMany?: Enumerable<TestcaseScalarWhereInput>
  }

  export type ContestUpdateOneWithoutCodingProblemsNestedInput = {
    create?: XOR<ContestCreateWithoutCodingProblemsInput, ContestUncheckedCreateWithoutCodingProblemsInput>
    connectOrCreate?: ContestCreateOrConnectWithoutCodingProblemsInput
    upsert?: ContestUpsertWithoutCodingProblemsInput
    disconnect?: boolean
    delete?: boolean
    connect?: ContestWhereUniqueInput
    update?: XOR<ContestUpdateWithoutCodingProblemsInput, ContestUncheckedUpdateWithoutCodingProblemsInput>
  }

  export type AuthorCodingProblemUncheckedUpdateManyWithoutCodingProblemNestedInput = {
    create?: XOR<Enumerable<AuthorCodingProblemCreateWithoutCodingProblemInput>, Enumerable<AuthorCodingProblemUncheckedCreateWithoutCodingProblemInput>>
    connectOrCreate?: Enumerable<AuthorCodingProblemCreateOrConnectWithoutCodingProblemInput>
    upsert?: Enumerable<AuthorCodingProblemUpsertWithWhereUniqueWithoutCodingProblemInput>
    createMany?: AuthorCodingProblemCreateManyCodingProblemInputEnvelope
    set?: Enumerable<AuthorCodingProblemWhereUniqueInput>
    disconnect?: Enumerable<AuthorCodingProblemWhereUniqueInput>
    delete?: Enumerable<AuthorCodingProblemWhereUniqueInput>
    connect?: Enumerable<AuthorCodingProblemWhereUniqueInput>
    update?: Enumerable<AuthorCodingProblemUpdateWithWhereUniqueWithoutCodingProblemInput>
    updateMany?: Enumerable<AuthorCodingProblemUpdateManyWithWhereWithoutCodingProblemInput>
    deleteMany?: Enumerable<AuthorCodingProblemScalarWhereInput>
  }

  export type TagCodingProblemUncheckedUpdateManyWithoutCodingProblemNestedInput = {
    create?: XOR<Enumerable<TagCodingProblemCreateWithoutCodingProblemInput>, Enumerable<TagCodingProblemUncheckedCreateWithoutCodingProblemInput>>
    connectOrCreate?: Enumerable<TagCodingProblemCreateOrConnectWithoutCodingProblemInput>
    upsert?: Enumerable<TagCodingProblemUpsertWithWhereUniqueWithoutCodingProblemInput>
    createMany?: TagCodingProblemCreateManyCodingProblemInputEnvelope
    set?: Enumerable<TagCodingProblemWhereUniqueInput>
    disconnect?: Enumerable<TagCodingProblemWhereUniqueInput>
    delete?: Enumerable<TagCodingProblemWhereUniqueInput>
    connect?: Enumerable<TagCodingProblemWhereUniqueInput>
    update?: Enumerable<TagCodingProblemUpdateWithWhereUniqueWithoutCodingProblemInput>
    updateMany?: Enumerable<TagCodingProblemUpdateManyWithWhereWithoutCodingProblemInput>
    deleteMany?: Enumerable<TagCodingProblemScalarWhereInput>
  }

  export type CodefocesTagProblemUncheckedUpdateManyWithoutProblemNestedInput = {
    create?: XOR<Enumerable<CodefocesTagProblemCreateWithoutProblemInput>, Enumerable<CodefocesTagProblemUncheckedCreateWithoutProblemInput>>
    connectOrCreate?: Enumerable<CodefocesTagProblemCreateOrConnectWithoutProblemInput>
    upsert?: Enumerable<CodefocesTagProblemUpsertWithWhereUniqueWithoutProblemInput>
    createMany?: CodefocesTagProblemCreateManyProblemInputEnvelope
    set?: Enumerable<CodefocesTagProblemWhereUniqueInput>
    disconnect?: Enumerable<CodefocesTagProblemWhereUniqueInput>
    delete?: Enumerable<CodefocesTagProblemWhereUniqueInput>
    connect?: Enumerable<CodefocesTagProblemWhereUniqueInput>
    update?: Enumerable<CodefocesTagProblemUpdateWithWhereUniqueWithoutProblemInput>
    updateMany?: Enumerable<CodefocesTagProblemUpdateManyWithWhereWithoutProblemInput>
    deleteMany?: Enumerable<CodefocesTagProblemScalarWhereInput>
  }

  export type TestcaseUncheckedUpdateManyWithoutProblemNestedInput = {
    create?: XOR<Enumerable<TestcaseCreateWithoutProblemInput>, Enumerable<TestcaseUncheckedCreateWithoutProblemInput>>
    connectOrCreate?: Enumerable<TestcaseCreateOrConnectWithoutProblemInput>
    upsert?: Enumerable<TestcaseUpsertWithWhereUniqueWithoutProblemInput>
    createMany?: TestcaseCreateManyProblemInputEnvelope
    set?: Enumerable<TestcaseWhereUniqueInput>
    disconnect?: Enumerable<TestcaseWhereUniqueInput>
    delete?: Enumerable<TestcaseWhereUniqueInput>
    connect?: Enumerable<TestcaseWhereUniqueInput>
    update?: Enumerable<TestcaseUpdateWithWhereUniqueWithoutProblemInput>
    updateMany?: Enumerable<TestcaseUpdateManyWithWhereWithoutProblemInput>
    deleteMany?: Enumerable<TestcaseScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutCodingProblemsInput = {
    create?: XOR<UserCreateWithoutCodingProblemsInput, UserUncheckedCreateWithoutCodingProblemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCodingProblemsInput
    connect?: UserWhereUniqueInput
  }

  export type CodingProblemCreateNestedOneWithoutAuthorsInput = {
    create?: XOR<CodingProblemCreateWithoutAuthorsInput, CodingProblemUncheckedCreateWithoutAuthorsInput>
    connectOrCreate?: CodingProblemCreateOrConnectWithoutAuthorsInput
    connect?: CodingProblemWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCodingProblemsNestedInput = {
    create?: XOR<UserCreateWithoutCodingProblemsInput, UserUncheckedCreateWithoutCodingProblemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCodingProblemsInput
    upsert?: UserUpsertWithoutCodingProblemsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCodingProblemsInput, UserUncheckedUpdateWithoutCodingProblemsInput>
  }

  export type CodingProblemUpdateOneRequiredWithoutAuthorsNestedInput = {
    create?: XOR<CodingProblemCreateWithoutAuthorsInput, CodingProblemUncheckedCreateWithoutAuthorsInput>
    connectOrCreate?: CodingProblemCreateOrConnectWithoutAuthorsInput
    upsert?: CodingProblemUpsertWithoutAuthorsInput
    connect?: CodingProblemWhereUniqueInput
    update?: XOR<CodingProblemUpdateWithoutAuthorsInput, CodingProblemUncheckedUpdateWithoutAuthorsInput>
  }

  export type CodingProblemTagCreateNestedOneWithoutCodingProblemsInput = {
    create?: XOR<CodingProblemTagCreateWithoutCodingProblemsInput, CodingProblemTagUncheckedCreateWithoutCodingProblemsInput>
    connectOrCreate?: CodingProblemTagCreateOrConnectWithoutCodingProblemsInput
    connect?: CodingProblemTagWhereUniqueInput
  }

  export type CodingProblemCreateNestedOneWithoutTagsInput = {
    create?: XOR<CodingProblemCreateWithoutTagsInput, CodingProblemUncheckedCreateWithoutTagsInput>
    connectOrCreate?: CodingProblemCreateOrConnectWithoutTagsInput
    connect?: CodingProblemWhereUniqueInput
  }

  export type CodingProblemTagUpdateOneRequiredWithoutCodingProblemsNestedInput = {
    create?: XOR<CodingProblemTagCreateWithoutCodingProblemsInput, CodingProblemTagUncheckedCreateWithoutCodingProblemsInput>
    connectOrCreate?: CodingProblemTagCreateOrConnectWithoutCodingProblemsInput
    upsert?: CodingProblemTagUpsertWithoutCodingProblemsInput
    connect?: CodingProblemTagWhereUniqueInput
    update?: XOR<CodingProblemTagUpdateWithoutCodingProblemsInput, CodingProblemTagUncheckedUpdateWithoutCodingProblemsInput>
  }

  export type CodingProblemUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<CodingProblemCreateWithoutTagsInput, CodingProblemUncheckedCreateWithoutTagsInput>
    connectOrCreate?: CodingProblemCreateOrConnectWithoutTagsInput
    upsert?: CodingProblemUpsertWithoutTagsInput
    connect?: CodingProblemWhereUniqueInput
    update?: XOR<CodingProblemUpdateWithoutTagsInput, CodingProblemUncheckedUpdateWithoutTagsInput>
  }

  export type UserCreateNestedOneWithoutThreadsInput = {
    create?: XOR<UserCreateWithoutThreadsInput, UserUncheckedCreateWithoutThreadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutThreadsInput
    connect?: UserWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutThreadInput = {
    create?: XOR<Enumerable<CommentCreateWithoutThreadInput>, Enumerable<CommentUncheckedCreateWithoutThreadInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutThreadInput>
    createMany?: CommentCreateManyThreadInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type ThreadCategoryCreateNestedOneWithoutThreadsInput = {
    create?: XOR<ThreadCategoryCreateWithoutThreadsInput, ThreadCategoryUncheckedCreateWithoutThreadsInput>
    connectOrCreate?: ThreadCategoryCreateOrConnectWithoutThreadsInput
    connect?: ThreadCategoryWhereUniqueInput
  }

  export type ThreadTagRelCreateNestedManyWithoutThreadInput = {
    create?: XOR<Enumerable<ThreadTagRelCreateWithoutThreadInput>, Enumerable<ThreadTagRelUncheckedCreateWithoutThreadInput>>
    connectOrCreate?: Enumerable<ThreadTagRelCreateOrConnectWithoutThreadInput>
    createMany?: ThreadTagRelCreateManyThreadInputEnvelope
    connect?: Enumerable<ThreadTagRelWhereUniqueInput>
  }

  export type UserLikeThreadCreateNestedManyWithoutThreadInput = {
    create?: XOR<Enumerable<UserLikeThreadCreateWithoutThreadInput>, Enumerable<UserLikeThreadUncheckedCreateWithoutThreadInput>>
    connectOrCreate?: Enumerable<UserLikeThreadCreateOrConnectWithoutThreadInput>
    createMany?: UserLikeThreadCreateManyThreadInputEnvelope
    connect?: Enumerable<UserLikeThreadWhereUniqueInput>
  }

  export type CommentUncheckedCreateNestedManyWithoutThreadInput = {
    create?: XOR<Enumerable<CommentCreateWithoutThreadInput>, Enumerable<CommentUncheckedCreateWithoutThreadInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutThreadInput>
    createMany?: CommentCreateManyThreadInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type ThreadTagRelUncheckedCreateNestedManyWithoutThreadInput = {
    create?: XOR<Enumerable<ThreadTagRelCreateWithoutThreadInput>, Enumerable<ThreadTagRelUncheckedCreateWithoutThreadInput>>
    connectOrCreate?: Enumerable<ThreadTagRelCreateOrConnectWithoutThreadInput>
    createMany?: ThreadTagRelCreateManyThreadInputEnvelope
    connect?: Enumerable<ThreadTagRelWhereUniqueInput>
  }

  export type UserLikeThreadUncheckedCreateNestedManyWithoutThreadInput = {
    create?: XOR<Enumerable<UserLikeThreadCreateWithoutThreadInput>, Enumerable<UserLikeThreadUncheckedCreateWithoutThreadInput>>
    connectOrCreate?: Enumerable<UserLikeThreadCreateOrConnectWithoutThreadInput>
    createMany?: UserLikeThreadCreateManyThreadInputEnvelope
    connect?: Enumerable<UserLikeThreadWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutThreadsNestedInput = {
    create?: XOR<UserCreateWithoutThreadsInput, UserUncheckedCreateWithoutThreadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutThreadsInput
    upsert?: UserUpsertWithoutThreadsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutThreadsInput, UserUncheckedUpdateWithoutThreadsInput>
  }

  export type CommentUpdateManyWithoutThreadNestedInput = {
    create?: XOR<Enumerable<CommentCreateWithoutThreadInput>, Enumerable<CommentUncheckedCreateWithoutThreadInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutThreadInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutThreadInput>
    createMany?: CommentCreateManyThreadInputEnvelope
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    connect?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutThreadInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutThreadInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type ThreadCategoryUpdateOneWithoutThreadsNestedInput = {
    create?: XOR<ThreadCategoryCreateWithoutThreadsInput, ThreadCategoryUncheckedCreateWithoutThreadsInput>
    connectOrCreate?: ThreadCategoryCreateOrConnectWithoutThreadsInput
    upsert?: ThreadCategoryUpsertWithoutThreadsInput
    disconnect?: boolean
    delete?: boolean
    connect?: ThreadCategoryWhereUniqueInput
    update?: XOR<ThreadCategoryUpdateWithoutThreadsInput, ThreadCategoryUncheckedUpdateWithoutThreadsInput>
  }

  export type ThreadTagRelUpdateManyWithoutThreadNestedInput = {
    create?: XOR<Enumerable<ThreadTagRelCreateWithoutThreadInput>, Enumerable<ThreadTagRelUncheckedCreateWithoutThreadInput>>
    connectOrCreate?: Enumerable<ThreadTagRelCreateOrConnectWithoutThreadInput>
    upsert?: Enumerable<ThreadTagRelUpsertWithWhereUniqueWithoutThreadInput>
    createMany?: ThreadTagRelCreateManyThreadInputEnvelope
    set?: Enumerable<ThreadTagRelWhereUniqueInput>
    disconnect?: Enumerable<ThreadTagRelWhereUniqueInput>
    delete?: Enumerable<ThreadTagRelWhereUniqueInput>
    connect?: Enumerable<ThreadTagRelWhereUniqueInput>
    update?: Enumerable<ThreadTagRelUpdateWithWhereUniqueWithoutThreadInput>
    updateMany?: Enumerable<ThreadTagRelUpdateManyWithWhereWithoutThreadInput>
    deleteMany?: Enumerable<ThreadTagRelScalarWhereInput>
  }

  export type UserLikeThreadUpdateManyWithoutThreadNestedInput = {
    create?: XOR<Enumerable<UserLikeThreadCreateWithoutThreadInput>, Enumerable<UserLikeThreadUncheckedCreateWithoutThreadInput>>
    connectOrCreate?: Enumerable<UserLikeThreadCreateOrConnectWithoutThreadInput>
    upsert?: Enumerable<UserLikeThreadUpsertWithWhereUniqueWithoutThreadInput>
    createMany?: UserLikeThreadCreateManyThreadInputEnvelope
    set?: Enumerable<UserLikeThreadWhereUniqueInput>
    disconnect?: Enumerable<UserLikeThreadWhereUniqueInput>
    delete?: Enumerable<UserLikeThreadWhereUniqueInput>
    connect?: Enumerable<UserLikeThreadWhereUniqueInput>
    update?: Enumerable<UserLikeThreadUpdateWithWhereUniqueWithoutThreadInput>
    updateMany?: Enumerable<UserLikeThreadUpdateManyWithWhereWithoutThreadInput>
    deleteMany?: Enumerable<UserLikeThreadScalarWhereInput>
  }

  export type CommentUncheckedUpdateManyWithoutThreadNestedInput = {
    create?: XOR<Enumerable<CommentCreateWithoutThreadInput>, Enumerable<CommentUncheckedCreateWithoutThreadInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutThreadInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutThreadInput>
    createMany?: CommentCreateManyThreadInputEnvelope
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    connect?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutThreadInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutThreadInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type ThreadTagRelUncheckedUpdateManyWithoutThreadNestedInput = {
    create?: XOR<Enumerable<ThreadTagRelCreateWithoutThreadInput>, Enumerable<ThreadTagRelUncheckedCreateWithoutThreadInput>>
    connectOrCreate?: Enumerable<ThreadTagRelCreateOrConnectWithoutThreadInput>
    upsert?: Enumerable<ThreadTagRelUpsertWithWhereUniqueWithoutThreadInput>
    createMany?: ThreadTagRelCreateManyThreadInputEnvelope
    set?: Enumerable<ThreadTagRelWhereUniqueInput>
    disconnect?: Enumerable<ThreadTagRelWhereUniqueInput>
    delete?: Enumerable<ThreadTagRelWhereUniqueInput>
    connect?: Enumerable<ThreadTagRelWhereUniqueInput>
    update?: Enumerable<ThreadTagRelUpdateWithWhereUniqueWithoutThreadInput>
    updateMany?: Enumerable<ThreadTagRelUpdateManyWithWhereWithoutThreadInput>
    deleteMany?: Enumerable<ThreadTagRelScalarWhereInput>
  }

  export type UserLikeThreadUncheckedUpdateManyWithoutThreadNestedInput = {
    create?: XOR<Enumerable<UserLikeThreadCreateWithoutThreadInput>, Enumerable<UserLikeThreadUncheckedCreateWithoutThreadInput>>
    connectOrCreate?: Enumerable<UserLikeThreadCreateOrConnectWithoutThreadInput>
    upsert?: Enumerable<UserLikeThreadUpsertWithWhereUniqueWithoutThreadInput>
    createMany?: UserLikeThreadCreateManyThreadInputEnvelope
    set?: Enumerable<UserLikeThreadWhereUniqueInput>
    disconnect?: Enumerable<UserLikeThreadWhereUniqueInput>
    delete?: Enumerable<UserLikeThreadWhereUniqueInput>
    connect?: Enumerable<UserLikeThreadWhereUniqueInput>
    update?: Enumerable<UserLikeThreadUpdateWithWhereUniqueWithoutThreadInput>
    updateMany?: Enumerable<UserLikeThreadUpdateManyWithWhereWithoutThreadInput>
    deleteMany?: Enumerable<UserLikeThreadScalarWhereInput>
  }

  export type ThreadCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<ThreadCreateWithoutCategoryInput>, Enumerable<ThreadUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<ThreadCreateOrConnectWithoutCategoryInput>
    createMany?: ThreadCreateManyCategoryInputEnvelope
    connect?: Enumerable<ThreadWhereUniqueInput>
  }

  export type ThreadUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<ThreadCreateWithoutCategoryInput>, Enumerable<ThreadUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<ThreadCreateOrConnectWithoutCategoryInput>
    createMany?: ThreadCreateManyCategoryInputEnvelope
    connect?: Enumerable<ThreadWhereUniqueInput>
  }

  export type ThreadUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<ThreadCreateWithoutCategoryInput>, Enumerable<ThreadUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<ThreadCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<ThreadUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: ThreadCreateManyCategoryInputEnvelope
    set?: Enumerable<ThreadWhereUniqueInput>
    disconnect?: Enumerable<ThreadWhereUniqueInput>
    delete?: Enumerable<ThreadWhereUniqueInput>
    connect?: Enumerable<ThreadWhereUniqueInput>
    update?: Enumerable<ThreadUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<ThreadUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<ThreadScalarWhereInput>
  }

  export type ThreadUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<ThreadCreateWithoutCategoryInput>, Enumerable<ThreadUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<ThreadCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<ThreadUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: ThreadCreateManyCategoryInputEnvelope
    set?: Enumerable<ThreadWhereUniqueInput>
    disconnect?: Enumerable<ThreadWhereUniqueInput>
    delete?: Enumerable<ThreadWhereUniqueInput>
    connect?: Enumerable<ThreadWhereUniqueInput>
    update?: Enumerable<ThreadUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<ThreadUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<ThreadScalarWhereInput>
  }

  export type ThreadTagRelCreateNestedManyWithoutTagInput = {
    create?: XOR<Enumerable<ThreadTagRelCreateWithoutTagInput>, Enumerable<ThreadTagRelUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<ThreadTagRelCreateOrConnectWithoutTagInput>
    createMany?: ThreadTagRelCreateManyTagInputEnvelope
    connect?: Enumerable<ThreadTagRelWhereUniqueInput>
  }

  export type ThreadTagRelUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<Enumerable<ThreadTagRelCreateWithoutTagInput>, Enumerable<ThreadTagRelUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<ThreadTagRelCreateOrConnectWithoutTagInput>
    createMany?: ThreadTagRelCreateManyTagInputEnvelope
    connect?: Enumerable<ThreadTagRelWhereUniqueInput>
  }

  export type ThreadTagRelUpdateManyWithoutTagNestedInput = {
    create?: XOR<Enumerable<ThreadTagRelCreateWithoutTagInput>, Enumerable<ThreadTagRelUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<ThreadTagRelCreateOrConnectWithoutTagInput>
    upsert?: Enumerable<ThreadTagRelUpsertWithWhereUniqueWithoutTagInput>
    createMany?: ThreadTagRelCreateManyTagInputEnvelope
    set?: Enumerable<ThreadTagRelWhereUniqueInput>
    disconnect?: Enumerable<ThreadTagRelWhereUniqueInput>
    delete?: Enumerable<ThreadTagRelWhereUniqueInput>
    connect?: Enumerable<ThreadTagRelWhereUniqueInput>
    update?: Enumerable<ThreadTagRelUpdateWithWhereUniqueWithoutTagInput>
    updateMany?: Enumerable<ThreadTagRelUpdateManyWithWhereWithoutTagInput>
    deleteMany?: Enumerable<ThreadTagRelScalarWhereInput>
  }

  export type ThreadTagRelUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<Enumerable<ThreadTagRelCreateWithoutTagInput>, Enumerable<ThreadTagRelUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<ThreadTagRelCreateOrConnectWithoutTagInput>
    upsert?: Enumerable<ThreadTagRelUpsertWithWhereUniqueWithoutTagInput>
    createMany?: ThreadTagRelCreateManyTagInputEnvelope
    set?: Enumerable<ThreadTagRelWhereUniqueInput>
    disconnect?: Enumerable<ThreadTagRelWhereUniqueInput>
    delete?: Enumerable<ThreadTagRelWhereUniqueInput>
    connect?: Enumerable<ThreadTagRelWhereUniqueInput>
    update?: Enumerable<ThreadTagRelUpdateWithWhereUniqueWithoutTagInput>
    updateMany?: Enumerable<ThreadTagRelUpdateManyWithWhereWithoutTagInput>
    deleteMany?: Enumerable<ThreadTagRelScalarWhereInput>
  }

  export type ThreadCreateNestedOneWithoutTagsInput = {
    create?: XOR<ThreadCreateWithoutTagsInput, ThreadUncheckedCreateWithoutTagsInput>
    connectOrCreate?: ThreadCreateOrConnectWithoutTagsInput
    connect?: ThreadWhereUniqueInput
  }

  export type ThreadTagCreateNestedOneWithoutThreadsInput = {
    create?: XOR<ThreadTagCreateWithoutThreadsInput, ThreadTagUncheckedCreateWithoutThreadsInput>
    connectOrCreate?: ThreadTagCreateOrConnectWithoutThreadsInput
    connect?: ThreadTagWhereUniqueInput
  }

  export type ThreadUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<ThreadCreateWithoutTagsInput, ThreadUncheckedCreateWithoutTagsInput>
    connectOrCreate?: ThreadCreateOrConnectWithoutTagsInput
    upsert?: ThreadUpsertWithoutTagsInput
    connect?: ThreadWhereUniqueInput
    update?: XOR<ThreadUpdateWithoutTagsInput, ThreadUncheckedUpdateWithoutTagsInput>
  }

  export type ThreadTagUpdateOneRequiredWithoutThreadsNestedInput = {
    create?: XOR<ThreadTagCreateWithoutThreadsInput, ThreadTagUncheckedCreateWithoutThreadsInput>
    connectOrCreate?: ThreadTagCreateOrConnectWithoutThreadsInput
    upsert?: ThreadTagUpsertWithoutThreadsInput
    connect?: ThreadTagWhereUniqueInput
    update?: XOR<ThreadTagUpdateWithoutThreadsInput, ThreadTagUncheckedUpdateWithoutThreadsInput>
  }

  export type UserCreateNestedOneWithoutThreadLikedInput = {
    create?: XOR<UserCreateWithoutThreadLikedInput, UserUncheckedCreateWithoutThreadLikedInput>
    connectOrCreate?: UserCreateOrConnectWithoutThreadLikedInput
    connect?: UserWhereUniqueInput
  }

  export type ThreadCreateNestedOneWithoutUserLikesInput = {
    create?: XOR<ThreadCreateWithoutUserLikesInput, ThreadUncheckedCreateWithoutUserLikesInput>
    connectOrCreate?: ThreadCreateOrConnectWithoutUserLikesInput
    connect?: ThreadWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutThreadLikedNestedInput = {
    create?: XOR<UserCreateWithoutThreadLikedInput, UserUncheckedCreateWithoutThreadLikedInput>
    connectOrCreate?: UserCreateOrConnectWithoutThreadLikedInput
    upsert?: UserUpsertWithoutThreadLikedInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutThreadLikedInput, UserUncheckedUpdateWithoutThreadLikedInput>
  }

  export type ThreadUpdateOneRequiredWithoutUserLikesNestedInput = {
    create?: XOR<ThreadCreateWithoutUserLikesInput, ThreadUncheckedCreateWithoutUserLikesInput>
    connectOrCreate?: ThreadCreateOrConnectWithoutUserLikesInput
    upsert?: ThreadUpsertWithoutUserLikesInput
    connect?: ThreadWhereUniqueInput
    update?: XOR<ThreadUpdateWithoutUserLikesInput, ThreadUncheckedUpdateWithoutUserLikesInput>
  }

  export type UserCreateNestedOneWithoutCommentLikedInput = {
    create?: XOR<UserCreateWithoutCommentLikedInput, UserUncheckedCreateWithoutCommentLikedInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentLikedInput
    connect?: UserWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutUsersLikedInput = {
    create?: XOR<CommentCreateWithoutUsersLikedInput, CommentUncheckedCreateWithoutUsersLikedInput>
    connectOrCreate?: CommentCreateOrConnectWithoutUsersLikedInput
    connect?: CommentWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCommentLikedNestedInput = {
    create?: XOR<UserCreateWithoutCommentLikedInput, UserUncheckedCreateWithoutCommentLikedInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentLikedInput
    upsert?: UserUpsertWithoutCommentLikedInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCommentLikedInput, UserUncheckedUpdateWithoutCommentLikedInput>
  }

  export type CommentUpdateOneRequiredWithoutUsersLikedNestedInput = {
    create?: XOR<CommentCreateWithoutUsersLikedInput, CommentUncheckedCreateWithoutUsersLikedInput>
    connectOrCreate?: CommentCreateOrConnectWithoutUsersLikedInput
    upsert?: CommentUpsertWithoutUsersLikedInput
    connect?: CommentWhereUniqueInput
    update?: XOR<CommentUpdateWithoutUsersLikedInput, CommentUncheckedUpdateWithoutUsersLikedInput>
  }

  export type ThreadCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ThreadCreateWithoutCommentsInput, ThreadUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ThreadCreateOrConnectWithoutCommentsInput
    connect?: ThreadWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserLikeCommentCreateNestedManyWithoutCommentInput = {
    create?: XOR<Enumerable<UserLikeCommentCreateWithoutCommentInput>, Enumerable<UserLikeCommentUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<UserLikeCommentCreateOrConnectWithoutCommentInput>
    createMany?: UserLikeCommentCreateManyCommentInputEnvelope
    connect?: Enumerable<UserLikeCommentWhereUniqueInput>
  }

  export type UserLikeCommentUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<Enumerable<UserLikeCommentCreateWithoutCommentInput>, Enumerable<UserLikeCommentUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<UserLikeCommentCreateOrConnectWithoutCommentInput>
    createMany?: UserLikeCommentCreateManyCommentInputEnvelope
    connect?: Enumerable<UserLikeCommentWhereUniqueInput>
  }

  export type ThreadUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<ThreadCreateWithoutCommentsInput, ThreadUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ThreadCreateOrConnectWithoutCommentsInput
    upsert?: ThreadUpsertWithoutCommentsInput
    connect?: ThreadWhereUniqueInput
    update?: XOR<ThreadUpdateWithoutCommentsInput, ThreadUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserLikeCommentUpdateManyWithoutCommentNestedInput = {
    create?: XOR<Enumerable<UserLikeCommentCreateWithoutCommentInput>, Enumerable<UserLikeCommentUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<UserLikeCommentCreateOrConnectWithoutCommentInput>
    upsert?: Enumerable<UserLikeCommentUpsertWithWhereUniqueWithoutCommentInput>
    createMany?: UserLikeCommentCreateManyCommentInputEnvelope
    set?: Enumerable<UserLikeCommentWhereUniqueInput>
    disconnect?: Enumerable<UserLikeCommentWhereUniqueInput>
    delete?: Enumerable<UserLikeCommentWhereUniqueInput>
    connect?: Enumerable<UserLikeCommentWhereUniqueInput>
    update?: Enumerable<UserLikeCommentUpdateWithWhereUniqueWithoutCommentInput>
    updateMany?: Enumerable<UserLikeCommentUpdateManyWithWhereWithoutCommentInput>
    deleteMany?: Enumerable<UserLikeCommentScalarWhereInput>
  }

  export type UserLikeCommentUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<Enumerable<UserLikeCommentCreateWithoutCommentInput>, Enumerable<UserLikeCommentUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<UserLikeCommentCreateOrConnectWithoutCommentInput>
    upsert?: Enumerable<UserLikeCommentUpsertWithWhereUniqueWithoutCommentInput>
    createMany?: UserLikeCommentCreateManyCommentInputEnvelope
    set?: Enumerable<UserLikeCommentWhereUniqueInput>
    disconnect?: Enumerable<UserLikeCommentWhereUniqueInput>
    delete?: Enumerable<UserLikeCommentWhereUniqueInput>
    connect?: Enumerable<UserLikeCommentWhereUniqueInput>
    update?: Enumerable<UserLikeCommentUpdateWithWhereUniqueWithoutCommentInput>
    updateMany?: Enumerable<UserLikeCommentUpdateManyWithWhereWithoutCommentInput>
    deleteMany?: Enumerable<UserLikeCommentScalarWhereInput>
  }

  export type MathProblemCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<MathProblemCreateWithoutCategoryInput>, Enumerable<MathProblemUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<MathProblemCreateOrConnectWithoutCategoryInput>
    createMany?: MathProblemCreateManyCategoryInputEnvelope
    connect?: Enumerable<MathProblemWhereUniqueInput>
  }

  export type MathProblemUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<MathProblemCreateWithoutCategoryInput>, Enumerable<MathProblemUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<MathProblemCreateOrConnectWithoutCategoryInput>
    createMany?: MathProblemCreateManyCategoryInputEnvelope
    connect?: Enumerable<MathProblemWhereUniqueInput>
  }

  export type MathProblemUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<MathProblemCreateWithoutCategoryInput>, Enumerable<MathProblemUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<MathProblemCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<MathProblemUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: MathProblemCreateManyCategoryInputEnvelope
    set?: Enumerable<MathProblemWhereUniqueInput>
    disconnect?: Enumerable<MathProblemWhereUniqueInput>
    delete?: Enumerable<MathProblemWhereUniqueInput>
    connect?: Enumerable<MathProblemWhereUniqueInput>
    update?: Enumerable<MathProblemUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<MathProblemUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<MathProblemScalarWhereInput>
  }

  export type MathProblemUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<MathProblemCreateWithoutCategoryInput>, Enumerable<MathProblemUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<MathProblemCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<MathProblemUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: MathProblemCreateManyCategoryInputEnvelope
    set?: Enumerable<MathProblemWhereUniqueInput>
    disconnect?: Enumerable<MathProblemWhereUniqueInput>
    delete?: Enumerable<MathProblemWhereUniqueInput>
    connect?: Enumerable<MathProblemWhereUniqueInput>
    update?: Enumerable<MathProblemUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<MathProblemUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<MathProblemScalarWhereInput>
  }

  export type TagMathProblemCreateNestedManyWithoutTagInput = {
    create?: XOR<Enumerable<TagMathProblemCreateWithoutTagInput>, Enumerable<TagMathProblemUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<TagMathProblemCreateOrConnectWithoutTagInput>
    createMany?: TagMathProblemCreateManyTagInputEnvelope
    connect?: Enumerable<TagMathProblemWhereUniqueInput>
  }

  export type TagMathProblemUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<Enumerable<TagMathProblemCreateWithoutTagInput>, Enumerable<TagMathProblemUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<TagMathProblemCreateOrConnectWithoutTagInput>
    createMany?: TagMathProblemCreateManyTagInputEnvelope
    connect?: Enumerable<TagMathProblemWhereUniqueInput>
  }

  export type TagMathProblemUpdateManyWithoutTagNestedInput = {
    create?: XOR<Enumerable<TagMathProblemCreateWithoutTagInput>, Enumerable<TagMathProblemUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<TagMathProblemCreateOrConnectWithoutTagInput>
    upsert?: Enumerable<TagMathProblemUpsertWithWhereUniqueWithoutTagInput>
    createMany?: TagMathProblemCreateManyTagInputEnvelope
    set?: Enumerable<TagMathProblemWhereUniqueInput>
    disconnect?: Enumerable<TagMathProblemWhereUniqueInput>
    delete?: Enumerable<TagMathProblemWhereUniqueInput>
    connect?: Enumerable<TagMathProblemWhereUniqueInput>
    update?: Enumerable<TagMathProblemUpdateWithWhereUniqueWithoutTagInput>
    updateMany?: Enumerable<TagMathProblemUpdateManyWithWhereWithoutTagInput>
    deleteMany?: Enumerable<TagMathProblemScalarWhereInput>
  }

  export type TagMathProblemUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<Enumerable<TagMathProblemCreateWithoutTagInput>, Enumerable<TagMathProblemUncheckedCreateWithoutTagInput>>
    connectOrCreate?: Enumerable<TagMathProblemCreateOrConnectWithoutTagInput>
    upsert?: Enumerable<TagMathProblemUpsertWithWhereUniqueWithoutTagInput>
    createMany?: TagMathProblemCreateManyTagInputEnvelope
    set?: Enumerable<TagMathProblemWhereUniqueInput>
    disconnect?: Enumerable<TagMathProblemWhereUniqueInput>
    delete?: Enumerable<TagMathProblemWhereUniqueInput>
    connect?: Enumerable<TagMathProblemWhereUniqueInput>
    update?: Enumerable<TagMathProblemUpdateWithWhereUniqueWithoutTagInput>
    updateMany?: Enumerable<TagMathProblemUpdateManyWithWhereWithoutTagInput>
    deleteMany?: Enumerable<TagMathProblemScalarWhereInput>
  }

  export type MathProblemCategoryCreateNestedOneWithoutMathProblemsInput = {
    create?: XOR<MathProblemCategoryCreateWithoutMathProblemsInput, MathProblemCategoryUncheckedCreateWithoutMathProblemsInput>
    connectOrCreate?: MathProblemCategoryCreateOrConnectWithoutMathProblemsInput
    connect?: MathProblemCategoryWhereUniqueInput
  }

  export type AuthorMathProblemCreateNestedManyWithoutMathProblemInput = {
    create?: XOR<Enumerable<AuthorMathProblemCreateWithoutMathProblemInput>, Enumerable<AuthorMathProblemUncheckedCreateWithoutMathProblemInput>>
    connectOrCreate?: Enumerable<AuthorMathProblemCreateOrConnectWithoutMathProblemInput>
    createMany?: AuthorMathProblemCreateManyMathProblemInputEnvelope
    connect?: Enumerable<AuthorMathProblemWhereUniqueInput>
  }

  export type TagMathProblemCreateNestedManyWithoutMathProblemInput = {
    create?: XOR<Enumerable<TagMathProblemCreateWithoutMathProblemInput>, Enumerable<TagMathProblemUncheckedCreateWithoutMathProblemInput>>
    connectOrCreate?: Enumerable<TagMathProblemCreateOrConnectWithoutMathProblemInput>
    createMany?: TagMathProblemCreateManyMathProblemInputEnvelope
    connect?: Enumerable<TagMathProblemWhereUniqueInput>
  }

  export type MathNoteCreateNestedManyWithoutMathProblemInput = {
    create?: XOR<Enumerable<MathNoteCreateWithoutMathProblemInput>, Enumerable<MathNoteUncheckedCreateWithoutMathProblemInput>>
    connectOrCreate?: Enumerable<MathNoteCreateOrConnectWithoutMathProblemInput>
    createMany?: MathNoteCreateManyMathProblemInputEnvelope
    connect?: Enumerable<MathNoteWhereUniqueInput>
  }

  export type MathSolutionCreateNestedManyWithoutMathProblemInput = {
    create?: XOR<Enumerable<MathSolutionCreateWithoutMathProblemInput>, Enumerable<MathSolutionUncheckedCreateWithoutMathProblemInput>>
    connectOrCreate?: Enumerable<MathSolutionCreateOrConnectWithoutMathProblemInput>
    createMany?: MathSolutionCreateManyMathProblemInputEnvelope
    connect?: Enumerable<MathSolutionWhereUniqueInput>
  }

  export type MathSetProbRelCreateNestedManyWithoutProblemInput = {
    create?: XOR<Enumerable<MathSetProbRelCreateWithoutProblemInput>, Enumerable<MathSetProbRelUncheckedCreateWithoutProblemInput>>
    connectOrCreate?: Enumerable<MathSetProbRelCreateOrConnectWithoutProblemInput>
    createMany?: MathSetProbRelCreateManyProblemInputEnvelope
    connect?: Enumerable<MathSetProbRelWhereUniqueInput>
  }

  export type AuthorMathProblemUncheckedCreateNestedManyWithoutMathProblemInput = {
    create?: XOR<Enumerable<AuthorMathProblemCreateWithoutMathProblemInput>, Enumerable<AuthorMathProblemUncheckedCreateWithoutMathProblemInput>>
    connectOrCreate?: Enumerable<AuthorMathProblemCreateOrConnectWithoutMathProblemInput>
    createMany?: AuthorMathProblemCreateManyMathProblemInputEnvelope
    connect?: Enumerable<AuthorMathProblemWhereUniqueInput>
  }

  export type TagMathProblemUncheckedCreateNestedManyWithoutMathProblemInput = {
    create?: XOR<Enumerable<TagMathProblemCreateWithoutMathProblemInput>, Enumerable<TagMathProblemUncheckedCreateWithoutMathProblemInput>>
    connectOrCreate?: Enumerable<TagMathProblemCreateOrConnectWithoutMathProblemInput>
    createMany?: TagMathProblemCreateManyMathProblemInputEnvelope
    connect?: Enumerable<TagMathProblemWhereUniqueInput>
  }

  export type MathNoteUncheckedCreateNestedManyWithoutMathProblemInput = {
    create?: XOR<Enumerable<MathNoteCreateWithoutMathProblemInput>, Enumerable<MathNoteUncheckedCreateWithoutMathProblemInput>>
    connectOrCreate?: Enumerable<MathNoteCreateOrConnectWithoutMathProblemInput>
    createMany?: MathNoteCreateManyMathProblemInputEnvelope
    connect?: Enumerable<MathNoteWhereUniqueInput>
  }

  export type MathSolutionUncheckedCreateNestedManyWithoutMathProblemInput = {
    create?: XOR<Enumerable<MathSolutionCreateWithoutMathProblemInput>, Enumerable<MathSolutionUncheckedCreateWithoutMathProblemInput>>
    connectOrCreate?: Enumerable<MathSolutionCreateOrConnectWithoutMathProblemInput>
    createMany?: MathSolutionCreateManyMathProblemInputEnvelope
    connect?: Enumerable<MathSolutionWhereUniqueInput>
  }

  export type MathSetProbRelUncheckedCreateNestedManyWithoutProblemInput = {
    create?: XOR<Enumerable<MathSetProbRelCreateWithoutProblemInput>, Enumerable<MathSetProbRelUncheckedCreateWithoutProblemInput>>
    connectOrCreate?: Enumerable<MathSetProbRelCreateOrConnectWithoutProblemInput>
    createMany?: MathSetProbRelCreateManyProblemInputEnvelope
    connect?: Enumerable<MathSetProbRelWhereUniqueInput>
  }

  export type MathProblemCategoryUpdateOneRequiredWithoutMathProblemsNestedInput = {
    create?: XOR<MathProblemCategoryCreateWithoutMathProblemsInput, MathProblemCategoryUncheckedCreateWithoutMathProblemsInput>
    connectOrCreate?: MathProblemCategoryCreateOrConnectWithoutMathProblemsInput
    upsert?: MathProblemCategoryUpsertWithoutMathProblemsInput
    connect?: MathProblemCategoryWhereUniqueInput
    update?: XOR<MathProblemCategoryUpdateWithoutMathProblemsInput, MathProblemCategoryUncheckedUpdateWithoutMathProblemsInput>
  }

  export type AuthorMathProblemUpdateManyWithoutMathProblemNestedInput = {
    create?: XOR<Enumerable<AuthorMathProblemCreateWithoutMathProblemInput>, Enumerable<AuthorMathProblemUncheckedCreateWithoutMathProblemInput>>
    connectOrCreate?: Enumerable<AuthorMathProblemCreateOrConnectWithoutMathProblemInput>
    upsert?: Enumerable<AuthorMathProblemUpsertWithWhereUniqueWithoutMathProblemInput>
    createMany?: AuthorMathProblemCreateManyMathProblemInputEnvelope
    set?: Enumerable<AuthorMathProblemWhereUniqueInput>
    disconnect?: Enumerable<AuthorMathProblemWhereUniqueInput>
    delete?: Enumerable<AuthorMathProblemWhereUniqueInput>
    connect?: Enumerable<AuthorMathProblemWhereUniqueInput>
    update?: Enumerable<AuthorMathProblemUpdateWithWhereUniqueWithoutMathProblemInput>
    updateMany?: Enumerable<AuthorMathProblemUpdateManyWithWhereWithoutMathProblemInput>
    deleteMany?: Enumerable<AuthorMathProblemScalarWhereInput>
  }

  export type TagMathProblemUpdateManyWithoutMathProblemNestedInput = {
    create?: XOR<Enumerable<TagMathProblemCreateWithoutMathProblemInput>, Enumerable<TagMathProblemUncheckedCreateWithoutMathProblemInput>>
    connectOrCreate?: Enumerable<TagMathProblemCreateOrConnectWithoutMathProblemInput>
    upsert?: Enumerable<TagMathProblemUpsertWithWhereUniqueWithoutMathProblemInput>
    createMany?: TagMathProblemCreateManyMathProblemInputEnvelope
    set?: Enumerable<TagMathProblemWhereUniqueInput>
    disconnect?: Enumerable<TagMathProblemWhereUniqueInput>
    delete?: Enumerable<TagMathProblemWhereUniqueInput>
    connect?: Enumerable<TagMathProblemWhereUniqueInput>
    update?: Enumerable<TagMathProblemUpdateWithWhereUniqueWithoutMathProblemInput>
    updateMany?: Enumerable<TagMathProblemUpdateManyWithWhereWithoutMathProblemInput>
    deleteMany?: Enumerable<TagMathProblemScalarWhereInput>
  }

  export type MathNoteUpdateManyWithoutMathProblemNestedInput = {
    create?: XOR<Enumerable<MathNoteCreateWithoutMathProblemInput>, Enumerable<MathNoteUncheckedCreateWithoutMathProblemInput>>
    connectOrCreate?: Enumerable<MathNoteCreateOrConnectWithoutMathProblemInput>
    upsert?: Enumerable<MathNoteUpsertWithWhereUniqueWithoutMathProblemInput>
    createMany?: MathNoteCreateManyMathProblemInputEnvelope
    set?: Enumerable<MathNoteWhereUniqueInput>
    disconnect?: Enumerable<MathNoteWhereUniqueInput>
    delete?: Enumerable<MathNoteWhereUniqueInput>
    connect?: Enumerable<MathNoteWhereUniqueInput>
    update?: Enumerable<MathNoteUpdateWithWhereUniqueWithoutMathProblemInput>
    updateMany?: Enumerable<MathNoteUpdateManyWithWhereWithoutMathProblemInput>
    deleteMany?: Enumerable<MathNoteScalarWhereInput>
  }

  export type MathSolutionUpdateManyWithoutMathProblemNestedInput = {
    create?: XOR<Enumerable<MathSolutionCreateWithoutMathProblemInput>, Enumerable<MathSolutionUncheckedCreateWithoutMathProblemInput>>
    connectOrCreate?: Enumerable<MathSolutionCreateOrConnectWithoutMathProblemInput>
    upsert?: Enumerable<MathSolutionUpsertWithWhereUniqueWithoutMathProblemInput>
    createMany?: MathSolutionCreateManyMathProblemInputEnvelope
    set?: Enumerable<MathSolutionWhereUniqueInput>
    disconnect?: Enumerable<MathSolutionWhereUniqueInput>
    delete?: Enumerable<MathSolutionWhereUniqueInput>
    connect?: Enumerable<MathSolutionWhereUniqueInput>
    update?: Enumerable<MathSolutionUpdateWithWhereUniqueWithoutMathProblemInput>
    updateMany?: Enumerable<MathSolutionUpdateManyWithWhereWithoutMathProblemInput>
    deleteMany?: Enumerable<MathSolutionScalarWhereInput>
  }

  export type MathSetProbRelUpdateManyWithoutProblemNestedInput = {
    create?: XOR<Enumerable<MathSetProbRelCreateWithoutProblemInput>, Enumerable<MathSetProbRelUncheckedCreateWithoutProblemInput>>
    connectOrCreate?: Enumerable<MathSetProbRelCreateOrConnectWithoutProblemInput>
    upsert?: Enumerable<MathSetProbRelUpsertWithWhereUniqueWithoutProblemInput>
    createMany?: MathSetProbRelCreateManyProblemInputEnvelope
    set?: Enumerable<MathSetProbRelWhereUniqueInput>
    disconnect?: Enumerable<MathSetProbRelWhereUniqueInput>
    delete?: Enumerable<MathSetProbRelWhereUniqueInput>
    connect?: Enumerable<MathSetProbRelWhereUniqueInput>
    update?: Enumerable<MathSetProbRelUpdateWithWhereUniqueWithoutProblemInput>
    updateMany?: Enumerable<MathSetProbRelUpdateManyWithWhereWithoutProblemInput>
    deleteMany?: Enumerable<MathSetProbRelScalarWhereInput>
  }

  export type AuthorMathProblemUncheckedUpdateManyWithoutMathProblemNestedInput = {
    create?: XOR<Enumerable<AuthorMathProblemCreateWithoutMathProblemInput>, Enumerable<AuthorMathProblemUncheckedCreateWithoutMathProblemInput>>
    connectOrCreate?: Enumerable<AuthorMathProblemCreateOrConnectWithoutMathProblemInput>
    upsert?: Enumerable<AuthorMathProblemUpsertWithWhereUniqueWithoutMathProblemInput>
    createMany?: AuthorMathProblemCreateManyMathProblemInputEnvelope
    set?: Enumerable<AuthorMathProblemWhereUniqueInput>
    disconnect?: Enumerable<AuthorMathProblemWhereUniqueInput>
    delete?: Enumerable<AuthorMathProblemWhereUniqueInput>
    connect?: Enumerable<AuthorMathProblemWhereUniqueInput>
    update?: Enumerable<AuthorMathProblemUpdateWithWhereUniqueWithoutMathProblemInput>
    updateMany?: Enumerable<AuthorMathProblemUpdateManyWithWhereWithoutMathProblemInput>
    deleteMany?: Enumerable<AuthorMathProblemScalarWhereInput>
  }

  export type TagMathProblemUncheckedUpdateManyWithoutMathProblemNestedInput = {
    create?: XOR<Enumerable<TagMathProblemCreateWithoutMathProblemInput>, Enumerable<TagMathProblemUncheckedCreateWithoutMathProblemInput>>
    connectOrCreate?: Enumerable<TagMathProblemCreateOrConnectWithoutMathProblemInput>
    upsert?: Enumerable<TagMathProblemUpsertWithWhereUniqueWithoutMathProblemInput>
    createMany?: TagMathProblemCreateManyMathProblemInputEnvelope
    set?: Enumerable<TagMathProblemWhereUniqueInput>
    disconnect?: Enumerable<TagMathProblemWhereUniqueInput>
    delete?: Enumerable<TagMathProblemWhereUniqueInput>
    connect?: Enumerable<TagMathProblemWhereUniqueInput>
    update?: Enumerable<TagMathProblemUpdateWithWhereUniqueWithoutMathProblemInput>
    updateMany?: Enumerable<TagMathProblemUpdateManyWithWhereWithoutMathProblemInput>
    deleteMany?: Enumerable<TagMathProblemScalarWhereInput>
  }

  export type MathNoteUncheckedUpdateManyWithoutMathProblemNestedInput = {
    create?: XOR<Enumerable<MathNoteCreateWithoutMathProblemInput>, Enumerable<MathNoteUncheckedCreateWithoutMathProblemInput>>
    connectOrCreate?: Enumerable<MathNoteCreateOrConnectWithoutMathProblemInput>
    upsert?: Enumerable<MathNoteUpsertWithWhereUniqueWithoutMathProblemInput>
    createMany?: MathNoteCreateManyMathProblemInputEnvelope
    set?: Enumerable<MathNoteWhereUniqueInput>
    disconnect?: Enumerable<MathNoteWhereUniqueInput>
    delete?: Enumerable<MathNoteWhereUniqueInput>
    connect?: Enumerable<MathNoteWhereUniqueInput>
    update?: Enumerable<MathNoteUpdateWithWhereUniqueWithoutMathProblemInput>
    updateMany?: Enumerable<MathNoteUpdateManyWithWhereWithoutMathProblemInput>
    deleteMany?: Enumerable<MathNoteScalarWhereInput>
  }

  export type MathSolutionUncheckedUpdateManyWithoutMathProblemNestedInput = {
    create?: XOR<Enumerable<MathSolutionCreateWithoutMathProblemInput>, Enumerable<MathSolutionUncheckedCreateWithoutMathProblemInput>>
    connectOrCreate?: Enumerable<MathSolutionCreateOrConnectWithoutMathProblemInput>
    upsert?: Enumerable<MathSolutionUpsertWithWhereUniqueWithoutMathProblemInput>
    createMany?: MathSolutionCreateManyMathProblemInputEnvelope
    set?: Enumerable<MathSolutionWhereUniqueInput>
    disconnect?: Enumerable<MathSolutionWhereUniqueInput>
    delete?: Enumerable<MathSolutionWhereUniqueInput>
    connect?: Enumerable<MathSolutionWhereUniqueInput>
    update?: Enumerable<MathSolutionUpdateWithWhereUniqueWithoutMathProblemInput>
    updateMany?: Enumerable<MathSolutionUpdateManyWithWhereWithoutMathProblemInput>
    deleteMany?: Enumerable<MathSolutionScalarWhereInput>
  }

  export type MathSetProbRelUncheckedUpdateManyWithoutProblemNestedInput = {
    create?: XOR<Enumerable<MathSetProbRelCreateWithoutProblemInput>, Enumerable<MathSetProbRelUncheckedCreateWithoutProblemInput>>
    connectOrCreate?: Enumerable<MathSetProbRelCreateOrConnectWithoutProblemInput>
    upsert?: Enumerable<MathSetProbRelUpsertWithWhereUniqueWithoutProblemInput>
    createMany?: MathSetProbRelCreateManyProblemInputEnvelope
    set?: Enumerable<MathSetProbRelWhereUniqueInput>
    disconnect?: Enumerable<MathSetProbRelWhereUniqueInput>
    delete?: Enumerable<MathSetProbRelWhereUniqueInput>
    connect?: Enumerable<MathSetProbRelWhereUniqueInput>
    update?: Enumerable<MathSetProbRelUpdateWithWhereUniqueWithoutProblemInput>
    updateMany?: Enumerable<MathSetProbRelUpdateManyWithWhereWithoutProblemInput>
    deleteMany?: Enumerable<MathSetProbRelScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutMathProbSetListInput = {
    create?: XOR<UserCreateWithoutMathProbSetListInput, UserUncheckedCreateWithoutMathProbSetListInput>
    connectOrCreate?: UserCreateOrConnectWithoutMathProbSetListInput
    connect?: UserWhereUniqueInput
  }

  export type MathSetProbRelCreateNestedManyWithoutMathProbSetInput = {
    create?: XOR<Enumerable<MathSetProbRelCreateWithoutMathProbSetInput>, Enumerable<MathSetProbRelUncheckedCreateWithoutMathProbSetInput>>
    connectOrCreate?: Enumerable<MathSetProbRelCreateOrConnectWithoutMathProbSetInput>
    createMany?: MathSetProbRelCreateManyMathProbSetInputEnvelope
    connect?: Enumerable<MathSetProbRelWhereUniqueInput>
  }

  export type MathSetProbRelUncheckedCreateNestedManyWithoutMathProbSetInput = {
    create?: XOR<Enumerable<MathSetProbRelCreateWithoutMathProbSetInput>, Enumerable<MathSetProbRelUncheckedCreateWithoutMathProbSetInput>>
    connectOrCreate?: Enumerable<MathSetProbRelCreateOrConnectWithoutMathProbSetInput>
    createMany?: MathSetProbRelCreateManyMathProbSetInputEnvelope
    connect?: Enumerable<MathSetProbRelWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutMathProbSetListNestedInput = {
    create?: XOR<UserCreateWithoutMathProbSetListInput, UserUncheckedCreateWithoutMathProbSetListInput>
    connectOrCreate?: UserCreateOrConnectWithoutMathProbSetListInput
    upsert?: UserUpsertWithoutMathProbSetListInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutMathProbSetListInput, UserUncheckedUpdateWithoutMathProbSetListInput>
  }

  export type MathSetProbRelUpdateManyWithoutMathProbSetNestedInput = {
    create?: XOR<Enumerable<MathSetProbRelCreateWithoutMathProbSetInput>, Enumerable<MathSetProbRelUncheckedCreateWithoutMathProbSetInput>>
    connectOrCreate?: Enumerable<MathSetProbRelCreateOrConnectWithoutMathProbSetInput>
    upsert?: Enumerable<MathSetProbRelUpsertWithWhereUniqueWithoutMathProbSetInput>
    createMany?: MathSetProbRelCreateManyMathProbSetInputEnvelope
    set?: Enumerable<MathSetProbRelWhereUniqueInput>
    disconnect?: Enumerable<MathSetProbRelWhereUniqueInput>
    delete?: Enumerable<MathSetProbRelWhereUniqueInput>
    connect?: Enumerable<MathSetProbRelWhereUniqueInput>
    update?: Enumerable<MathSetProbRelUpdateWithWhereUniqueWithoutMathProbSetInput>
    updateMany?: Enumerable<MathSetProbRelUpdateManyWithWhereWithoutMathProbSetInput>
    deleteMany?: Enumerable<MathSetProbRelScalarWhereInput>
  }

  export type MathSetProbRelUncheckedUpdateManyWithoutMathProbSetNestedInput = {
    create?: XOR<Enumerable<MathSetProbRelCreateWithoutMathProbSetInput>, Enumerable<MathSetProbRelUncheckedCreateWithoutMathProbSetInput>>
    connectOrCreate?: Enumerable<MathSetProbRelCreateOrConnectWithoutMathProbSetInput>
    upsert?: Enumerable<MathSetProbRelUpsertWithWhereUniqueWithoutMathProbSetInput>
    createMany?: MathSetProbRelCreateManyMathProbSetInputEnvelope
    set?: Enumerable<MathSetProbRelWhereUniqueInput>
    disconnect?: Enumerable<MathSetProbRelWhereUniqueInput>
    delete?: Enumerable<MathSetProbRelWhereUniqueInput>
    connect?: Enumerable<MathSetProbRelWhereUniqueInput>
    update?: Enumerable<MathSetProbRelUpdateWithWhereUniqueWithoutMathProbSetInput>
    updateMany?: Enumerable<MathSetProbRelUpdateManyWithWhereWithoutMathProbSetInput>
    deleteMany?: Enumerable<MathSetProbRelScalarWhereInput>
  }

  export type MathProblemCreateNestedOneWithoutProblemSetInput = {
    create?: XOR<MathProblemCreateWithoutProblemSetInput, MathProblemUncheckedCreateWithoutProblemSetInput>
    connectOrCreate?: MathProblemCreateOrConnectWithoutProblemSetInput
    connect?: MathProblemWhereUniqueInput
  }

  export type MathProblemSetCreateNestedOneWithoutProblemsInput = {
    create?: XOR<MathProblemSetCreateWithoutProblemsInput, MathProblemSetUncheckedCreateWithoutProblemsInput>
    connectOrCreate?: MathProblemSetCreateOrConnectWithoutProblemsInput
    connect?: MathProblemSetWhereUniqueInput
  }

  export type MathProblemUpdateOneRequiredWithoutProblemSetNestedInput = {
    create?: XOR<MathProblemCreateWithoutProblemSetInput, MathProblemUncheckedCreateWithoutProblemSetInput>
    connectOrCreate?: MathProblemCreateOrConnectWithoutProblemSetInput
    upsert?: MathProblemUpsertWithoutProblemSetInput
    connect?: MathProblemWhereUniqueInput
    update?: XOR<MathProblemUpdateWithoutProblemSetInput, MathProblemUncheckedUpdateWithoutProblemSetInput>
  }

  export type MathProblemSetUpdateOneRequiredWithoutProblemsNestedInput = {
    create?: XOR<MathProblemSetCreateWithoutProblemsInput, MathProblemSetUncheckedCreateWithoutProblemsInput>
    connectOrCreate?: MathProblemSetCreateOrConnectWithoutProblemsInput
    upsert?: MathProblemSetUpsertWithoutProblemsInput
    connect?: MathProblemSetWhereUniqueInput
    update?: XOR<MathProblemSetUpdateWithoutProblemsInput, MathProblemSetUncheckedUpdateWithoutProblemsInput>
  }

  export type UserCreateNestedOneWithoutAuthorMathProblemsInput = {
    create?: XOR<UserCreateWithoutAuthorMathProblemsInput, UserUncheckedCreateWithoutAuthorMathProblemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthorMathProblemsInput
    connect?: UserWhereUniqueInput
  }

  export type MathProblemCreateNestedOneWithoutAuthorsInput = {
    create?: XOR<MathProblemCreateWithoutAuthorsInput, MathProblemUncheckedCreateWithoutAuthorsInput>
    connectOrCreate?: MathProblemCreateOrConnectWithoutAuthorsInput
    connect?: MathProblemWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuthorMathProblemsNestedInput = {
    create?: XOR<UserCreateWithoutAuthorMathProblemsInput, UserUncheckedCreateWithoutAuthorMathProblemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthorMathProblemsInput
    upsert?: UserUpsertWithoutAuthorMathProblemsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAuthorMathProblemsInput, UserUncheckedUpdateWithoutAuthorMathProblemsInput>
  }

  export type MathProblemUpdateOneRequiredWithoutAuthorsNestedInput = {
    create?: XOR<MathProblemCreateWithoutAuthorsInput, MathProblemUncheckedCreateWithoutAuthorsInput>
    connectOrCreate?: MathProblemCreateOrConnectWithoutAuthorsInput
    upsert?: MathProblemUpsertWithoutAuthorsInput
    connect?: MathProblemWhereUniqueInput
    update?: XOR<MathProblemUpdateWithoutAuthorsInput, MathProblemUncheckedUpdateWithoutAuthorsInput>
  }

  export type MathProblemTagCreateNestedOneWithoutMathProblemsInput = {
    create?: XOR<MathProblemTagCreateWithoutMathProblemsInput, MathProblemTagUncheckedCreateWithoutMathProblemsInput>
    connectOrCreate?: MathProblemTagCreateOrConnectWithoutMathProblemsInput
    connect?: MathProblemTagWhereUniqueInput
  }

  export type MathProblemCreateNestedOneWithoutTagsInput = {
    create?: XOR<MathProblemCreateWithoutTagsInput, MathProblemUncheckedCreateWithoutTagsInput>
    connectOrCreate?: MathProblemCreateOrConnectWithoutTagsInput
    connect?: MathProblemWhereUniqueInput
  }

  export type MathProblemTagUpdateOneRequiredWithoutMathProblemsNestedInput = {
    create?: XOR<MathProblemTagCreateWithoutMathProblemsInput, MathProblemTagUncheckedCreateWithoutMathProblemsInput>
    connectOrCreate?: MathProblemTagCreateOrConnectWithoutMathProblemsInput
    upsert?: MathProblemTagUpsertWithoutMathProblemsInput
    connect?: MathProblemTagWhereUniqueInput
    update?: XOR<MathProblemTagUpdateWithoutMathProblemsInput, MathProblemTagUncheckedUpdateWithoutMathProblemsInput>
  }

  export type MathProblemUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<MathProblemCreateWithoutTagsInput, MathProblemUncheckedCreateWithoutTagsInput>
    connectOrCreate?: MathProblemCreateOrConnectWithoutTagsInput
    upsert?: MathProblemUpsertWithoutTagsInput
    connect?: MathProblemWhereUniqueInput
    update?: XOR<MathProblemUpdateWithoutTagsInput, MathProblemUncheckedUpdateWithoutTagsInput>
  }

  export type UserCreateNestedOneWithoutPostsInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    connect?: UserWhereUniqueInput
  }

  export type GroupCreateNestedOneWithoutPostsInput = {
    create?: XOR<GroupCreateWithoutPostsInput, GroupUncheckedCreateWithoutPostsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutPostsInput
    connect?: GroupWhereUniqueInput
  }

  export type GroupPostMessageCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<GroupPostMessageCreateWithoutPostInput>, Enumerable<GroupPostMessageUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<GroupPostMessageCreateOrConnectWithoutPostInput>
    createMany?: GroupPostMessageCreateManyPostInputEnvelope
    connect?: Enumerable<GroupPostMessageWhereUniqueInput>
  }

  export type GroupPostMessageUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<GroupPostMessageCreateWithoutPostInput>, Enumerable<GroupPostMessageUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<GroupPostMessageCreateOrConnectWithoutPostInput>
    createMany?: GroupPostMessageCreateManyPostInputEnvelope
    connect?: Enumerable<GroupPostMessageWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    upsert?: UserUpsertWithoutPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
  }

  export type GroupUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<GroupCreateWithoutPostsInput, GroupUncheckedCreateWithoutPostsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutPostsInput
    upsert?: GroupUpsertWithoutPostsInput
    connect?: GroupWhereUniqueInput
    update?: XOR<GroupUpdateWithoutPostsInput, GroupUncheckedUpdateWithoutPostsInput>
  }

  export type GroupPostMessageUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<GroupPostMessageCreateWithoutPostInput>, Enumerable<GroupPostMessageUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<GroupPostMessageCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<GroupPostMessageUpsertWithWhereUniqueWithoutPostInput>
    createMany?: GroupPostMessageCreateManyPostInputEnvelope
    set?: Enumerable<GroupPostMessageWhereUniqueInput>
    disconnect?: Enumerable<GroupPostMessageWhereUniqueInput>
    delete?: Enumerable<GroupPostMessageWhereUniqueInput>
    connect?: Enumerable<GroupPostMessageWhereUniqueInput>
    update?: Enumerable<GroupPostMessageUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<GroupPostMessageUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<GroupPostMessageScalarWhereInput>
  }

  export type GroupPostMessageUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<GroupPostMessageCreateWithoutPostInput>, Enumerable<GroupPostMessageUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<GroupPostMessageCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<GroupPostMessageUpsertWithWhereUniqueWithoutPostInput>
    createMany?: GroupPostMessageCreateManyPostInputEnvelope
    set?: Enumerable<GroupPostMessageWhereUniqueInput>
    disconnect?: Enumerable<GroupPostMessageWhereUniqueInput>
    delete?: Enumerable<GroupPostMessageWhereUniqueInput>
    connect?: Enumerable<GroupPostMessageWhereUniqueInput>
    update?: Enumerable<GroupPostMessageUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<GroupPostMessageUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<GroupPostMessageScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutChatMessagesInput = {
    create?: XOR<UserCreateWithoutChatMessagesInput, UserUncheckedCreateWithoutChatMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type ChatSessionCreateNestedOneWithoutChatMessagesInput = {
    create?: XOR<ChatSessionCreateWithoutChatMessagesInput, ChatSessionUncheckedCreateWithoutChatMessagesInput>
    connectOrCreate?: ChatSessionCreateOrConnectWithoutChatMessagesInput
    connect?: ChatSessionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutChatMessagesNestedInput = {
    create?: XOR<UserCreateWithoutChatMessagesInput, UserUncheckedCreateWithoutChatMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatMessagesInput
    upsert?: UserUpsertWithoutChatMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutChatMessagesInput, UserUncheckedUpdateWithoutChatMessagesInput>
  }

  export type ChatSessionUpdateOneRequiredWithoutChatMessagesNestedInput = {
    create?: XOR<ChatSessionCreateWithoutChatMessagesInput, ChatSessionUncheckedCreateWithoutChatMessagesInput>
    connectOrCreate?: ChatSessionCreateOrConnectWithoutChatMessagesInput
    upsert?: ChatSessionUpsertWithoutChatMessagesInput
    connect?: ChatSessionWhereUniqueInput
    update?: XOR<ChatSessionUpdateWithoutChatMessagesInput, ChatSessionUncheckedUpdateWithoutChatMessagesInput>
  }

  export type UserCreateNestedOneWithoutGroupPostMessagesInput = {
    create?: XOR<UserCreateWithoutGroupPostMessagesInput, UserUncheckedCreateWithoutGroupPostMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupPostMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type GroupPostCreateNestedOneWithoutMessagesInput = {
    create?: XOR<GroupPostCreateWithoutMessagesInput, GroupPostUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: GroupPostCreateOrConnectWithoutMessagesInput
    connect?: GroupPostWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutGroupPostMessagesNestedInput = {
    create?: XOR<UserCreateWithoutGroupPostMessagesInput, UserUncheckedCreateWithoutGroupPostMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupPostMessagesInput
    upsert?: UserUpsertWithoutGroupPostMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutGroupPostMessagesInput, UserUncheckedUpdateWithoutGroupPostMessagesInput>
  }

  export type GroupPostUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<GroupPostCreateWithoutMessagesInput, GroupPostUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: GroupPostCreateOrConnectWithoutMessagesInput
    upsert?: GroupPostUpsertWithoutMessagesInput
    connect?: GroupPostWhereUniqueInput
    update?: XOR<GroupPostUpdateWithoutMessagesInput, GroupPostUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatMessageCreateNestedManyWithoutChatSessionInput = {
    create?: XOR<Enumerable<ChatMessageCreateWithoutChatSessionInput>, Enumerable<ChatMessageUncheckedCreateWithoutChatSessionInput>>
    connectOrCreate?: Enumerable<ChatMessageCreateOrConnectWithoutChatSessionInput>
    createMany?: ChatMessageCreateManyChatSessionInputEnvelope
    connect?: Enumerable<ChatMessageWhereUniqueInput>
  }

  export type ChatSessionUserCreateNestedManyWithoutChatSessionInput = {
    create?: XOR<Enumerable<ChatSessionUserCreateWithoutChatSessionInput>, Enumerable<ChatSessionUserUncheckedCreateWithoutChatSessionInput>>
    connectOrCreate?: Enumerable<ChatSessionUserCreateOrConnectWithoutChatSessionInput>
    createMany?: ChatSessionUserCreateManyChatSessionInputEnvelope
    connect?: Enumerable<ChatSessionUserWhereUniqueInput>
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutChatSessionInput = {
    create?: XOR<Enumerable<ChatMessageCreateWithoutChatSessionInput>, Enumerable<ChatMessageUncheckedCreateWithoutChatSessionInput>>
    connectOrCreate?: Enumerable<ChatMessageCreateOrConnectWithoutChatSessionInput>
    createMany?: ChatMessageCreateManyChatSessionInputEnvelope
    connect?: Enumerable<ChatMessageWhereUniqueInput>
  }

  export type ChatSessionUserUncheckedCreateNestedManyWithoutChatSessionInput = {
    create?: XOR<Enumerable<ChatSessionUserCreateWithoutChatSessionInput>, Enumerable<ChatSessionUserUncheckedCreateWithoutChatSessionInput>>
    connectOrCreate?: Enumerable<ChatSessionUserCreateOrConnectWithoutChatSessionInput>
    createMany?: ChatSessionUserCreateManyChatSessionInputEnvelope
    connect?: Enumerable<ChatSessionUserWhereUniqueInput>
  }

  export type EnumChatSessionTypeFieldUpdateOperationsInput = {
    set?: ChatSessionType
  }

  export type ChatMessageUpdateManyWithoutChatSessionNestedInput = {
    create?: XOR<Enumerable<ChatMessageCreateWithoutChatSessionInput>, Enumerable<ChatMessageUncheckedCreateWithoutChatSessionInput>>
    connectOrCreate?: Enumerable<ChatMessageCreateOrConnectWithoutChatSessionInput>
    upsert?: Enumerable<ChatMessageUpsertWithWhereUniqueWithoutChatSessionInput>
    createMany?: ChatMessageCreateManyChatSessionInputEnvelope
    set?: Enumerable<ChatMessageWhereUniqueInput>
    disconnect?: Enumerable<ChatMessageWhereUniqueInput>
    delete?: Enumerable<ChatMessageWhereUniqueInput>
    connect?: Enumerable<ChatMessageWhereUniqueInput>
    update?: Enumerable<ChatMessageUpdateWithWhereUniqueWithoutChatSessionInput>
    updateMany?: Enumerable<ChatMessageUpdateManyWithWhereWithoutChatSessionInput>
    deleteMany?: Enumerable<ChatMessageScalarWhereInput>
  }

  export type ChatSessionUserUpdateManyWithoutChatSessionNestedInput = {
    create?: XOR<Enumerable<ChatSessionUserCreateWithoutChatSessionInput>, Enumerable<ChatSessionUserUncheckedCreateWithoutChatSessionInput>>
    connectOrCreate?: Enumerable<ChatSessionUserCreateOrConnectWithoutChatSessionInput>
    upsert?: Enumerable<ChatSessionUserUpsertWithWhereUniqueWithoutChatSessionInput>
    createMany?: ChatSessionUserCreateManyChatSessionInputEnvelope
    set?: Enumerable<ChatSessionUserWhereUniqueInput>
    disconnect?: Enumerable<ChatSessionUserWhereUniqueInput>
    delete?: Enumerable<ChatSessionUserWhereUniqueInput>
    connect?: Enumerable<ChatSessionUserWhereUniqueInput>
    update?: Enumerable<ChatSessionUserUpdateWithWhereUniqueWithoutChatSessionInput>
    updateMany?: Enumerable<ChatSessionUserUpdateManyWithWhereWithoutChatSessionInput>
    deleteMany?: Enumerable<ChatSessionUserScalarWhereInput>
  }

  export type ChatMessageUncheckedUpdateManyWithoutChatSessionNestedInput = {
    create?: XOR<Enumerable<ChatMessageCreateWithoutChatSessionInput>, Enumerable<ChatMessageUncheckedCreateWithoutChatSessionInput>>
    connectOrCreate?: Enumerable<ChatMessageCreateOrConnectWithoutChatSessionInput>
    upsert?: Enumerable<ChatMessageUpsertWithWhereUniqueWithoutChatSessionInput>
    createMany?: ChatMessageCreateManyChatSessionInputEnvelope
    set?: Enumerable<ChatMessageWhereUniqueInput>
    disconnect?: Enumerable<ChatMessageWhereUniqueInput>
    delete?: Enumerable<ChatMessageWhereUniqueInput>
    connect?: Enumerable<ChatMessageWhereUniqueInput>
    update?: Enumerable<ChatMessageUpdateWithWhereUniqueWithoutChatSessionInput>
    updateMany?: Enumerable<ChatMessageUpdateManyWithWhereWithoutChatSessionInput>
    deleteMany?: Enumerable<ChatMessageScalarWhereInput>
  }

  export type ChatSessionUserUncheckedUpdateManyWithoutChatSessionNestedInput = {
    create?: XOR<Enumerable<ChatSessionUserCreateWithoutChatSessionInput>, Enumerable<ChatSessionUserUncheckedCreateWithoutChatSessionInput>>
    connectOrCreate?: Enumerable<ChatSessionUserCreateOrConnectWithoutChatSessionInput>
    upsert?: Enumerable<ChatSessionUserUpsertWithWhereUniqueWithoutChatSessionInput>
    createMany?: ChatSessionUserCreateManyChatSessionInputEnvelope
    set?: Enumerable<ChatSessionUserWhereUniqueInput>
    disconnect?: Enumerable<ChatSessionUserWhereUniqueInput>
    delete?: Enumerable<ChatSessionUserWhereUniqueInput>
    connect?: Enumerable<ChatSessionUserWhereUniqueInput>
    update?: Enumerable<ChatSessionUserUpdateWithWhereUniqueWithoutChatSessionInput>
    updateMany?: Enumerable<ChatSessionUserUpdateManyWithWhereWithoutChatSessionInput>
    deleteMany?: Enumerable<ChatSessionUserScalarWhereInput>
  }

  export type ChatSessionCreateNestedOneWithoutUsersInput = {
    create?: XOR<ChatSessionCreateWithoutUsersInput, ChatSessionUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ChatSessionCreateOrConnectWithoutUsersInput
    connect?: ChatSessionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChatSessionsInput = {
    create?: XOR<UserCreateWithoutChatSessionsInput, UserUncheckedCreateWithoutChatSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type ChatSessionUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<ChatSessionCreateWithoutUsersInput, ChatSessionUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ChatSessionCreateOrConnectWithoutUsersInput
    upsert?: ChatSessionUpsertWithoutUsersInput
    connect?: ChatSessionWhereUniqueInput
    update?: XOR<ChatSessionUpdateWithoutUsersInput, ChatSessionUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneRequiredWithoutChatSessionsNestedInput = {
    create?: XOR<UserCreateWithoutChatSessionsInput, UserUncheckedCreateWithoutChatSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatSessionsInput
    upsert?: UserUpsertWithoutChatSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutChatSessionsInput, UserUncheckedUpdateWithoutChatSessionsInput>
  }

  export type UserCreateNestedOneWithoutMathNotesInput = {
    create?: XOR<UserCreateWithoutMathNotesInput, UserUncheckedCreateWithoutMathNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMathNotesInput
    connect?: UserWhereUniqueInput
  }

  export type MathProblemCreateNestedOneWithoutMathNotesInput = {
    create?: XOR<MathProblemCreateWithoutMathNotesInput, MathProblemUncheckedCreateWithoutMathNotesInput>
    connectOrCreate?: MathProblemCreateOrConnectWithoutMathNotesInput
    connect?: MathProblemWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMathNotesNestedInput = {
    create?: XOR<UserCreateWithoutMathNotesInput, UserUncheckedCreateWithoutMathNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMathNotesInput
    upsert?: UserUpsertWithoutMathNotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutMathNotesInput, UserUncheckedUpdateWithoutMathNotesInput>
  }

  export type MathProblemUpdateOneRequiredWithoutMathNotesNestedInput = {
    create?: XOR<MathProblemCreateWithoutMathNotesInput, MathProblemUncheckedCreateWithoutMathNotesInput>
    connectOrCreate?: MathProblemCreateOrConnectWithoutMathNotesInput
    upsert?: MathProblemUpsertWithoutMathNotesInput
    connect?: MathProblemWhereUniqueInput
    update?: XOR<MathProblemUpdateWithoutMathNotesInput, MathProblemUncheckedUpdateWithoutMathNotesInput>
  }

  export type UserCreateNestedOneWithoutMathSolutionsInput = {
    create?: XOR<UserCreateWithoutMathSolutionsInput, UserUncheckedCreateWithoutMathSolutionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMathSolutionsInput
    connect?: UserWhereUniqueInput
  }

  export type MathProblemCreateNestedOneWithoutMathSolutionsInput = {
    create?: XOR<MathProblemCreateWithoutMathSolutionsInput, MathProblemUncheckedCreateWithoutMathSolutionsInput>
    connectOrCreate?: MathProblemCreateOrConnectWithoutMathSolutionsInput
    connect?: MathProblemWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMathSolutionsNestedInput = {
    create?: XOR<UserCreateWithoutMathSolutionsInput, UserUncheckedCreateWithoutMathSolutionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMathSolutionsInput
    upsert?: UserUpsertWithoutMathSolutionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutMathSolutionsInput, UserUncheckedUpdateWithoutMathSolutionsInput>
  }

  export type MathProblemUpdateOneRequiredWithoutMathSolutionsNestedInput = {
    create?: XOR<MathProblemCreateWithoutMathSolutionsInput, MathProblemUncheckedCreateWithoutMathSolutionsInput>
    connectOrCreate?: MathProblemCreateOrConnectWithoutMathSolutionsInput
    upsert?: MathProblemUpsertWithoutMathSolutionsInput
    connect?: MathProblemWhereUniqueInput
    update?: XOR<MathProblemUpdateWithoutMathSolutionsInput, MathProblemUncheckedUpdateWithoutMathSolutionsInput>
  }

  export type CodingProblemCreateNestedManyWithoutContestInput = {
    create?: XOR<Enumerable<CodingProblemCreateWithoutContestInput>, Enumerable<CodingProblemUncheckedCreateWithoutContestInput>>
    connectOrCreate?: Enumerable<CodingProblemCreateOrConnectWithoutContestInput>
    createMany?: CodingProblemCreateManyContestInputEnvelope
    connect?: Enumerable<CodingProblemWhereUniqueInput>
  }

  export type CodingProblemUncheckedCreateNestedManyWithoutContestInput = {
    create?: XOR<Enumerable<CodingProblemCreateWithoutContestInput>, Enumerable<CodingProblemUncheckedCreateWithoutContestInput>>
    connectOrCreate?: Enumerable<CodingProblemCreateOrConnectWithoutContestInput>
    createMany?: CodingProblemCreateManyContestInputEnvelope
    connect?: Enumerable<CodingProblemWhereUniqueInput>
  }

  export type EnumProblemRuleTypeFieldUpdateOperationsInput = {
    set?: ProblemRuleType
  }

  export type CodingProblemUpdateManyWithoutContestNestedInput = {
    create?: XOR<Enumerable<CodingProblemCreateWithoutContestInput>, Enumerable<CodingProblemUncheckedCreateWithoutContestInput>>
    connectOrCreate?: Enumerable<CodingProblemCreateOrConnectWithoutContestInput>
    upsert?: Enumerable<CodingProblemUpsertWithWhereUniqueWithoutContestInput>
    createMany?: CodingProblemCreateManyContestInputEnvelope
    set?: Enumerable<CodingProblemWhereUniqueInput>
    disconnect?: Enumerable<CodingProblemWhereUniqueInput>
    delete?: Enumerable<CodingProblemWhereUniqueInput>
    connect?: Enumerable<CodingProblemWhereUniqueInput>
    update?: Enumerable<CodingProblemUpdateWithWhereUniqueWithoutContestInput>
    updateMany?: Enumerable<CodingProblemUpdateManyWithWhereWithoutContestInput>
    deleteMany?: Enumerable<CodingProblemScalarWhereInput>
  }

  export type CodingProblemUncheckedUpdateManyWithoutContestNestedInput = {
    create?: XOR<Enumerable<CodingProblemCreateWithoutContestInput>, Enumerable<CodingProblemUncheckedCreateWithoutContestInput>>
    connectOrCreate?: Enumerable<CodingProblemCreateOrConnectWithoutContestInput>
    upsert?: Enumerable<CodingProblemUpsertWithWhereUniqueWithoutContestInput>
    createMany?: CodingProblemCreateManyContestInputEnvelope
    set?: Enumerable<CodingProblemWhereUniqueInput>
    disconnect?: Enumerable<CodingProblemWhereUniqueInput>
    delete?: Enumerable<CodingProblemWhereUniqueInput>
    connect?: Enumerable<CodingProblemWhereUniqueInput>
    update?: Enumerable<CodingProblemUpdateWithWhereUniqueWithoutContestInput>
    updateMany?: Enumerable<CodingProblemUpdateManyWithWhereWithoutContestInput>
    deleteMany?: Enumerable<CodingProblemScalarWhereInput>
  }

  export type EnumJudgeStatusFieldUpdateOperationsInput = {
    set?: JudgeStatus
  }

  export type CodingProblemCreateNestedOneWithoutTestCasesInput = {
    create?: XOR<CodingProblemCreateWithoutTestCasesInput, CodingProblemUncheckedCreateWithoutTestCasesInput>
    connectOrCreate?: CodingProblemCreateOrConnectWithoutTestCasesInput
    connect?: CodingProblemWhereUniqueInput
  }

  export type CodingProblemUpdateOneRequiredWithoutTestCasesNestedInput = {
    create?: XOR<CodingProblemCreateWithoutTestCasesInput, CodingProblemUncheckedCreateWithoutTestCasesInput>
    connectOrCreate?: CodingProblemCreateOrConnectWithoutTestCasesInput
    upsert?: CodingProblemUpsertWithoutTestCasesInput
    connect?: CodingProblemWhereUniqueInput
    update?: XOR<CodingProblemUpdateWithoutTestCasesInput, CodingProblemUncheckedUpdateWithoutTestCasesInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedEnumadmin_typeFilter = {
    equals?: admin_type
    in?: Enumerable<admin_type>
    notIn?: Enumerable<admin_type>
    not?: NestedEnumadmin_typeFilter | admin_type
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedEnumadmin_typeWithAggregatesFilter = {
    equals?: admin_type
    in?: Enumerable<admin_type>
    notIn?: Enumerable<admin_type>
    not?: NestedEnumadmin_typeWithAggregatesFilter | admin_type
    _count?: NestedIntFilter
    _min?: NestedEnumadmin_typeFilter
    _max?: NestedEnumadmin_typeFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }
  export type NestedJsonNullableFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase>, Exclude<keyof Required<NestedJsonNullableFilterBase>, 'path'>>,
        Required<NestedJsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase>, 'path'>>

  export type NestedJsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type NestedEnumChatSessionTypeFilter = {
    equals?: ChatSessionType
    in?: Enumerable<ChatSessionType>
    notIn?: Enumerable<ChatSessionType>
    not?: NestedEnumChatSessionTypeFilter | ChatSessionType
  }
  export type NestedJsonFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase>, Exclude<keyof Required<NestedJsonFilterBase>, 'path'>>,
        Required<NestedJsonFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase>, 'path'>>

  export type NestedJsonFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type NestedEnumChatSessionTypeWithAggregatesFilter = {
    equals?: ChatSessionType
    in?: Enumerable<ChatSessionType>
    notIn?: Enumerable<ChatSessionType>
    not?: NestedEnumChatSessionTypeWithAggregatesFilter | ChatSessionType
    _count?: NestedIntFilter
    _min?: NestedEnumChatSessionTypeFilter
    _max?: NestedEnumChatSessionTypeFilter
  }

  export type NestedEnumProblemRuleTypeFilter = {
    equals?: ProblemRuleType
    in?: Enumerable<ProblemRuleType>
    notIn?: Enumerable<ProblemRuleType>
    not?: NestedEnumProblemRuleTypeFilter | ProblemRuleType
  }

  export type NestedEnumProblemRuleTypeWithAggregatesFilter = {
    equals?: ProblemRuleType
    in?: Enumerable<ProblemRuleType>
    notIn?: Enumerable<ProblemRuleType>
    not?: NestedEnumProblemRuleTypeWithAggregatesFilter | ProblemRuleType
    _count?: NestedIntFilter
    _min?: NestedEnumProblemRuleTypeFilter
    _max?: NestedEnumProblemRuleTypeFilter
  }

  export type NestedEnumJudgeStatusFilter = {
    equals?: JudgeStatus
    in?: Enumerable<JudgeStatus>
    notIn?: Enumerable<JudgeStatus>
    not?: NestedEnumJudgeStatusFilter | JudgeStatus
  }

  export type NestedEnumJudgeStatusWithAggregatesFilter = {
    equals?: JudgeStatus
    in?: Enumerable<JudgeStatus>
    notIn?: Enumerable<JudgeStatus>
    not?: NestedEnumJudgeStatusWithAggregatesFilter | JudgeStatus
    _count?: NestedIntFilter
    _min?: NestedEnumJudgeStatusFilter
    _max?: NestedEnumJudgeStatusFilter
  }

  export type AuthorCodingProblemCreateWithoutUserInput = {
    codingProblem: CodingProblemCreateNestedOneWithoutAuthorsInput
  }

  export type AuthorCodingProblemUncheckedCreateWithoutUserInput = {
    codingProblemId: string
  }

  export type AuthorCodingProblemCreateOrConnectWithoutUserInput = {
    where: AuthorCodingProblemWhereUniqueInput
    create: XOR<AuthorCodingProblemCreateWithoutUserInput, AuthorCodingProblemUncheckedCreateWithoutUserInput>
  }

  export type AuthorCodingProblemCreateManyUserInputEnvelope = {
    data: Enumerable<AuthorCodingProblemCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type AuthorMathProblemCreateWithoutUserInput = {
    mathProblem: MathProblemCreateNestedOneWithoutAuthorsInput
  }

  export type AuthorMathProblemUncheckedCreateWithoutUserInput = {
    mathProblemId: string
  }

  export type AuthorMathProblemCreateOrConnectWithoutUserInput = {
    where: AuthorMathProblemWhereUniqueInput
    create: XOR<AuthorMathProblemCreateWithoutUserInput, AuthorMathProblemUncheckedCreateWithoutUserInput>
  }

  export type AuthorMathProblemCreateManyUserInputEnvelope = {
    data: Enumerable<AuthorMathProblemCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ThreadCreateWithoutAuthorInput = {
    id: string
    parentId?: string | null
    title: string
    summary: string
    published: boolean
    createdAt?: Date | string
    lastUpdateAt?: Date | string
    publishedAt?: Date | string
    content: string
    totalComments?: number
    totalRootComments?: number
    likes?: number
    views?: number
    comments?: CommentCreateNestedManyWithoutThreadInput
    category?: ThreadCategoryCreateNestedOneWithoutThreadsInput
    tags?: ThreadTagRelCreateNestedManyWithoutThreadInput
    userLikes?: UserLikeThreadCreateNestedManyWithoutThreadInput
  }

  export type ThreadUncheckedCreateWithoutAuthorInput = {
    id: string
    parentId?: string | null
    title: string
    summary: string
    published: boolean
    createdAt?: Date | string
    lastUpdateAt?: Date | string
    publishedAt?: Date | string
    content: string
    totalComments?: number
    totalRootComments?: number
    likes?: number
    views?: number
    categoryId?: number | null
    comments?: CommentUncheckedCreateNestedManyWithoutThreadInput
    tags?: ThreadTagRelUncheckedCreateNestedManyWithoutThreadInput
    userLikes?: UserLikeThreadUncheckedCreateNestedManyWithoutThreadInput
  }

  export type ThreadCreateOrConnectWithoutAuthorInput = {
    where: ThreadWhereUniqueInput
    create: XOR<ThreadCreateWithoutAuthorInput, ThreadUncheckedCreateWithoutAuthorInput>
  }

  export type ThreadCreateManyAuthorInputEnvelope = {
    data: Enumerable<ThreadCreateManyAuthorInput>
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutCreatorInput = {
    id: string
    parentId?: string | null
    rootId: string
    totalChildren?: number
    depth?: number
    likes?: number
    parentUsername?: string | null
    published?: boolean
    createdAt?: Date | string
    content: string
    thread: ThreadCreateNestedOneWithoutCommentsInput
    usersLiked?: UserLikeCommentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutCreatorInput = {
    id: string
    threadId: string
    parentId?: string | null
    rootId: string
    totalChildren?: number
    depth?: number
    likes?: number
    parentUsername?: string | null
    published?: boolean
    createdAt?: Date | string
    content: string
    usersLiked?: UserLikeCommentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutCreatorInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutCreatorInput, CommentUncheckedCreateWithoutCreatorInput>
  }

  export type CommentCreateManyCreatorInputEnvelope = {
    data: Enumerable<CommentCreateManyCreatorInput>
    skipDuplicates?: boolean
  }

  export type UserLikeThreadCreateWithoutUserInput = {
    disable?: boolean
    thread: ThreadCreateNestedOneWithoutUserLikesInput
  }

  export type UserLikeThreadUncheckedCreateWithoutUserInput = {
    threadId: string
    disable?: boolean
  }

  export type UserLikeThreadCreateOrConnectWithoutUserInput = {
    where: UserLikeThreadWhereUniqueInput
    create: XOR<UserLikeThreadCreateWithoutUserInput, UserLikeThreadUncheckedCreateWithoutUserInput>
  }

  export type UserLikeThreadCreateManyUserInputEnvelope = {
    data: Enumerable<UserLikeThreadCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserLikeCommentCreateWithoutUserInput = {
    disable?: boolean
    comment: CommentCreateNestedOneWithoutUsersLikedInput
  }

  export type UserLikeCommentUncheckedCreateWithoutUserInput = {
    commentId: string
    disable?: boolean
  }

  export type UserLikeCommentCreateOrConnectWithoutUserInput = {
    where: UserLikeCommentWhereUniqueInput
    create: XOR<UserLikeCommentCreateWithoutUserInput, UserLikeCommentUncheckedCreateWithoutUserInput>
  }

  export type UserLikeCommentCreateManyUserInputEnvelope = {
    data: Enumerable<UserLikeCommentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserProfileCreateWithoutUserInput = {
    id?: string
    real_name?: string | null
    avatar?: string | null
    blog?: string | null
    github?: string | null
    school?: string | null
    major?: string | null
    language?: string | null
    accepted_number?: number | null
    total_score?: number | null
    total_practice_score?: number | null
    submission_number?: number | null
    rating?: number | null
  }

  export type UserProfileUncheckedCreateWithoutUserInput = {
    id?: string
    real_name?: string | null
    avatar?: string | null
    blog?: string | null
    github?: string | null
    school?: string | null
    major?: string | null
    language?: string | null
    accepted_number?: number | null
    total_score?: number | null
    total_practice_score?: number | null
    submission_number?: number | null
    rating?: number | null
  }

  export type UserProfileCreateOrConnectWithoutUserInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
  }

  export type MathNoteCreateWithoutCreatorInput = {
    content: string
    createdAt?: Date | string
    imageLink?: string | null
    mathProblem: MathProblemCreateNestedOneWithoutMathNotesInput
  }

  export type MathNoteUncheckedCreateWithoutCreatorInput = {
    content: string
    mathProblemId: string
    createdAt?: Date | string
    imageLink?: string | null
  }

  export type MathNoteCreateOrConnectWithoutCreatorInput = {
    where: MathNoteWhereUniqueInput
    create: XOR<MathNoteCreateWithoutCreatorInput, MathNoteUncheckedCreateWithoutCreatorInput>
  }

  export type MathNoteCreateManyCreatorInputEnvelope = {
    data: Enumerable<MathNoteCreateManyCreatorInput>
    skipDuplicates?: boolean
  }

  export type MathSolutionCreateWithoutCreatorInput = {
    content: string
    createdAt?: Date | string
    checked?: boolean
    imageLink?: string | null
    mathProblem: MathProblemCreateNestedOneWithoutMathSolutionsInput
  }

  export type MathSolutionUncheckedCreateWithoutCreatorInput = {
    content: string
    mathProblemId: string
    createdAt?: Date | string
    checked?: boolean
    imageLink?: string | null
  }

  export type MathSolutionCreateOrConnectWithoutCreatorInput = {
    where: MathSolutionWhereUniqueInput
    create: XOR<MathSolutionCreateWithoutCreatorInput, MathSolutionUncheckedCreateWithoutCreatorInput>
  }

  export type MathSolutionCreateManyCreatorInputEnvelope = {
    data: Enumerable<MathSolutionCreateManyCreatorInput>
    skipDuplicates?: boolean
  }

  export type MathProblemSetCreateWithoutCreatorInput = {
    id: string
    title: string
    numberProb: number
    problems?: MathSetProbRelCreateNestedManyWithoutMathProbSetInput
  }

  export type MathProblemSetUncheckedCreateWithoutCreatorInput = {
    id: string
    title: string
    numberProb: number
    problems?: MathSetProbRelUncheckedCreateNestedManyWithoutMathProbSetInput
  }

  export type MathProblemSetCreateOrConnectWithoutCreatorInput = {
    where: MathProblemSetWhereUniqueInput
    create: XOR<MathProblemSetCreateWithoutCreatorInput, MathProblemSetUncheckedCreateWithoutCreatorInput>
  }

  export type MathProblemSetCreateManyCreatorInputEnvelope = {
    data: Enumerable<MathProblemSetCreateManyCreatorInput>
    skipDuplicates?: boolean
  }

  export type FriendRequestCreateWithoutSenderInput = {
    id?: string
    disable?: boolean
    reciever: UserCreateNestedOneWithoutOtherFriendReqsInput
  }

  export type FriendRequestUncheckedCreateWithoutSenderInput = {
    id?: string
    recieverId: string
    disable?: boolean
  }

  export type FriendRequestCreateOrConnectWithoutSenderInput = {
    where: FriendRequestWhereUniqueInput
    create: XOR<FriendRequestCreateWithoutSenderInput, FriendRequestUncheckedCreateWithoutSenderInput>
  }

  export type FriendRequestCreateManySenderInputEnvelope = {
    data: Enumerable<FriendRequestCreateManySenderInput>
    skipDuplicates?: boolean
  }

  export type FriendRequestCreateWithoutRecieverInput = {
    id?: string
    disable?: boolean
    sender: UserCreateNestedOneWithoutMyFriendReqsInput
  }

  export type FriendRequestUncheckedCreateWithoutRecieverInput = {
    id?: string
    senderId: string
    disable?: boolean
  }

  export type FriendRequestCreateOrConnectWithoutRecieverInput = {
    where: FriendRequestWhereUniqueInput
    create: XOR<FriendRequestCreateWithoutRecieverInput, FriendRequestUncheckedCreateWithoutRecieverInput>
  }

  export type FriendRequestCreateManyRecieverInputEnvelope = {
    data: Enumerable<FriendRequestCreateManyRecieverInput>
    skipDuplicates?: boolean
  }

  export type GroupCreateWithoutCreatorInput = {
    id?: string
    name: string
    generalChatSessionId?: string | null
    createdAt?: Date | string
    users?: UserGroupRelCreateNestedManyWithoutGroupInput
    posts?: GroupPostCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    generalChatSessionId?: string | null
    createdAt?: Date | string
    users?: UserGroupRelUncheckedCreateNestedManyWithoutGroupInput
    posts?: GroupPostUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutCreatorInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutCreatorInput, GroupUncheckedCreateWithoutCreatorInput>
  }

  export type GroupCreateManyCreatorInputEnvelope = {
    data: Enumerable<GroupCreateManyCreatorInput>
    skipDuplicates?: boolean
  }

  export type UserGroupRelCreateWithoutUserInput = {
    joinedAt: Date | string
    group: GroupCreateNestedOneWithoutUsersInput
  }

  export type UserGroupRelUncheckedCreateWithoutUserInput = {
    groupId: string
    joinedAt: Date | string
  }

  export type UserGroupRelCreateOrConnectWithoutUserInput = {
    where: UserGroupRelWhereUniqueInput
    create: XOR<UserGroupRelCreateWithoutUserInput, UserGroupRelUncheckedCreateWithoutUserInput>
  }

  export type UserGroupRelCreateManyUserInputEnvelope = {
    data: Enumerable<UserGroupRelCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type GroupPostCreateWithoutAuthorInput = {
    id: string
    content: string
    createdAt?: Date | string
    title: string
    group: GroupCreateNestedOneWithoutPostsInput
    messages?: GroupPostMessageCreateNestedManyWithoutPostInput
  }

  export type GroupPostUncheckedCreateWithoutAuthorInput = {
    id: string
    content: string
    createdAt?: Date | string
    groupId: string
    title: string
    messages?: GroupPostMessageUncheckedCreateNestedManyWithoutPostInput
  }

  export type GroupPostCreateOrConnectWithoutAuthorInput = {
    where: GroupPostWhereUniqueInput
    create: XOR<GroupPostCreateWithoutAuthorInput, GroupPostUncheckedCreateWithoutAuthorInput>
  }

  export type GroupPostCreateManyAuthorInputEnvelope = {
    data: Enumerable<GroupPostCreateManyAuthorInput>
    skipDuplicates?: boolean
  }

  export type ChatMessageCreateWithoutAuthorInput = {
    id: string
    content: string
    createdAt?: Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
    chatSession: ChatSessionCreateNestedOneWithoutChatMessagesInput
  }

  export type ChatMessageUncheckedCreateWithoutAuthorInput = {
    id: string
    content: string
    createdAt?: Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
    sessionId: string
  }

  export type ChatMessageCreateOrConnectWithoutAuthorInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutAuthorInput, ChatMessageUncheckedCreateWithoutAuthorInput>
  }

  export type ChatMessageCreateManyAuthorInputEnvelope = {
    data: Enumerable<ChatMessageCreateManyAuthorInput>
    skipDuplicates?: boolean
  }

  export type ChatSessionUserCreateWithoutUserInput = {
    unseenCnt?: number
    joinedAt: Date | string
    chatSession: ChatSessionCreateNestedOneWithoutUsersInput
  }

  export type ChatSessionUserUncheckedCreateWithoutUserInput = {
    sessionId: string
    unseenCnt?: number
    joinedAt: Date | string
  }

  export type ChatSessionUserCreateOrConnectWithoutUserInput = {
    where: ChatSessionUserWhereUniqueInput
    create: XOR<ChatSessionUserCreateWithoutUserInput, ChatSessionUserUncheckedCreateWithoutUserInput>
  }

  export type ChatSessionUserCreateManyUserInputEnvelope = {
    data: Enumerable<ChatSessionUserCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type GroupPostMessageCreateWithoutAuthorInput = {
    id: string
    content: string
    createdAt?: Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
    post: GroupPostCreateNestedOneWithoutMessagesInput
  }

  export type GroupPostMessageUncheckedCreateWithoutAuthorInput = {
    id: string
    content: string
    createdAt?: Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
    postId: string
  }

  export type GroupPostMessageCreateOrConnectWithoutAuthorInput = {
    where: GroupPostMessageWhereUniqueInput
    create: XOR<GroupPostMessageCreateWithoutAuthorInput, GroupPostMessageUncheckedCreateWithoutAuthorInput>
  }

  export type GroupPostMessageCreateManyAuthorInputEnvelope = {
    data: Enumerable<GroupPostMessageCreateManyAuthorInput>
    skipDuplicates?: boolean
  }

  export type AuthorCodingProblemUpsertWithWhereUniqueWithoutUserInput = {
    where: AuthorCodingProblemWhereUniqueInput
    update: XOR<AuthorCodingProblemUpdateWithoutUserInput, AuthorCodingProblemUncheckedUpdateWithoutUserInput>
    create: XOR<AuthorCodingProblemCreateWithoutUserInput, AuthorCodingProblemUncheckedCreateWithoutUserInput>
  }

  export type AuthorCodingProblemUpdateWithWhereUniqueWithoutUserInput = {
    where: AuthorCodingProblemWhereUniqueInput
    data: XOR<AuthorCodingProblemUpdateWithoutUserInput, AuthorCodingProblemUncheckedUpdateWithoutUserInput>
  }

  export type AuthorCodingProblemUpdateManyWithWhereWithoutUserInput = {
    where: AuthorCodingProblemScalarWhereInput
    data: XOR<AuthorCodingProblemUpdateManyMutationInput, AuthorCodingProblemUncheckedUpdateManyWithoutCodingProblemsInput>
  }

  export type AuthorCodingProblemScalarWhereInput = {
    AND?: Enumerable<AuthorCodingProblemScalarWhereInput>
    OR?: Enumerable<AuthorCodingProblemScalarWhereInput>
    NOT?: Enumerable<AuthorCodingProblemScalarWhereInput>
    username?: StringFilter | string
    codingProblemId?: StringFilter | string
  }

  export type AuthorMathProblemUpsertWithWhereUniqueWithoutUserInput = {
    where: AuthorMathProblemWhereUniqueInput
    update: XOR<AuthorMathProblemUpdateWithoutUserInput, AuthorMathProblemUncheckedUpdateWithoutUserInput>
    create: XOR<AuthorMathProblemCreateWithoutUserInput, AuthorMathProblemUncheckedCreateWithoutUserInput>
  }

  export type AuthorMathProblemUpdateWithWhereUniqueWithoutUserInput = {
    where: AuthorMathProblemWhereUniqueInput
    data: XOR<AuthorMathProblemUpdateWithoutUserInput, AuthorMathProblemUncheckedUpdateWithoutUserInput>
  }

  export type AuthorMathProblemUpdateManyWithWhereWithoutUserInput = {
    where: AuthorMathProblemScalarWhereInput
    data: XOR<AuthorMathProblemUpdateManyMutationInput, AuthorMathProblemUncheckedUpdateManyWithoutAuthorMathProblemsInput>
  }

  export type AuthorMathProblemScalarWhereInput = {
    AND?: Enumerable<AuthorMathProblemScalarWhereInput>
    OR?: Enumerable<AuthorMathProblemScalarWhereInput>
    NOT?: Enumerable<AuthorMathProblemScalarWhereInput>
    username?: StringFilter | string
    mathProblemId?: StringFilter | string
  }

  export type ThreadUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ThreadWhereUniqueInput
    update: XOR<ThreadUpdateWithoutAuthorInput, ThreadUncheckedUpdateWithoutAuthorInput>
    create: XOR<ThreadCreateWithoutAuthorInput, ThreadUncheckedCreateWithoutAuthorInput>
  }

  export type ThreadUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ThreadWhereUniqueInput
    data: XOR<ThreadUpdateWithoutAuthorInput, ThreadUncheckedUpdateWithoutAuthorInput>
  }

  export type ThreadUpdateManyWithWhereWithoutAuthorInput = {
    where: ThreadScalarWhereInput
    data: XOR<ThreadUpdateManyMutationInput, ThreadUncheckedUpdateManyWithoutThreadsInput>
  }

  export type ThreadScalarWhereInput = {
    AND?: Enumerable<ThreadScalarWhereInput>
    OR?: Enumerable<ThreadScalarWhereInput>
    NOT?: Enumerable<ThreadScalarWhereInput>
    id?: StringFilter | string
    authorId?: StringFilter | string
    parentId?: StringNullableFilter | string | null
    title?: StringFilter | string
    summary?: StringFilter | string
    published?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    lastUpdateAt?: DateTimeFilter | Date | string
    publishedAt?: DateTimeFilter | Date | string
    content?: StringFilter | string
    totalComments?: IntFilter | number
    totalRootComments?: IntFilter | number
    likes?: IntFilter | number
    views?: IntFilter | number
    categoryId?: IntNullableFilter | number | null
  }

  export type CommentUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutCreatorInput, CommentUncheckedUpdateWithoutCreatorInput>
    create: XOR<CommentCreateWithoutCreatorInput, CommentUncheckedCreateWithoutCreatorInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutCreatorInput, CommentUncheckedUpdateWithoutCreatorInput>
  }

  export type CommentUpdateManyWithWhereWithoutCreatorInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutCommentsInput>
  }

  export type CommentScalarWhereInput = {
    AND?: Enumerable<CommentScalarWhereInput>
    OR?: Enumerable<CommentScalarWhereInput>
    NOT?: Enumerable<CommentScalarWhereInput>
    id?: StringFilter | string
    threadId?: StringFilter | string
    parentId?: StringNullableFilter | string | null
    rootId?: StringFilter | string
    totalChildren?: IntFilter | number
    depth?: IntFilter | number
    likes?: IntFilter | number
    parentUsername?: StringNullableFilter | string | null
    creatorId?: StringFilter | string
    published?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    content?: StringFilter | string
  }

  export type UserLikeThreadUpsertWithWhereUniqueWithoutUserInput = {
    where: UserLikeThreadWhereUniqueInput
    update: XOR<UserLikeThreadUpdateWithoutUserInput, UserLikeThreadUncheckedUpdateWithoutUserInput>
    create: XOR<UserLikeThreadCreateWithoutUserInput, UserLikeThreadUncheckedCreateWithoutUserInput>
  }

  export type UserLikeThreadUpdateWithWhereUniqueWithoutUserInput = {
    where: UserLikeThreadWhereUniqueInput
    data: XOR<UserLikeThreadUpdateWithoutUserInput, UserLikeThreadUncheckedUpdateWithoutUserInput>
  }

  export type UserLikeThreadUpdateManyWithWhereWithoutUserInput = {
    where: UserLikeThreadScalarWhereInput
    data: XOR<UserLikeThreadUpdateManyMutationInput, UserLikeThreadUncheckedUpdateManyWithoutThreadLikedInput>
  }

  export type UserLikeThreadScalarWhereInput = {
    AND?: Enumerable<UserLikeThreadScalarWhereInput>
    OR?: Enumerable<UserLikeThreadScalarWhereInput>
    NOT?: Enumerable<UserLikeThreadScalarWhereInput>
    username?: StringFilter | string
    threadId?: StringFilter | string
    disable?: BoolFilter | boolean
  }

  export type UserLikeCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: UserLikeCommentWhereUniqueInput
    update: XOR<UserLikeCommentUpdateWithoutUserInput, UserLikeCommentUncheckedUpdateWithoutUserInput>
    create: XOR<UserLikeCommentCreateWithoutUserInput, UserLikeCommentUncheckedCreateWithoutUserInput>
  }

  export type UserLikeCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: UserLikeCommentWhereUniqueInput
    data: XOR<UserLikeCommentUpdateWithoutUserInput, UserLikeCommentUncheckedUpdateWithoutUserInput>
  }

  export type UserLikeCommentUpdateManyWithWhereWithoutUserInput = {
    where: UserLikeCommentScalarWhereInput
    data: XOR<UserLikeCommentUpdateManyMutationInput, UserLikeCommentUncheckedUpdateManyWithoutCommentLikedInput>
  }

  export type UserLikeCommentScalarWhereInput = {
    AND?: Enumerable<UserLikeCommentScalarWhereInput>
    OR?: Enumerable<UserLikeCommentScalarWhereInput>
    NOT?: Enumerable<UserLikeCommentScalarWhereInput>
    username?: StringFilter | string
    commentId?: StringFilter | string
    disable?: BoolFilter | boolean
  }

  export type UserProfileUpsertWithoutUserInput = {
    update: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
  }

  export type UserProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    real_name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    blog?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    accepted_number?: NullableIntFieldUpdateOperationsInput | number | null
    total_score?: NullableIntFieldUpdateOperationsInput | number | null
    total_practice_score?: NullableIntFieldUpdateOperationsInput | number | null
    submission_number?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    real_name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    blog?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    major?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    accepted_number?: NullableIntFieldUpdateOperationsInput | number | null
    total_score?: NullableIntFieldUpdateOperationsInput | number | null
    total_practice_score?: NullableIntFieldUpdateOperationsInput | number | null
    submission_number?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MathNoteUpsertWithWhereUniqueWithoutCreatorInput = {
    where: MathNoteWhereUniqueInput
    update: XOR<MathNoteUpdateWithoutCreatorInput, MathNoteUncheckedUpdateWithoutCreatorInput>
    create: XOR<MathNoteCreateWithoutCreatorInput, MathNoteUncheckedCreateWithoutCreatorInput>
  }

  export type MathNoteUpdateWithWhereUniqueWithoutCreatorInput = {
    where: MathNoteWhereUniqueInput
    data: XOR<MathNoteUpdateWithoutCreatorInput, MathNoteUncheckedUpdateWithoutCreatorInput>
  }

  export type MathNoteUpdateManyWithWhereWithoutCreatorInput = {
    where: MathNoteScalarWhereInput
    data: XOR<MathNoteUpdateManyMutationInput, MathNoteUncheckedUpdateManyWithoutMathNotesInput>
  }

  export type MathNoteScalarWhereInput = {
    AND?: Enumerable<MathNoteScalarWhereInput>
    OR?: Enumerable<MathNoteScalarWhereInput>
    NOT?: Enumerable<MathNoteScalarWhereInput>
    creatorId?: StringFilter | string
    content?: StringFilter | string
    mathProblemId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    imageLink?: StringNullableFilter | string | null
  }

  export type MathSolutionUpsertWithWhereUniqueWithoutCreatorInput = {
    where: MathSolutionWhereUniqueInput
    update: XOR<MathSolutionUpdateWithoutCreatorInput, MathSolutionUncheckedUpdateWithoutCreatorInput>
    create: XOR<MathSolutionCreateWithoutCreatorInput, MathSolutionUncheckedCreateWithoutCreatorInput>
  }

  export type MathSolutionUpdateWithWhereUniqueWithoutCreatorInput = {
    where: MathSolutionWhereUniqueInput
    data: XOR<MathSolutionUpdateWithoutCreatorInput, MathSolutionUncheckedUpdateWithoutCreatorInput>
  }

  export type MathSolutionUpdateManyWithWhereWithoutCreatorInput = {
    where: MathSolutionScalarWhereInput
    data: XOR<MathSolutionUpdateManyMutationInput, MathSolutionUncheckedUpdateManyWithoutMathSolutionsInput>
  }

  export type MathSolutionScalarWhereInput = {
    AND?: Enumerable<MathSolutionScalarWhereInput>
    OR?: Enumerable<MathSolutionScalarWhereInput>
    NOT?: Enumerable<MathSolutionScalarWhereInput>
    creatorId?: StringFilter | string
    content?: StringFilter | string
    mathProblemId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    checked?: BoolFilter | boolean
    imageLink?: StringNullableFilter | string | null
  }

  export type MathProblemSetUpsertWithWhereUniqueWithoutCreatorInput = {
    where: MathProblemSetWhereUniqueInput
    update: XOR<MathProblemSetUpdateWithoutCreatorInput, MathProblemSetUncheckedUpdateWithoutCreatorInput>
    create: XOR<MathProblemSetCreateWithoutCreatorInput, MathProblemSetUncheckedCreateWithoutCreatorInput>
  }

  export type MathProblemSetUpdateWithWhereUniqueWithoutCreatorInput = {
    where: MathProblemSetWhereUniqueInput
    data: XOR<MathProblemSetUpdateWithoutCreatorInput, MathProblemSetUncheckedUpdateWithoutCreatorInput>
  }

  export type MathProblemSetUpdateManyWithWhereWithoutCreatorInput = {
    where: MathProblemSetScalarWhereInput
    data: XOR<MathProblemSetUpdateManyMutationInput, MathProblemSetUncheckedUpdateManyWithoutMathProbSetListInput>
  }

  export type MathProblemSetScalarWhereInput = {
    AND?: Enumerable<MathProblemSetScalarWhereInput>
    OR?: Enumerable<MathProblemSetScalarWhereInput>
    NOT?: Enumerable<MathProblemSetScalarWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    creatorId?: StringFilter | string
    numberProb?: IntFilter | number
  }

  export type FriendRequestUpsertWithWhereUniqueWithoutSenderInput = {
    where: FriendRequestWhereUniqueInput
    update: XOR<FriendRequestUpdateWithoutSenderInput, FriendRequestUncheckedUpdateWithoutSenderInput>
    create: XOR<FriendRequestCreateWithoutSenderInput, FriendRequestUncheckedCreateWithoutSenderInput>
  }

  export type FriendRequestUpdateWithWhereUniqueWithoutSenderInput = {
    where: FriendRequestWhereUniqueInput
    data: XOR<FriendRequestUpdateWithoutSenderInput, FriendRequestUncheckedUpdateWithoutSenderInput>
  }

  export type FriendRequestUpdateManyWithWhereWithoutSenderInput = {
    where: FriendRequestScalarWhereInput
    data: XOR<FriendRequestUpdateManyMutationInput, FriendRequestUncheckedUpdateManyWithoutMyFriendReqsInput>
  }

  export type FriendRequestScalarWhereInput = {
    AND?: Enumerable<FriendRequestScalarWhereInput>
    OR?: Enumerable<FriendRequestScalarWhereInput>
    NOT?: Enumerable<FriendRequestScalarWhereInput>
    id?: StringFilter | string
    senderId?: StringFilter | string
    recieverId?: StringFilter | string
    disable?: BoolFilter | boolean
  }

  export type FriendRequestUpsertWithWhereUniqueWithoutRecieverInput = {
    where: FriendRequestWhereUniqueInput
    update: XOR<FriendRequestUpdateWithoutRecieverInput, FriendRequestUncheckedUpdateWithoutRecieverInput>
    create: XOR<FriendRequestCreateWithoutRecieverInput, FriendRequestUncheckedCreateWithoutRecieverInput>
  }

  export type FriendRequestUpdateWithWhereUniqueWithoutRecieverInput = {
    where: FriendRequestWhereUniqueInput
    data: XOR<FriendRequestUpdateWithoutRecieverInput, FriendRequestUncheckedUpdateWithoutRecieverInput>
  }

  export type FriendRequestUpdateManyWithWhereWithoutRecieverInput = {
    where: FriendRequestScalarWhereInput
    data: XOR<FriendRequestUpdateManyMutationInput, FriendRequestUncheckedUpdateManyWithoutOtherFriendReqsInput>
  }

  export type GroupUpsertWithWhereUniqueWithoutCreatorInput = {
    where: GroupWhereUniqueInput
    update: XOR<GroupUpdateWithoutCreatorInput, GroupUncheckedUpdateWithoutCreatorInput>
    create: XOR<GroupCreateWithoutCreatorInput, GroupUncheckedCreateWithoutCreatorInput>
  }

  export type GroupUpdateWithWhereUniqueWithoutCreatorInput = {
    where: GroupWhereUniqueInput
    data: XOR<GroupUpdateWithoutCreatorInput, GroupUncheckedUpdateWithoutCreatorInput>
  }

  export type GroupUpdateManyWithWhereWithoutCreatorInput = {
    where: GroupScalarWhereInput
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyWithoutCreatedGroupInput>
  }

  export type GroupScalarWhereInput = {
    AND?: Enumerable<GroupScalarWhereInput>
    OR?: Enumerable<GroupScalarWhereInput>
    NOT?: Enumerable<GroupScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    creatorId?: StringFilter | string
    generalChatSessionId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
  }

  export type UserGroupRelUpsertWithWhereUniqueWithoutUserInput = {
    where: UserGroupRelWhereUniqueInput
    update: XOR<UserGroupRelUpdateWithoutUserInput, UserGroupRelUncheckedUpdateWithoutUserInput>
    create: XOR<UserGroupRelCreateWithoutUserInput, UserGroupRelUncheckedCreateWithoutUserInput>
  }

  export type UserGroupRelUpdateWithWhereUniqueWithoutUserInput = {
    where: UserGroupRelWhereUniqueInput
    data: XOR<UserGroupRelUpdateWithoutUserInput, UserGroupRelUncheckedUpdateWithoutUserInput>
  }

  export type UserGroupRelUpdateManyWithWhereWithoutUserInput = {
    where: UserGroupRelScalarWhereInput
    data: XOR<UserGroupRelUpdateManyMutationInput, UserGroupRelUncheckedUpdateManyWithoutJoinedGroupsInput>
  }

  export type UserGroupRelScalarWhereInput = {
    AND?: Enumerable<UserGroupRelScalarWhereInput>
    OR?: Enumerable<UserGroupRelScalarWhereInput>
    NOT?: Enumerable<UserGroupRelScalarWhereInput>
    username?: StringFilter | string
    groupId?: StringFilter | string
    joinedAt?: DateTimeFilter | Date | string
  }

  export type GroupPostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: GroupPostWhereUniqueInput
    update: XOR<GroupPostUpdateWithoutAuthorInput, GroupPostUncheckedUpdateWithoutAuthorInput>
    create: XOR<GroupPostCreateWithoutAuthorInput, GroupPostUncheckedCreateWithoutAuthorInput>
  }

  export type GroupPostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: GroupPostWhereUniqueInput
    data: XOR<GroupPostUpdateWithoutAuthorInput, GroupPostUncheckedUpdateWithoutAuthorInput>
  }

  export type GroupPostUpdateManyWithWhereWithoutAuthorInput = {
    where: GroupPostScalarWhereInput
    data: XOR<GroupPostUpdateManyMutationInput, GroupPostUncheckedUpdateManyWithoutPostsInput>
  }

  export type GroupPostScalarWhereInput = {
    AND?: Enumerable<GroupPostScalarWhereInput>
    OR?: Enumerable<GroupPostScalarWhereInput>
    NOT?: Enumerable<GroupPostScalarWhereInput>
    id?: StringFilter | string
    content?: StringFilter | string
    authorId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    groupId?: StringFilter | string
    title?: StringFilter | string
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutAuthorInput, ChatMessageUncheckedUpdateWithoutAuthorInput>
    create: XOR<ChatMessageCreateWithoutAuthorInput, ChatMessageUncheckedCreateWithoutAuthorInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutAuthorInput, ChatMessageUncheckedUpdateWithoutAuthorInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutAuthorInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutChatMessagesInput>
  }

  export type ChatMessageScalarWhereInput = {
    AND?: Enumerable<ChatMessageScalarWhereInput>
    OR?: Enumerable<ChatMessageScalarWhereInput>
    NOT?: Enumerable<ChatMessageScalarWhereInput>
    id?: StringFilter | string
    content?: StringFilter | string
    authorId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    referenceMessage?: JsonNullableFilter
    sessionId?: StringFilter | string
  }

  export type ChatSessionUserUpsertWithWhereUniqueWithoutUserInput = {
    where: ChatSessionUserWhereUniqueInput
    update: XOR<ChatSessionUserUpdateWithoutUserInput, ChatSessionUserUncheckedUpdateWithoutUserInput>
    create: XOR<ChatSessionUserCreateWithoutUserInput, ChatSessionUserUncheckedCreateWithoutUserInput>
  }

  export type ChatSessionUserUpdateWithWhereUniqueWithoutUserInput = {
    where: ChatSessionUserWhereUniqueInput
    data: XOR<ChatSessionUserUpdateWithoutUserInput, ChatSessionUserUncheckedUpdateWithoutUserInput>
  }

  export type ChatSessionUserUpdateManyWithWhereWithoutUserInput = {
    where: ChatSessionUserScalarWhereInput
    data: XOR<ChatSessionUserUpdateManyMutationInput, ChatSessionUserUncheckedUpdateManyWithoutChatSessionsInput>
  }

  export type ChatSessionUserScalarWhereInput = {
    AND?: Enumerable<ChatSessionUserScalarWhereInput>
    OR?: Enumerable<ChatSessionUserScalarWhereInput>
    NOT?: Enumerable<ChatSessionUserScalarWhereInput>
    sessionId?: StringFilter | string
    username?: StringFilter | string
    unseenCnt?: IntFilter | number
    joinedAt?: DateTimeFilter | Date | string
  }

  export type GroupPostMessageUpsertWithWhereUniqueWithoutAuthorInput = {
    where: GroupPostMessageWhereUniqueInput
    update: XOR<GroupPostMessageUpdateWithoutAuthorInput, GroupPostMessageUncheckedUpdateWithoutAuthorInput>
    create: XOR<GroupPostMessageCreateWithoutAuthorInput, GroupPostMessageUncheckedCreateWithoutAuthorInput>
  }

  export type GroupPostMessageUpdateWithWhereUniqueWithoutAuthorInput = {
    where: GroupPostMessageWhereUniqueInput
    data: XOR<GroupPostMessageUpdateWithoutAuthorInput, GroupPostMessageUncheckedUpdateWithoutAuthorInput>
  }

  export type GroupPostMessageUpdateManyWithWhereWithoutAuthorInput = {
    where: GroupPostMessageScalarWhereInput
    data: XOR<GroupPostMessageUpdateManyMutationInput, GroupPostMessageUncheckedUpdateManyWithoutGroupPostMessagesInput>
  }

  export type GroupPostMessageScalarWhereInput = {
    AND?: Enumerable<GroupPostMessageScalarWhereInput>
    OR?: Enumerable<GroupPostMessageScalarWhereInput>
    NOT?: Enumerable<GroupPostMessageScalarWhereInput>
    id?: StringFilter | string
    content?: StringFilter | string
    authorId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    referenceMessage?: JsonNullableFilter
    postId?: StringFilter | string
  }

  export type UserCreateWithoutMyFriendReqsInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemCreateNestedManyWithoutUserInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetCreateNestedManyWithoutCreatorInput
    otherFriendReqs?: FriendRequestCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelCreateNestedManyWithoutUserInput
    posts?: GroupPostCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutMyFriendReqsInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemUncheckedCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemUncheckedCreateNestedManyWithoutUserInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadUncheckedCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteUncheckedCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionUncheckedCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetUncheckedCreateNestedManyWithoutCreatorInput
    otherFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelUncheckedCreateNestedManyWithoutUserInput
    posts?: GroupPostUncheckedCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserUncheckedCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutMyFriendReqsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMyFriendReqsInput, UserUncheckedCreateWithoutMyFriendReqsInput>
  }

  export type UserCreateWithoutOtherFriendReqsInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemCreateNestedManyWithoutUserInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestCreateNestedManyWithoutSenderInput
    createdGroup?: GroupCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelCreateNestedManyWithoutUserInput
    posts?: GroupPostCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutOtherFriendReqsInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemUncheckedCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemUncheckedCreateNestedManyWithoutUserInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadUncheckedCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteUncheckedCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionUncheckedCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetUncheckedCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutSenderInput
    createdGroup?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelUncheckedCreateNestedManyWithoutUserInput
    posts?: GroupPostUncheckedCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserUncheckedCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutOtherFriendReqsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOtherFriendReqsInput, UserUncheckedCreateWithoutOtherFriendReqsInput>
  }

  export type UserUpsertWithoutMyFriendReqsInput = {
    update: XOR<UserUpdateWithoutMyFriendReqsInput, UserUncheckedUpdateWithoutMyFriendReqsInput>
    create: XOR<UserCreateWithoutMyFriendReqsInput, UserUncheckedCreateWithoutMyFriendReqsInput>
  }

  export type UserUpdateWithoutMyFriendReqsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUpdateManyWithoutUserNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUpdateManyWithoutCreatorNestedInput
    otherFriendReqs?: FriendRequestUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUpdateManyWithoutUserNestedInput
    posts?: GroupPostUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutMyFriendReqsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUncheckedUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUncheckedUpdateManyWithoutUserNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUncheckedUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUncheckedUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUncheckedUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUncheckedUpdateManyWithoutCreatorNestedInput
    otherFriendReqs?: FriendRequestUncheckedUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUncheckedUpdateManyWithoutUserNestedInput
    posts?: GroupPostUncheckedUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUncheckedUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserUpsertWithoutOtherFriendReqsInput = {
    update: XOR<UserUpdateWithoutOtherFriendReqsInput, UserUncheckedUpdateWithoutOtherFriendReqsInput>
    create: XOR<UserCreateWithoutOtherFriendReqsInput, UserUncheckedCreateWithoutOtherFriendReqsInput>
  }

  export type UserUpdateWithoutOtherFriendReqsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUpdateManyWithoutUserNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUpdateManyWithoutSenderNestedInput
    createdGroup?: GroupUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUpdateManyWithoutUserNestedInput
    posts?: GroupPostUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutOtherFriendReqsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUncheckedUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUncheckedUpdateManyWithoutUserNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUncheckedUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUncheckedUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUncheckedUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUncheckedUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUncheckedUpdateManyWithoutSenderNestedInput
    createdGroup?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUncheckedUpdateManyWithoutUserNestedInput
    posts?: GroupPostUncheckedUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUncheckedUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateWithoutCreatedGroupInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemCreateNestedManyWithoutUserInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestCreateNestedManyWithoutRecieverInput
    joinedGroups?: UserGroupRelCreateNestedManyWithoutUserInput
    posts?: GroupPostCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutCreatedGroupInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemUncheckedCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemUncheckedCreateNestedManyWithoutUserInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadUncheckedCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteUncheckedCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionUncheckedCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetUncheckedCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutRecieverInput
    joinedGroups?: UserGroupRelUncheckedCreateNestedManyWithoutUserInput
    posts?: GroupPostUncheckedCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserUncheckedCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutCreatedGroupInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedGroupInput, UserUncheckedCreateWithoutCreatedGroupInput>
  }

  export type UserGroupRelCreateWithoutGroupInput = {
    joinedAt: Date | string
    user: UserCreateNestedOneWithoutJoinedGroupsInput
  }

  export type UserGroupRelUncheckedCreateWithoutGroupInput = {
    username: string
    joinedAt: Date | string
  }

  export type UserGroupRelCreateOrConnectWithoutGroupInput = {
    where: UserGroupRelWhereUniqueInput
    create: XOR<UserGroupRelCreateWithoutGroupInput, UserGroupRelUncheckedCreateWithoutGroupInput>
  }

  export type UserGroupRelCreateManyGroupInputEnvelope = {
    data: Enumerable<UserGroupRelCreateManyGroupInput>
    skipDuplicates?: boolean
  }

  export type GroupPostCreateWithoutGroupInput = {
    id: string
    content: string
    createdAt?: Date | string
    title: string
    author: UserCreateNestedOneWithoutPostsInput
    messages?: GroupPostMessageCreateNestedManyWithoutPostInput
  }

  export type GroupPostUncheckedCreateWithoutGroupInput = {
    id: string
    content: string
    authorId: string
    createdAt?: Date | string
    title: string
    messages?: GroupPostMessageUncheckedCreateNestedManyWithoutPostInput
  }

  export type GroupPostCreateOrConnectWithoutGroupInput = {
    where: GroupPostWhereUniqueInput
    create: XOR<GroupPostCreateWithoutGroupInput, GroupPostUncheckedCreateWithoutGroupInput>
  }

  export type GroupPostCreateManyGroupInputEnvelope = {
    data: Enumerable<GroupPostCreateManyGroupInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedGroupInput = {
    update: XOR<UserUpdateWithoutCreatedGroupInput, UserUncheckedUpdateWithoutCreatedGroupInput>
    create: XOR<UserCreateWithoutCreatedGroupInput, UserUncheckedCreateWithoutCreatedGroupInput>
  }

  export type UserUpdateWithoutCreatedGroupInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUpdateManyWithoutUserNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUpdateManyWithoutRecieverNestedInput
    joinedGroups?: UserGroupRelUpdateManyWithoutUserNestedInput
    posts?: GroupPostUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedGroupInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUncheckedUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUncheckedUpdateManyWithoutUserNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUncheckedUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUncheckedUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUncheckedUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUncheckedUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUncheckedUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUncheckedUpdateManyWithoutRecieverNestedInput
    joinedGroups?: UserGroupRelUncheckedUpdateManyWithoutUserNestedInput
    posts?: GroupPostUncheckedUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUncheckedUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserGroupRelUpsertWithWhereUniqueWithoutGroupInput = {
    where: UserGroupRelWhereUniqueInput
    update: XOR<UserGroupRelUpdateWithoutGroupInput, UserGroupRelUncheckedUpdateWithoutGroupInput>
    create: XOR<UserGroupRelCreateWithoutGroupInput, UserGroupRelUncheckedCreateWithoutGroupInput>
  }

  export type UserGroupRelUpdateWithWhereUniqueWithoutGroupInput = {
    where: UserGroupRelWhereUniqueInput
    data: XOR<UserGroupRelUpdateWithoutGroupInput, UserGroupRelUncheckedUpdateWithoutGroupInput>
  }

  export type UserGroupRelUpdateManyWithWhereWithoutGroupInput = {
    where: UserGroupRelScalarWhereInput
    data: XOR<UserGroupRelUpdateManyMutationInput, UserGroupRelUncheckedUpdateManyWithoutUsersInput>
  }

  export type GroupPostUpsertWithWhereUniqueWithoutGroupInput = {
    where: GroupPostWhereUniqueInput
    update: XOR<GroupPostUpdateWithoutGroupInput, GroupPostUncheckedUpdateWithoutGroupInput>
    create: XOR<GroupPostCreateWithoutGroupInput, GroupPostUncheckedCreateWithoutGroupInput>
  }

  export type GroupPostUpdateWithWhereUniqueWithoutGroupInput = {
    where: GroupPostWhereUniqueInput
    data: XOR<GroupPostUpdateWithoutGroupInput, GroupPostUncheckedUpdateWithoutGroupInput>
  }

  export type GroupPostUpdateManyWithWhereWithoutGroupInput = {
    where: GroupPostScalarWhereInput
    data: XOR<GroupPostUpdateManyMutationInput, GroupPostUncheckedUpdateManyWithoutPostsInput>
  }

  export type UserCreateWithoutJoinedGroupsInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemCreateNestedManyWithoutUserInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupCreateNestedManyWithoutCreatorInput
    posts?: GroupPostCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutJoinedGroupsInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemUncheckedCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemUncheckedCreateNestedManyWithoutUserInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadUncheckedCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteUncheckedCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionUncheckedCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetUncheckedCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    posts?: GroupPostUncheckedCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserUncheckedCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutJoinedGroupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutJoinedGroupsInput, UserUncheckedCreateWithoutJoinedGroupsInput>
  }

  export type GroupCreateWithoutUsersInput = {
    id?: string
    name: string
    generalChatSessionId?: string | null
    createdAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedGroupInput
    posts?: GroupPostCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    creatorId: string
    generalChatSessionId?: string | null
    createdAt?: Date | string
    posts?: GroupPostUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutUsersInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutUsersInput, GroupUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutJoinedGroupsInput = {
    update: XOR<UserUpdateWithoutJoinedGroupsInput, UserUncheckedUpdateWithoutJoinedGroupsInput>
    create: XOR<UserCreateWithoutJoinedGroupsInput, UserUncheckedCreateWithoutJoinedGroupsInput>
  }

  export type UserUpdateWithoutJoinedGroupsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUpdateManyWithoutUserNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUpdateManyWithoutCreatorNestedInput
    posts?: GroupPostUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutJoinedGroupsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUncheckedUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUncheckedUpdateManyWithoutUserNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUncheckedUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUncheckedUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUncheckedUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUncheckedUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUncheckedUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUncheckedUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    posts?: GroupPostUncheckedUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUncheckedUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type GroupUpsertWithoutUsersInput = {
    update: XOR<GroupUpdateWithoutUsersInput, GroupUncheckedUpdateWithoutUsersInput>
    create: XOR<GroupCreateWithoutUsersInput, GroupUncheckedCreateWithoutUsersInput>
  }

  export type GroupUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generalChatSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedGroupNestedInput
    posts?: GroupPostUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    generalChatSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: GroupPostUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type UserCreateWithoutUserProfileInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemCreateNestedManyWithoutUserInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentCreateNestedManyWithoutUserInput
    mathNotes?: MathNoteCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelCreateNestedManyWithoutUserInput
    posts?: GroupPostCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutUserProfileInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemUncheckedCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemUncheckedCreateNestedManyWithoutUserInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadUncheckedCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentUncheckedCreateNestedManyWithoutUserInput
    mathNotes?: MathNoteUncheckedCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionUncheckedCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetUncheckedCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelUncheckedCreateNestedManyWithoutUserInput
    posts?: GroupPostUncheckedCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserUncheckedCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutUserProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserProfileInput, UserUncheckedCreateWithoutUserProfileInput>
  }

  export type UserUpsertWithoutUserProfileInput = {
    update: XOR<UserUpdateWithoutUserProfileInput, UserUncheckedUpdateWithoutUserProfileInput>
    create: XOR<UserCreateWithoutUserProfileInput, UserUncheckedCreateWithoutUserProfileInput>
  }

  export type UserUpdateWithoutUserProfileInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUpdateManyWithoutUserNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUpdateManyWithoutUserNestedInput
    mathNotes?: MathNoteUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUpdateManyWithoutUserNestedInput
    posts?: GroupPostUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutUserProfileInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUncheckedUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUncheckedUpdateManyWithoutUserNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUncheckedUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    mathNotes?: MathNoteUncheckedUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUncheckedUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUncheckedUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUncheckedUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUncheckedUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUncheckedUpdateManyWithoutUserNestedInput
    posts?: GroupPostUncheckedUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUncheckedUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type CodingProblemCreateWithoutCategoryInput = {
    id: string
    code: string
    title: string
    link?: string | null
    description?: string | null
    timeLimit?: number
    memoryLimit?: number
    difficulty?: number
    practicePoint?: number
    totalPoint?: number
    submissionNumber?: number
    acceptedNumber?: number
    visibleFrom?: Date | string | null
    authors?: AuthorCodingProblemCreateNestedManyWithoutCodingProblemInput
    tags?: TagCodingProblemCreateNestedManyWithoutCodingProblemInput
    codeforcesTag?: CodefocesTagProblemCreateNestedManyWithoutProblemInput
    testCases?: TestcaseCreateNestedManyWithoutProblemInput
    contest?: ContestCreateNestedOneWithoutCodingProblemsInput
  }

  export type CodingProblemUncheckedCreateWithoutCategoryInput = {
    id: string
    code: string
    title: string
    link?: string | null
    description?: string | null
    timeLimit?: number
    memoryLimit?: number
    difficulty?: number
    practicePoint?: number
    totalPoint?: number
    submissionNumber?: number
    acceptedNumber?: number
    contestId?: string | null
    visibleFrom?: Date | string | null
    authors?: AuthorCodingProblemUncheckedCreateNestedManyWithoutCodingProblemInput
    tags?: TagCodingProblemUncheckedCreateNestedManyWithoutCodingProblemInput
    codeforcesTag?: CodefocesTagProblemUncheckedCreateNestedManyWithoutProblemInput
    testCases?: TestcaseUncheckedCreateNestedManyWithoutProblemInput
  }

  export type CodingProblemCreateOrConnectWithoutCategoryInput = {
    where: CodingProblemWhereUniqueInput
    create: XOR<CodingProblemCreateWithoutCategoryInput, CodingProblemUncheckedCreateWithoutCategoryInput>
  }

  export type CodingProblemCreateManyCategoryInputEnvelope = {
    data: Enumerable<CodingProblemCreateManyCategoryInput>
    skipDuplicates?: boolean
  }

  export type CodingProblemUpsertWithWhereUniqueWithoutCategoryInput = {
    where: CodingProblemWhereUniqueInput
    update: XOR<CodingProblemUpdateWithoutCategoryInput, CodingProblemUncheckedUpdateWithoutCategoryInput>
    create: XOR<CodingProblemCreateWithoutCategoryInput, CodingProblemUncheckedCreateWithoutCategoryInput>
  }

  export type CodingProblemUpdateWithWhereUniqueWithoutCategoryInput = {
    where: CodingProblemWhereUniqueInput
    data: XOR<CodingProblemUpdateWithoutCategoryInput, CodingProblemUncheckedUpdateWithoutCategoryInput>
  }

  export type CodingProblemUpdateManyWithWhereWithoutCategoryInput = {
    where: CodingProblemScalarWhereInput
    data: XOR<CodingProblemUpdateManyMutationInput, CodingProblemUncheckedUpdateManyWithoutCodingProblemsInput>
  }

  export type CodingProblemScalarWhereInput = {
    AND?: Enumerable<CodingProblemScalarWhereInput>
    OR?: Enumerable<CodingProblemScalarWhereInput>
    NOT?: Enumerable<CodingProblemScalarWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    title?: StringFilter | string
    categoryId?: IntFilter | number
    link?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    timeLimit?: IntFilter | number
    memoryLimit?: IntFilter | number
    difficulty?: IntFilter | number
    practicePoint?: IntFilter | number
    totalPoint?: IntFilter | number
    submissionNumber?: IntFilter | number
    acceptedNumber?: IntFilter | number
    contestId?: StringNullableFilter | string | null
    visibleFrom?: DateTimeNullableFilter | Date | string | null
  }

  export type TagCodingProblemCreateWithoutTagInput = {
    codingProblem: CodingProblemCreateNestedOneWithoutTagsInput
  }

  export type TagCodingProblemUncheckedCreateWithoutTagInput = {
    codingProblemId: string
  }

  export type TagCodingProblemCreateOrConnectWithoutTagInput = {
    where: TagCodingProblemWhereUniqueInput
    create: XOR<TagCodingProblemCreateWithoutTagInput, TagCodingProblemUncheckedCreateWithoutTagInput>
  }

  export type TagCodingProblemCreateManyTagInputEnvelope = {
    data: Enumerable<TagCodingProblemCreateManyTagInput>
    skipDuplicates?: boolean
  }

  export type TagCodingProblemUpsertWithWhereUniqueWithoutTagInput = {
    where: TagCodingProblemWhereUniqueInput
    update: XOR<TagCodingProblemUpdateWithoutTagInput, TagCodingProblemUncheckedUpdateWithoutTagInput>
    create: XOR<TagCodingProblemCreateWithoutTagInput, TagCodingProblemUncheckedCreateWithoutTagInput>
  }

  export type TagCodingProblemUpdateWithWhereUniqueWithoutTagInput = {
    where: TagCodingProblemWhereUniqueInput
    data: XOR<TagCodingProblemUpdateWithoutTagInput, TagCodingProblemUncheckedUpdateWithoutTagInput>
  }

  export type TagCodingProblemUpdateManyWithWhereWithoutTagInput = {
    where: TagCodingProblemScalarWhereInput
    data: XOR<TagCodingProblemUpdateManyMutationInput, TagCodingProblemUncheckedUpdateManyWithoutCodingProblemsInput>
  }

  export type TagCodingProblemScalarWhereInput = {
    AND?: Enumerable<TagCodingProblemScalarWhereInput>
    OR?: Enumerable<TagCodingProblemScalarWhereInput>
    NOT?: Enumerable<TagCodingProblemScalarWhereInput>
    tagId?: IntFilter | number
    codingProblemId?: StringFilter | string
  }

  export type CodefocesTagProblemCreateWithoutCodeforcesTagInput = {
    problem: CodingProblemCreateNestedOneWithoutCodeforcesTagInput
  }

  export type CodefocesTagProblemUncheckedCreateWithoutCodeforcesTagInput = {
    problemId: string
  }

  export type CodefocesTagProblemCreateOrConnectWithoutCodeforcesTagInput = {
    where: CodefocesTagProblemWhereUniqueInput
    create: XOR<CodefocesTagProblemCreateWithoutCodeforcesTagInput, CodefocesTagProblemUncheckedCreateWithoutCodeforcesTagInput>
  }

  export type CodefocesTagProblemCreateManyCodeforcesTagInputEnvelope = {
    data: Enumerable<CodefocesTagProblemCreateManyCodeforcesTagInput>
    skipDuplicates?: boolean
  }

  export type CodefocesTagProblemUpsertWithWhereUniqueWithoutCodeforcesTagInput = {
    where: CodefocesTagProblemWhereUniqueInput
    update: XOR<CodefocesTagProblemUpdateWithoutCodeforcesTagInput, CodefocesTagProblemUncheckedUpdateWithoutCodeforcesTagInput>
    create: XOR<CodefocesTagProblemCreateWithoutCodeforcesTagInput, CodefocesTagProblemUncheckedCreateWithoutCodeforcesTagInput>
  }

  export type CodefocesTagProblemUpdateWithWhereUniqueWithoutCodeforcesTagInput = {
    where: CodefocesTagProblemWhereUniqueInput
    data: XOR<CodefocesTagProblemUpdateWithoutCodeforcesTagInput, CodefocesTagProblemUncheckedUpdateWithoutCodeforcesTagInput>
  }

  export type CodefocesTagProblemUpdateManyWithWhereWithoutCodeforcesTagInput = {
    where: CodefocesTagProblemScalarWhereInput
    data: XOR<CodefocesTagProblemUpdateManyMutationInput, CodefocesTagProblemUncheckedUpdateManyWithoutProblemsInput>
  }

  export type CodefocesTagProblemScalarWhereInput = {
    AND?: Enumerable<CodefocesTagProblemScalarWhereInput>
    OR?: Enumerable<CodefocesTagProblemScalarWhereInput>
    NOT?: Enumerable<CodefocesTagProblemScalarWhereInput>
    problemId?: StringFilter | string
    codeforcesTagId?: StringFilter | string
  }

  export type CodingProblemCreateWithoutCodeforcesTagInput = {
    id: string
    code: string
    title: string
    link?: string | null
    description?: string | null
    timeLimit?: number
    memoryLimit?: number
    difficulty?: number
    practicePoint?: number
    totalPoint?: number
    submissionNumber?: number
    acceptedNumber?: number
    visibleFrom?: Date | string | null
    category: CodingProblemCategoryCreateNestedOneWithoutCodingProblemsInput
    authors?: AuthorCodingProblemCreateNestedManyWithoutCodingProblemInput
    tags?: TagCodingProblemCreateNestedManyWithoutCodingProblemInput
    testCases?: TestcaseCreateNestedManyWithoutProblemInput
    contest?: ContestCreateNestedOneWithoutCodingProblemsInput
  }

  export type CodingProblemUncheckedCreateWithoutCodeforcesTagInput = {
    id: string
    code: string
    title: string
    categoryId: number
    link?: string | null
    description?: string | null
    timeLimit?: number
    memoryLimit?: number
    difficulty?: number
    practicePoint?: number
    totalPoint?: number
    submissionNumber?: number
    acceptedNumber?: number
    contestId?: string | null
    visibleFrom?: Date | string | null
    authors?: AuthorCodingProblemUncheckedCreateNestedManyWithoutCodingProblemInput
    tags?: TagCodingProblemUncheckedCreateNestedManyWithoutCodingProblemInput
    testCases?: TestcaseUncheckedCreateNestedManyWithoutProblemInput
  }

  export type CodingProblemCreateOrConnectWithoutCodeforcesTagInput = {
    where: CodingProblemWhereUniqueInput
    create: XOR<CodingProblemCreateWithoutCodeforcesTagInput, CodingProblemUncheckedCreateWithoutCodeforcesTagInput>
  }

  export type CodeforcesTagCreateWithoutProblemsInput = {
    id: string
    name: string
    parentId?: string | null
  }

  export type CodeforcesTagUncheckedCreateWithoutProblemsInput = {
    id: string
    name: string
    parentId?: string | null
  }

  export type CodeforcesTagCreateOrConnectWithoutProblemsInput = {
    where: CodeforcesTagWhereUniqueInput
    create: XOR<CodeforcesTagCreateWithoutProblemsInput, CodeforcesTagUncheckedCreateWithoutProblemsInput>
  }

  export type CodingProblemUpsertWithoutCodeforcesTagInput = {
    update: XOR<CodingProblemUpdateWithoutCodeforcesTagInput, CodingProblemUncheckedUpdateWithoutCodeforcesTagInput>
    create: XOR<CodingProblemCreateWithoutCodeforcesTagInput, CodingProblemUncheckedCreateWithoutCodeforcesTagInput>
  }

  export type CodingProblemUpdateWithoutCodeforcesTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: IntFieldUpdateOperationsInput | number
    memoryLimit?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: IntFieldUpdateOperationsInput | number
    totalPoint?: IntFieldUpdateOperationsInput | number
    submissionNumber?: IntFieldUpdateOperationsInput | number
    acceptedNumber?: IntFieldUpdateOperationsInput | number
    visibleFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CodingProblemCategoryUpdateOneRequiredWithoutCodingProblemsNestedInput
    authors?: AuthorCodingProblemUpdateManyWithoutCodingProblemNestedInput
    tags?: TagCodingProblemUpdateManyWithoutCodingProblemNestedInput
    testCases?: TestcaseUpdateManyWithoutProblemNestedInput
    contest?: ContestUpdateOneWithoutCodingProblemsNestedInput
  }

  export type CodingProblemUncheckedUpdateWithoutCodeforcesTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: IntFieldUpdateOperationsInput | number
    memoryLimit?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: IntFieldUpdateOperationsInput | number
    totalPoint?: IntFieldUpdateOperationsInput | number
    submissionNumber?: IntFieldUpdateOperationsInput | number
    acceptedNumber?: IntFieldUpdateOperationsInput | number
    contestId?: NullableStringFieldUpdateOperationsInput | string | null
    visibleFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authors?: AuthorCodingProblemUncheckedUpdateManyWithoutCodingProblemNestedInput
    tags?: TagCodingProblemUncheckedUpdateManyWithoutCodingProblemNestedInput
    testCases?: TestcaseUncheckedUpdateManyWithoutProblemNestedInput
  }

  export type CodeforcesTagUpsertWithoutProblemsInput = {
    update: XOR<CodeforcesTagUpdateWithoutProblemsInput, CodeforcesTagUncheckedUpdateWithoutProblemsInput>
    create: XOR<CodeforcesTagCreateWithoutProblemsInput, CodeforcesTagUncheckedCreateWithoutProblemsInput>
  }

  export type CodeforcesTagUpdateWithoutProblemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CodeforcesTagUncheckedUpdateWithoutProblemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CodingProblemCategoryCreateWithoutCodingProblemsInput = {
    name: string
  }

  export type CodingProblemCategoryUncheckedCreateWithoutCodingProblemsInput = {
    id?: number
    name: string
  }

  export type CodingProblemCategoryCreateOrConnectWithoutCodingProblemsInput = {
    where: CodingProblemCategoryWhereUniqueInput
    create: XOR<CodingProblemCategoryCreateWithoutCodingProblemsInput, CodingProblemCategoryUncheckedCreateWithoutCodingProblemsInput>
  }

  export type AuthorCodingProblemCreateWithoutCodingProblemInput = {
    user: UserCreateNestedOneWithoutCodingProblemsInput
  }

  export type AuthorCodingProblemUncheckedCreateWithoutCodingProblemInput = {
    username: string
  }

  export type AuthorCodingProblemCreateOrConnectWithoutCodingProblemInput = {
    where: AuthorCodingProblemWhereUniqueInput
    create: XOR<AuthorCodingProblemCreateWithoutCodingProblemInput, AuthorCodingProblemUncheckedCreateWithoutCodingProblemInput>
  }

  export type AuthorCodingProblemCreateManyCodingProblemInputEnvelope = {
    data: Enumerable<AuthorCodingProblemCreateManyCodingProblemInput>
    skipDuplicates?: boolean
  }

  export type TagCodingProblemCreateWithoutCodingProblemInput = {
    tag: CodingProblemTagCreateNestedOneWithoutCodingProblemsInput
  }

  export type TagCodingProblemUncheckedCreateWithoutCodingProblemInput = {
    tagId: number
  }

  export type TagCodingProblemCreateOrConnectWithoutCodingProblemInput = {
    where: TagCodingProblemWhereUniqueInput
    create: XOR<TagCodingProblemCreateWithoutCodingProblemInput, TagCodingProblemUncheckedCreateWithoutCodingProblemInput>
  }

  export type TagCodingProblemCreateManyCodingProblemInputEnvelope = {
    data: Enumerable<TagCodingProblemCreateManyCodingProblemInput>
    skipDuplicates?: boolean
  }

  export type CodefocesTagProblemCreateWithoutProblemInput = {
    codeforcesTag: CodeforcesTagCreateNestedOneWithoutProblemsInput
  }

  export type CodefocesTagProblemUncheckedCreateWithoutProblemInput = {
    codeforcesTagId: string
  }

  export type CodefocesTagProblemCreateOrConnectWithoutProblemInput = {
    where: CodefocesTagProblemWhereUniqueInput
    create: XOR<CodefocesTagProblemCreateWithoutProblemInput, CodefocesTagProblemUncheckedCreateWithoutProblemInput>
  }

  export type CodefocesTagProblemCreateManyProblemInputEnvelope = {
    data: Enumerable<CodefocesTagProblemCreateManyProblemInput>
    skipDuplicates?: boolean
  }

  export type TestcaseCreateWithoutProblemInput = {
    id: string
    subTestNumber: number
    description: JsonNullValueInput | InputJsonValue
  }

  export type TestcaseUncheckedCreateWithoutProblemInput = {
    id: string
    subTestNumber: number
    description: JsonNullValueInput | InputJsonValue
  }

  export type TestcaseCreateOrConnectWithoutProblemInput = {
    where: TestcaseWhereUniqueInput
    create: XOR<TestcaseCreateWithoutProblemInput, TestcaseUncheckedCreateWithoutProblemInput>
  }

  export type TestcaseCreateManyProblemInputEnvelope = {
    data: Enumerable<TestcaseCreateManyProblemInput>
    skipDuplicates?: boolean
  }

  export type ContestCreateWithoutCodingProblemsInput = {
    id: string
    title: string
    description: string
    realTimeRank: boolean
    password?: string | null
    ruleType: ProblemRuleType
    startTime: Date | string
    duration: number
    endTime: Date | string
    createTime?: Date | string
    lastUpdateTime?: Date | string
    visible?: boolean
  }

  export type ContestUncheckedCreateWithoutCodingProblemsInput = {
    id: string
    title: string
    description: string
    realTimeRank: boolean
    password?: string | null
    ruleType: ProblemRuleType
    startTime: Date | string
    duration: number
    endTime: Date | string
    createTime?: Date | string
    lastUpdateTime?: Date | string
    visible?: boolean
  }

  export type ContestCreateOrConnectWithoutCodingProblemsInput = {
    where: ContestWhereUniqueInput
    create: XOR<ContestCreateWithoutCodingProblemsInput, ContestUncheckedCreateWithoutCodingProblemsInput>
  }

  export type CodingProblemCategoryUpsertWithoutCodingProblemsInput = {
    update: XOR<CodingProblemCategoryUpdateWithoutCodingProblemsInput, CodingProblemCategoryUncheckedUpdateWithoutCodingProblemsInput>
    create: XOR<CodingProblemCategoryCreateWithoutCodingProblemsInput, CodingProblemCategoryUncheckedCreateWithoutCodingProblemsInput>
  }

  export type CodingProblemCategoryUpdateWithoutCodingProblemsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CodingProblemCategoryUncheckedUpdateWithoutCodingProblemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AuthorCodingProblemUpsertWithWhereUniqueWithoutCodingProblemInput = {
    where: AuthorCodingProblemWhereUniqueInput
    update: XOR<AuthorCodingProblemUpdateWithoutCodingProblemInput, AuthorCodingProblemUncheckedUpdateWithoutCodingProblemInput>
    create: XOR<AuthorCodingProblemCreateWithoutCodingProblemInput, AuthorCodingProblemUncheckedCreateWithoutCodingProblemInput>
  }

  export type AuthorCodingProblemUpdateWithWhereUniqueWithoutCodingProblemInput = {
    where: AuthorCodingProblemWhereUniqueInput
    data: XOR<AuthorCodingProblemUpdateWithoutCodingProblemInput, AuthorCodingProblemUncheckedUpdateWithoutCodingProblemInput>
  }

  export type AuthorCodingProblemUpdateManyWithWhereWithoutCodingProblemInput = {
    where: AuthorCodingProblemScalarWhereInput
    data: XOR<AuthorCodingProblemUpdateManyMutationInput, AuthorCodingProblemUncheckedUpdateManyWithoutAuthorsInput>
  }

  export type TagCodingProblemUpsertWithWhereUniqueWithoutCodingProblemInput = {
    where: TagCodingProblemWhereUniqueInput
    update: XOR<TagCodingProblemUpdateWithoutCodingProblemInput, TagCodingProblemUncheckedUpdateWithoutCodingProblemInput>
    create: XOR<TagCodingProblemCreateWithoutCodingProblemInput, TagCodingProblemUncheckedCreateWithoutCodingProblemInput>
  }

  export type TagCodingProblemUpdateWithWhereUniqueWithoutCodingProblemInput = {
    where: TagCodingProblemWhereUniqueInput
    data: XOR<TagCodingProblemUpdateWithoutCodingProblemInput, TagCodingProblemUncheckedUpdateWithoutCodingProblemInput>
  }

  export type TagCodingProblemUpdateManyWithWhereWithoutCodingProblemInput = {
    where: TagCodingProblemScalarWhereInput
    data: XOR<TagCodingProblemUpdateManyMutationInput, TagCodingProblemUncheckedUpdateManyWithoutTagsInput>
  }

  export type CodefocesTagProblemUpsertWithWhereUniqueWithoutProblemInput = {
    where: CodefocesTagProblemWhereUniqueInput
    update: XOR<CodefocesTagProblemUpdateWithoutProblemInput, CodefocesTagProblemUncheckedUpdateWithoutProblemInput>
    create: XOR<CodefocesTagProblemCreateWithoutProblemInput, CodefocesTagProblemUncheckedCreateWithoutProblemInput>
  }

  export type CodefocesTagProblemUpdateWithWhereUniqueWithoutProblemInput = {
    where: CodefocesTagProblemWhereUniqueInput
    data: XOR<CodefocesTagProblemUpdateWithoutProblemInput, CodefocesTagProblemUncheckedUpdateWithoutProblemInput>
  }

  export type CodefocesTagProblemUpdateManyWithWhereWithoutProblemInput = {
    where: CodefocesTagProblemScalarWhereInput
    data: XOR<CodefocesTagProblemUpdateManyMutationInput, CodefocesTagProblemUncheckedUpdateManyWithoutCodeforcesTagInput>
  }

  export type TestcaseUpsertWithWhereUniqueWithoutProblemInput = {
    where: TestcaseWhereUniqueInput
    update: XOR<TestcaseUpdateWithoutProblemInput, TestcaseUncheckedUpdateWithoutProblemInput>
    create: XOR<TestcaseCreateWithoutProblemInput, TestcaseUncheckedCreateWithoutProblemInput>
  }

  export type TestcaseUpdateWithWhereUniqueWithoutProblemInput = {
    where: TestcaseWhereUniqueInput
    data: XOR<TestcaseUpdateWithoutProblemInput, TestcaseUncheckedUpdateWithoutProblemInput>
  }

  export type TestcaseUpdateManyWithWhereWithoutProblemInput = {
    where: TestcaseScalarWhereInput
    data: XOR<TestcaseUpdateManyMutationInput, TestcaseUncheckedUpdateManyWithoutTestCasesInput>
  }

  export type TestcaseScalarWhereInput = {
    AND?: Enumerable<TestcaseScalarWhereInput>
    OR?: Enumerable<TestcaseScalarWhereInput>
    NOT?: Enumerable<TestcaseScalarWhereInput>
    id?: StringFilter | string
    problemId?: StringFilter | string
    subTestNumber?: IntFilter | number
    description?: JsonFilter
  }

  export type ContestUpsertWithoutCodingProblemsInput = {
    update: XOR<ContestUpdateWithoutCodingProblemsInput, ContestUncheckedUpdateWithoutCodingProblemsInput>
    create: XOR<ContestCreateWithoutCodingProblemsInput, ContestUncheckedCreateWithoutCodingProblemsInput>
  }

  export type ContestUpdateWithoutCodingProblemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    realTimeRank?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ruleType?: EnumProblemRuleTypeFieldUpdateOperationsInput | ProblemRuleType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createTime?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    visible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ContestUncheckedUpdateWithoutCodingProblemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    realTimeRank?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ruleType?: EnumProblemRuleTypeFieldUpdateOperationsInput | ProblemRuleType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createTime?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    visible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCreateWithoutCodingProblemsInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    authorMathProblems?: AuthorMathProblemCreateNestedManyWithoutUserInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelCreateNestedManyWithoutUserInput
    posts?: GroupPostCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutCodingProblemsInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    authorMathProblems?: AuthorMathProblemUncheckedCreateNestedManyWithoutUserInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadUncheckedCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteUncheckedCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionUncheckedCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetUncheckedCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelUncheckedCreateNestedManyWithoutUserInput
    posts?: GroupPostUncheckedCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserUncheckedCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutCodingProblemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCodingProblemsInput, UserUncheckedCreateWithoutCodingProblemsInput>
  }

  export type CodingProblemCreateWithoutAuthorsInput = {
    id: string
    code: string
    title: string
    link?: string | null
    description?: string | null
    timeLimit?: number
    memoryLimit?: number
    difficulty?: number
    practicePoint?: number
    totalPoint?: number
    submissionNumber?: number
    acceptedNumber?: number
    visibleFrom?: Date | string | null
    category: CodingProblemCategoryCreateNestedOneWithoutCodingProblemsInput
    tags?: TagCodingProblemCreateNestedManyWithoutCodingProblemInput
    codeforcesTag?: CodefocesTagProblemCreateNestedManyWithoutProblemInput
    testCases?: TestcaseCreateNestedManyWithoutProblemInput
    contest?: ContestCreateNestedOneWithoutCodingProblemsInput
  }

  export type CodingProblemUncheckedCreateWithoutAuthorsInput = {
    id: string
    code: string
    title: string
    categoryId: number
    link?: string | null
    description?: string | null
    timeLimit?: number
    memoryLimit?: number
    difficulty?: number
    practicePoint?: number
    totalPoint?: number
    submissionNumber?: number
    acceptedNumber?: number
    contestId?: string | null
    visibleFrom?: Date | string | null
    tags?: TagCodingProblemUncheckedCreateNestedManyWithoutCodingProblemInput
    codeforcesTag?: CodefocesTagProblemUncheckedCreateNestedManyWithoutProblemInput
    testCases?: TestcaseUncheckedCreateNestedManyWithoutProblemInput
  }

  export type CodingProblemCreateOrConnectWithoutAuthorsInput = {
    where: CodingProblemWhereUniqueInput
    create: XOR<CodingProblemCreateWithoutAuthorsInput, CodingProblemUncheckedCreateWithoutAuthorsInput>
  }

  export type UserUpsertWithoutCodingProblemsInput = {
    update: XOR<UserUpdateWithoutCodingProblemsInput, UserUncheckedUpdateWithoutCodingProblemsInput>
    create: XOR<UserCreateWithoutCodingProblemsInput, UserUncheckedCreateWithoutCodingProblemsInput>
  }

  export type UserUpdateWithoutCodingProblemsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    authorMathProblems?: AuthorMathProblemUpdateManyWithoutUserNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUpdateManyWithoutUserNestedInput
    posts?: GroupPostUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutCodingProblemsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    authorMathProblems?: AuthorMathProblemUncheckedUpdateManyWithoutUserNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUncheckedUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUncheckedUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUncheckedUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUncheckedUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUncheckedUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUncheckedUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUncheckedUpdateManyWithoutUserNestedInput
    posts?: GroupPostUncheckedUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUncheckedUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type CodingProblemUpsertWithoutAuthorsInput = {
    update: XOR<CodingProblemUpdateWithoutAuthorsInput, CodingProblemUncheckedUpdateWithoutAuthorsInput>
    create: XOR<CodingProblemCreateWithoutAuthorsInput, CodingProblemUncheckedCreateWithoutAuthorsInput>
  }

  export type CodingProblemUpdateWithoutAuthorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: IntFieldUpdateOperationsInput | number
    memoryLimit?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: IntFieldUpdateOperationsInput | number
    totalPoint?: IntFieldUpdateOperationsInput | number
    submissionNumber?: IntFieldUpdateOperationsInput | number
    acceptedNumber?: IntFieldUpdateOperationsInput | number
    visibleFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CodingProblemCategoryUpdateOneRequiredWithoutCodingProblemsNestedInput
    tags?: TagCodingProblemUpdateManyWithoutCodingProblemNestedInput
    codeforcesTag?: CodefocesTagProblemUpdateManyWithoutProblemNestedInput
    testCases?: TestcaseUpdateManyWithoutProblemNestedInput
    contest?: ContestUpdateOneWithoutCodingProblemsNestedInput
  }

  export type CodingProblemUncheckedUpdateWithoutAuthorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: IntFieldUpdateOperationsInput | number
    memoryLimit?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: IntFieldUpdateOperationsInput | number
    totalPoint?: IntFieldUpdateOperationsInput | number
    submissionNumber?: IntFieldUpdateOperationsInput | number
    acceptedNumber?: IntFieldUpdateOperationsInput | number
    contestId?: NullableStringFieldUpdateOperationsInput | string | null
    visibleFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: TagCodingProblemUncheckedUpdateManyWithoutCodingProblemNestedInput
    codeforcesTag?: CodefocesTagProblemUncheckedUpdateManyWithoutProblemNestedInput
    testCases?: TestcaseUncheckedUpdateManyWithoutProblemNestedInput
  }

  export type CodingProblemTagCreateWithoutCodingProblemsInput = {
    name: string
  }

  export type CodingProblemTagUncheckedCreateWithoutCodingProblemsInput = {
    id?: number
    name: string
  }

  export type CodingProblemTagCreateOrConnectWithoutCodingProblemsInput = {
    where: CodingProblemTagWhereUniqueInput
    create: XOR<CodingProblemTagCreateWithoutCodingProblemsInput, CodingProblemTagUncheckedCreateWithoutCodingProblemsInput>
  }

  export type CodingProblemCreateWithoutTagsInput = {
    id: string
    code: string
    title: string
    link?: string | null
    description?: string | null
    timeLimit?: number
    memoryLimit?: number
    difficulty?: number
    practicePoint?: number
    totalPoint?: number
    submissionNumber?: number
    acceptedNumber?: number
    visibleFrom?: Date | string | null
    category: CodingProblemCategoryCreateNestedOneWithoutCodingProblemsInput
    authors?: AuthorCodingProblemCreateNestedManyWithoutCodingProblemInput
    codeforcesTag?: CodefocesTagProblemCreateNestedManyWithoutProblemInput
    testCases?: TestcaseCreateNestedManyWithoutProblemInput
    contest?: ContestCreateNestedOneWithoutCodingProblemsInput
  }

  export type CodingProblemUncheckedCreateWithoutTagsInput = {
    id: string
    code: string
    title: string
    categoryId: number
    link?: string | null
    description?: string | null
    timeLimit?: number
    memoryLimit?: number
    difficulty?: number
    practicePoint?: number
    totalPoint?: number
    submissionNumber?: number
    acceptedNumber?: number
    contestId?: string | null
    visibleFrom?: Date | string | null
    authors?: AuthorCodingProblemUncheckedCreateNestedManyWithoutCodingProblemInput
    codeforcesTag?: CodefocesTagProblemUncheckedCreateNestedManyWithoutProblemInput
    testCases?: TestcaseUncheckedCreateNestedManyWithoutProblemInput
  }

  export type CodingProblemCreateOrConnectWithoutTagsInput = {
    where: CodingProblemWhereUniqueInput
    create: XOR<CodingProblemCreateWithoutTagsInput, CodingProblemUncheckedCreateWithoutTagsInput>
  }

  export type CodingProblemTagUpsertWithoutCodingProblemsInput = {
    update: XOR<CodingProblemTagUpdateWithoutCodingProblemsInput, CodingProblemTagUncheckedUpdateWithoutCodingProblemsInput>
    create: XOR<CodingProblemTagCreateWithoutCodingProblemsInput, CodingProblemTagUncheckedCreateWithoutCodingProblemsInput>
  }

  export type CodingProblemTagUpdateWithoutCodingProblemsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CodingProblemTagUncheckedUpdateWithoutCodingProblemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CodingProblemUpsertWithoutTagsInput = {
    update: XOR<CodingProblemUpdateWithoutTagsInput, CodingProblemUncheckedUpdateWithoutTagsInput>
    create: XOR<CodingProblemCreateWithoutTagsInput, CodingProblemUncheckedCreateWithoutTagsInput>
  }

  export type CodingProblemUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: IntFieldUpdateOperationsInput | number
    memoryLimit?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: IntFieldUpdateOperationsInput | number
    totalPoint?: IntFieldUpdateOperationsInput | number
    submissionNumber?: IntFieldUpdateOperationsInput | number
    acceptedNumber?: IntFieldUpdateOperationsInput | number
    visibleFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CodingProblemCategoryUpdateOneRequiredWithoutCodingProblemsNestedInput
    authors?: AuthorCodingProblemUpdateManyWithoutCodingProblemNestedInput
    codeforcesTag?: CodefocesTagProblemUpdateManyWithoutProblemNestedInput
    testCases?: TestcaseUpdateManyWithoutProblemNestedInput
    contest?: ContestUpdateOneWithoutCodingProblemsNestedInput
  }

  export type CodingProblemUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: IntFieldUpdateOperationsInput | number
    memoryLimit?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: IntFieldUpdateOperationsInput | number
    totalPoint?: IntFieldUpdateOperationsInput | number
    submissionNumber?: IntFieldUpdateOperationsInput | number
    acceptedNumber?: IntFieldUpdateOperationsInput | number
    contestId?: NullableStringFieldUpdateOperationsInput | string | null
    visibleFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authors?: AuthorCodingProblemUncheckedUpdateManyWithoutCodingProblemNestedInput
    codeforcesTag?: CodefocesTagProblemUncheckedUpdateManyWithoutProblemNestedInput
    testCases?: TestcaseUncheckedUpdateManyWithoutProblemNestedInput
  }

  export type UserCreateWithoutThreadsInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelCreateNestedManyWithoutUserInput
    posts?: GroupPostCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutThreadsInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemUncheckedCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadUncheckedCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteUncheckedCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionUncheckedCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetUncheckedCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelUncheckedCreateNestedManyWithoutUserInput
    posts?: GroupPostUncheckedCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserUncheckedCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutThreadsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutThreadsInput, UserUncheckedCreateWithoutThreadsInput>
  }

  export type CommentCreateWithoutThreadInput = {
    id: string
    parentId?: string | null
    rootId: string
    totalChildren?: number
    depth?: number
    likes?: number
    parentUsername?: string | null
    published?: boolean
    createdAt?: Date | string
    content: string
    creator: UserCreateNestedOneWithoutCommentsInput
    usersLiked?: UserLikeCommentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutThreadInput = {
    id: string
    parentId?: string | null
    rootId: string
    totalChildren?: number
    depth?: number
    likes?: number
    parentUsername?: string | null
    creatorId: string
    published?: boolean
    createdAt?: Date | string
    content: string
    usersLiked?: UserLikeCommentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutThreadInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutThreadInput, CommentUncheckedCreateWithoutThreadInput>
  }

  export type CommentCreateManyThreadInputEnvelope = {
    data: Enumerable<CommentCreateManyThreadInput>
    skipDuplicates?: boolean
  }

  export type ThreadCategoryCreateWithoutThreadsInput = {
    parentId?: string | null
    title: string
  }

  export type ThreadCategoryUncheckedCreateWithoutThreadsInput = {
    id?: number
    parentId?: string | null
    title: string
  }

  export type ThreadCategoryCreateOrConnectWithoutThreadsInput = {
    where: ThreadCategoryWhereUniqueInput
    create: XOR<ThreadCategoryCreateWithoutThreadsInput, ThreadCategoryUncheckedCreateWithoutThreadsInput>
  }

  export type ThreadTagRelCreateWithoutThreadInput = {
    tag: ThreadTagCreateNestedOneWithoutThreadsInput
  }

  export type ThreadTagRelUncheckedCreateWithoutThreadInput = {
    tagId: string
  }

  export type ThreadTagRelCreateOrConnectWithoutThreadInput = {
    where: ThreadTagRelWhereUniqueInput
    create: XOR<ThreadTagRelCreateWithoutThreadInput, ThreadTagRelUncheckedCreateWithoutThreadInput>
  }

  export type ThreadTagRelCreateManyThreadInputEnvelope = {
    data: Enumerable<ThreadTagRelCreateManyThreadInput>
    skipDuplicates?: boolean
  }

  export type UserLikeThreadCreateWithoutThreadInput = {
    disable?: boolean
    user: UserCreateNestedOneWithoutThreadLikedInput
  }

  export type UserLikeThreadUncheckedCreateWithoutThreadInput = {
    username: string
    disable?: boolean
  }

  export type UserLikeThreadCreateOrConnectWithoutThreadInput = {
    where: UserLikeThreadWhereUniqueInput
    create: XOR<UserLikeThreadCreateWithoutThreadInput, UserLikeThreadUncheckedCreateWithoutThreadInput>
  }

  export type UserLikeThreadCreateManyThreadInputEnvelope = {
    data: Enumerable<UserLikeThreadCreateManyThreadInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutThreadsInput = {
    update: XOR<UserUpdateWithoutThreadsInput, UserUncheckedUpdateWithoutThreadsInput>
    create: XOR<UserCreateWithoutThreadsInput, UserUncheckedCreateWithoutThreadsInput>
  }

  export type UserUpdateWithoutThreadsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUpdateManyWithoutUserNestedInput
    posts?: GroupPostUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutThreadsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUncheckedUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUncheckedUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUncheckedUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUncheckedUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUncheckedUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUncheckedUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUncheckedUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUncheckedUpdateManyWithoutUserNestedInput
    posts?: GroupPostUncheckedUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUncheckedUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutThreadInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutThreadInput, CommentUncheckedUpdateWithoutThreadInput>
    create: XOR<CommentCreateWithoutThreadInput, CommentUncheckedCreateWithoutThreadInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutThreadInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutThreadInput, CommentUncheckedUpdateWithoutThreadInput>
  }

  export type CommentUpdateManyWithWhereWithoutThreadInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutCommentsInput>
  }

  export type ThreadCategoryUpsertWithoutThreadsInput = {
    update: XOR<ThreadCategoryUpdateWithoutThreadsInput, ThreadCategoryUncheckedUpdateWithoutThreadsInput>
    create: XOR<ThreadCategoryCreateWithoutThreadsInput, ThreadCategoryUncheckedCreateWithoutThreadsInput>
  }

  export type ThreadCategoryUpdateWithoutThreadsInput = {
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
  }

  export type ThreadCategoryUncheckedUpdateWithoutThreadsInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
  }

  export type ThreadTagRelUpsertWithWhereUniqueWithoutThreadInput = {
    where: ThreadTagRelWhereUniqueInput
    update: XOR<ThreadTagRelUpdateWithoutThreadInput, ThreadTagRelUncheckedUpdateWithoutThreadInput>
    create: XOR<ThreadTagRelCreateWithoutThreadInput, ThreadTagRelUncheckedCreateWithoutThreadInput>
  }

  export type ThreadTagRelUpdateWithWhereUniqueWithoutThreadInput = {
    where: ThreadTagRelWhereUniqueInput
    data: XOR<ThreadTagRelUpdateWithoutThreadInput, ThreadTagRelUncheckedUpdateWithoutThreadInput>
  }

  export type ThreadTagRelUpdateManyWithWhereWithoutThreadInput = {
    where: ThreadTagRelScalarWhereInput
    data: XOR<ThreadTagRelUpdateManyMutationInput, ThreadTagRelUncheckedUpdateManyWithoutTagsInput>
  }

  export type ThreadTagRelScalarWhereInput = {
    AND?: Enumerable<ThreadTagRelScalarWhereInput>
    OR?: Enumerable<ThreadTagRelScalarWhereInput>
    NOT?: Enumerable<ThreadTagRelScalarWhereInput>
    threadId?: StringFilter | string
    tagId?: StringFilter | string
  }

  export type UserLikeThreadUpsertWithWhereUniqueWithoutThreadInput = {
    where: UserLikeThreadWhereUniqueInput
    update: XOR<UserLikeThreadUpdateWithoutThreadInput, UserLikeThreadUncheckedUpdateWithoutThreadInput>
    create: XOR<UserLikeThreadCreateWithoutThreadInput, UserLikeThreadUncheckedCreateWithoutThreadInput>
  }

  export type UserLikeThreadUpdateWithWhereUniqueWithoutThreadInput = {
    where: UserLikeThreadWhereUniqueInput
    data: XOR<UserLikeThreadUpdateWithoutThreadInput, UserLikeThreadUncheckedUpdateWithoutThreadInput>
  }

  export type UserLikeThreadUpdateManyWithWhereWithoutThreadInput = {
    where: UserLikeThreadScalarWhereInput
    data: XOR<UserLikeThreadUpdateManyMutationInput, UserLikeThreadUncheckedUpdateManyWithoutUserLikesInput>
  }

  export type ThreadCreateWithoutCategoryInput = {
    id: string
    parentId?: string | null
    title: string
    summary: string
    published: boolean
    createdAt?: Date | string
    lastUpdateAt?: Date | string
    publishedAt?: Date | string
    content: string
    totalComments?: number
    totalRootComments?: number
    likes?: number
    views?: number
    author: UserCreateNestedOneWithoutThreadsInput
    comments?: CommentCreateNestedManyWithoutThreadInput
    tags?: ThreadTagRelCreateNestedManyWithoutThreadInput
    userLikes?: UserLikeThreadCreateNestedManyWithoutThreadInput
  }

  export type ThreadUncheckedCreateWithoutCategoryInput = {
    id: string
    authorId: string
    parentId?: string | null
    title: string
    summary: string
    published: boolean
    createdAt?: Date | string
    lastUpdateAt?: Date | string
    publishedAt?: Date | string
    content: string
    totalComments?: number
    totalRootComments?: number
    likes?: number
    views?: number
    comments?: CommentUncheckedCreateNestedManyWithoutThreadInput
    tags?: ThreadTagRelUncheckedCreateNestedManyWithoutThreadInput
    userLikes?: UserLikeThreadUncheckedCreateNestedManyWithoutThreadInput
  }

  export type ThreadCreateOrConnectWithoutCategoryInput = {
    where: ThreadWhereUniqueInput
    create: XOR<ThreadCreateWithoutCategoryInput, ThreadUncheckedCreateWithoutCategoryInput>
  }

  export type ThreadCreateManyCategoryInputEnvelope = {
    data: Enumerable<ThreadCreateManyCategoryInput>
    skipDuplicates?: boolean
  }

  export type ThreadUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ThreadWhereUniqueInput
    update: XOR<ThreadUpdateWithoutCategoryInput, ThreadUncheckedUpdateWithoutCategoryInput>
    create: XOR<ThreadCreateWithoutCategoryInput, ThreadUncheckedCreateWithoutCategoryInput>
  }

  export type ThreadUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ThreadWhereUniqueInput
    data: XOR<ThreadUpdateWithoutCategoryInput, ThreadUncheckedUpdateWithoutCategoryInput>
  }

  export type ThreadUpdateManyWithWhereWithoutCategoryInput = {
    where: ThreadScalarWhereInput
    data: XOR<ThreadUpdateManyMutationInput, ThreadUncheckedUpdateManyWithoutThreadsInput>
  }

  export type ThreadTagRelCreateWithoutTagInput = {
    thread: ThreadCreateNestedOneWithoutTagsInput
  }

  export type ThreadTagRelUncheckedCreateWithoutTagInput = {
    threadId: string
  }

  export type ThreadTagRelCreateOrConnectWithoutTagInput = {
    where: ThreadTagRelWhereUniqueInput
    create: XOR<ThreadTagRelCreateWithoutTagInput, ThreadTagRelUncheckedCreateWithoutTagInput>
  }

  export type ThreadTagRelCreateManyTagInputEnvelope = {
    data: Enumerable<ThreadTagRelCreateManyTagInput>
    skipDuplicates?: boolean
  }

  export type ThreadTagRelUpsertWithWhereUniqueWithoutTagInput = {
    where: ThreadTagRelWhereUniqueInput
    update: XOR<ThreadTagRelUpdateWithoutTagInput, ThreadTagRelUncheckedUpdateWithoutTagInput>
    create: XOR<ThreadTagRelCreateWithoutTagInput, ThreadTagRelUncheckedCreateWithoutTagInput>
  }

  export type ThreadTagRelUpdateWithWhereUniqueWithoutTagInput = {
    where: ThreadTagRelWhereUniqueInput
    data: XOR<ThreadTagRelUpdateWithoutTagInput, ThreadTagRelUncheckedUpdateWithoutTagInput>
  }

  export type ThreadTagRelUpdateManyWithWhereWithoutTagInput = {
    where: ThreadTagRelScalarWhereInput
    data: XOR<ThreadTagRelUpdateManyMutationInput, ThreadTagRelUncheckedUpdateManyWithoutThreadsInput>
  }

  export type ThreadCreateWithoutTagsInput = {
    id: string
    parentId?: string | null
    title: string
    summary: string
    published: boolean
    createdAt?: Date | string
    lastUpdateAt?: Date | string
    publishedAt?: Date | string
    content: string
    totalComments?: number
    totalRootComments?: number
    likes?: number
    views?: number
    author: UserCreateNestedOneWithoutThreadsInput
    comments?: CommentCreateNestedManyWithoutThreadInput
    category?: ThreadCategoryCreateNestedOneWithoutThreadsInput
    userLikes?: UserLikeThreadCreateNestedManyWithoutThreadInput
  }

  export type ThreadUncheckedCreateWithoutTagsInput = {
    id: string
    authorId: string
    parentId?: string | null
    title: string
    summary: string
    published: boolean
    createdAt?: Date | string
    lastUpdateAt?: Date | string
    publishedAt?: Date | string
    content: string
    totalComments?: number
    totalRootComments?: number
    likes?: number
    views?: number
    categoryId?: number | null
    comments?: CommentUncheckedCreateNestedManyWithoutThreadInput
    userLikes?: UserLikeThreadUncheckedCreateNestedManyWithoutThreadInput
  }

  export type ThreadCreateOrConnectWithoutTagsInput = {
    where: ThreadWhereUniqueInput
    create: XOR<ThreadCreateWithoutTagsInput, ThreadUncheckedCreateWithoutTagsInput>
  }

  export type ThreadTagCreateWithoutThreadsInput = {
    id: string
    title: string
  }

  export type ThreadTagUncheckedCreateWithoutThreadsInput = {
    id: string
    title: string
  }

  export type ThreadTagCreateOrConnectWithoutThreadsInput = {
    where: ThreadTagWhereUniqueInput
    create: XOR<ThreadTagCreateWithoutThreadsInput, ThreadTagUncheckedCreateWithoutThreadsInput>
  }

  export type ThreadUpsertWithoutTagsInput = {
    update: XOR<ThreadUpdateWithoutTagsInput, ThreadUncheckedUpdateWithoutTagsInput>
    create: XOR<ThreadCreateWithoutTagsInput, ThreadUncheckedCreateWithoutTagsInput>
  }

  export type ThreadUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    totalComments?: IntFieldUpdateOperationsInput | number
    totalRootComments?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    author?: UserUpdateOneRequiredWithoutThreadsNestedInput
    comments?: CommentUpdateManyWithoutThreadNestedInput
    category?: ThreadCategoryUpdateOneWithoutThreadsNestedInput
    userLikes?: UserLikeThreadUpdateManyWithoutThreadNestedInput
  }

  export type ThreadUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    totalComments?: IntFieldUpdateOperationsInput | number
    totalRootComments?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: CommentUncheckedUpdateManyWithoutThreadNestedInput
    userLikes?: UserLikeThreadUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type ThreadTagUpsertWithoutThreadsInput = {
    update: XOR<ThreadTagUpdateWithoutThreadsInput, ThreadTagUncheckedUpdateWithoutThreadsInput>
    create: XOR<ThreadTagCreateWithoutThreadsInput, ThreadTagUncheckedCreateWithoutThreadsInput>
  }

  export type ThreadTagUpdateWithoutThreadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type ThreadTagUncheckedUpdateWithoutThreadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutThreadLikedInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemCreateNestedManyWithoutUserInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutCreatorInput
    commentLiked?: UserLikeCommentCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelCreateNestedManyWithoutUserInput
    posts?: GroupPostCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutThreadLikedInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemUncheckedCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemUncheckedCreateNestedManyWithoutUserInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreatorInput
    commentLiked?: UserLikeCommentUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteUncheckedCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionUncheckedCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetUncheckedCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelUncheckedCreateNestedManyWithoutUserInput
    posts?: GroupPostUncheckedCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserUncheckedCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutThreadLikedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutThreadLikedInput, UserUncheckedCreateWithoutThreadLikedInput>
  }

  export type ThreadCreateWithoutUserLikesInput = {
    id: string
    parentId?: string | null
    title: string
    summary: string
    published: boolean
    createdAt?: Date | string
    lastUpdateAt?: Date | string
    publishedAt?: Date | string
    content: string
    totalComments?: number
    totalRootComments?: number
    likes?: number
    views?: number
    author: UserCreateNestedOneWithoutThreadsInput
    comments?: CommentCreateNestedManyWithoutThreadInput
    category?: ThreadCategoryCreateNestedOneWithoutThreadsInput
    tags?: ThreadTagRelCreateNestedManyWithoutThreadInput
  }

  export type ThreadUncheckedCreateWithoutUserLikesInput = {
    id: string
    authorId: string
    parentId?: string | null
    title: string
    summary: string
    published: boolean
    createdAt?: Date | string
    lastUpdateAt?: Date | string
    publishedAt?: Date | string
    content: string
    totalComments?: number
    totalRootComments?: number
    likes?: number
    views?: number
    categoryId?: number | null
    comments?: CommentUncheckedCreateNestedManyWithoutThreadInput
    tags?: ThreadTagRelUncheckedCreateNestedManyWithoutThreadInput
  }

  export type ThreadCreateOrConnectWithoutUserLikesInput = {
    where: ThreadWhereUniqueInput
    create: XOR<ThreadCreateWithoutUserLikesInput, ThreadUncheckedCreateWithoutUserLikesInput>
  }

  export type UserUpsertWithoutThreadLikedInput = {
    update: XOR<UserUpdateWithoutThreadLikedInput, UserUncheckedUpdateWithoutThreadLikedInput>
    create: XOR<UserCreateWithoutThreadLikedInput, UserUncheckedCreateWithoutThreadLikedInput>
  }

  export type UserUpdateWithoutThreadLikedInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUpdateManyWithoutUserNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutCreatorNestedInput
    commentLiked?: UserLikeCommentUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUpdateManyWithoutUserNestedInput
    posts?: GroupPostUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutThreadLikedInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUncheckedUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUncheckedUpdateManyWithoutUserNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreatorNestedInput
    commentLiked?: UserLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUncheckedUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUncheckedUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUncheckedUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUncheckedUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUncheckedUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUncheckedUpdateManyWithoutUserNestedInput
    posts?: GroupPostUncheckedUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUncheckedUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type ThreadUpsertWithoutUserLikesInput = {
    update: XOR<ThreadUpdateWithoutUserLikesInput, ThreadUncheckedUpdateWithoutUserLikesInput>
    create: XOR<ThreadCreateWithoutUserLikesInput, ThreadUncheckedCreateWithoutUserLikesInput>
  }

  export type ThreadUpdateWithoutUserLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    totalComments?: IntFieldUpdateOperationsInput | number
    totalRootComments?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    author?: UserUpdateOneRequiredWithoutThreadsNestedInput
    comments?: CommentUpdateManyWithoutThreadNestedInput
    category?: ThreadCategoryUpdateOneWithoutThreadsNestedInput
    tags?: ThreadTagRelUpdateManyWithoutThreadNestedInput
  }

  export type ThreadUncheckedUpdateWithoutUserLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    totalComments?: IntFieldUpdateOperationsInput | number
    totalRootComments?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: CommentUncheckedUpdateManyWithoutThreadNestedInput
    tags?: ThreadTagRelUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type UserCreateWithoutCommentLikedInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemCreateNestedManyWithoutUserInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelCreateNestedManyWithoutUserInput
    posts?: GroupPostCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutCommentLikedInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemUncheckedCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemUncheckedCreateNestedManyWithoutUserInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteUncheckedCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionUncheckedCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetUncheckedCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelUncheckedCreateNestedManyWithoutUserInput
    posts?: GroupPostUncheckedCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserUncheckedCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutCommentLikedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentLikedInput, UserUncheckedCreateWithoutCommentLikedInput>
  }

  export type CommentCreateWithoutUsersLikedInput = {
    id: string
    parentId?: string | null
    rootId: string
    totalChildren?: number
    depth?: number
    likes?: number
    parentUsername?: string | null
    published?: boolean
    createdAt?: Date | string
    content: string
    thread: ThreadCreateNestedOneWithoutCommentsInput
    creator: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutUsersLikedInput = {
    id: string
    threadId: string
    parentId?: string | null
    rootId: string
    totalChildren?: number
    depth?: number
    likes?: number
    parentUsername?: string | null
    creatorId: string
    published?: boolean
    createdAt?: Date | string
    content: string
  }

  export type CommentCreateOrConnectWithoutUsersLikedInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUsersLikedInput, CommentUncheckedCreateWithoutUsersLikedInput>
  }

  export type UserUpsertWithoutCommentLikedInput = {
    update: XOR<UserUpdateWithoutCommentLikedInput, UserUncheckedUpdateWithoutCommentLikedInput>
    create: XOR<UserCreateWithoutCommentLikedInput, UserUncheckedCreateWithoutCommentLikedInput>
  }

  export type UserUpdateWithoutCommentLikedInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUpdateManyWithoutUserNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUpdateManyWithoutUserNestedInput
    posts?: GroupPostUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentLikedInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUncheckedUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUncheckedUpdateManyWithoutUserNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUncheckedUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUncheckedUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUncheckedUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUncheckedUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUncheckedUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUncheckedUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUncheckedUpdateManyWithoutUserNestedInput
    posts?: GroupPostUncheckedUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUncheckedUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type CommentUpsertWithoutUsersLikedInput = {
    update: XOR<CommentUpdateWithoutUsersLikedInput, CommentUncheckedUpdateWithoutUsersLikedInput>
    create: XOR<CommentCreateWithoutUsersLikedInput, CommentUncheckedCreateWithoutUsersLikedInput>
  }

  export type CommentUpdateWithoutUsersLikedInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: StringFieldUpdateOperationsInput | string
    totalChildren?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    parentUsername?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    thread?: ThreadUpdateOneRequiredWithoutCommentsNestedInput
    creator?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutUsersLikedInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: StringFieldUpdateOperationsInput | string
    totalChildren?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    parentUsername?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type ThreadCreateWithoutCommentsInput = {
    id: string
    parentId?: string | null
    title: string
    summary: string
    published: boolean
    createdAt?: Date | string
    lastUpdateAt?: Date | string
    publishedAt?: Date | string
    content: string
    totalComments?: number
    totalRootComments?: number
    likes?: number
    views?: number
    author: UserCreateNestedOneWithoutThreadsInput
    category?: ThreadCategoryCreateNestedOneWithoutThreadsInput
    tags?: ThreadTagRelCreateNestedManyWithoutThreadInput
    userLikes?: UserLikeThreadCreateNestedManyWithoutThreadInput
  }

  export type ThreadUncheckedCreateWithoutCommentsInput = {
    id: string
    authorId: string
    parentId?: string | null
    title: string
    summary: string
    published: boolean
    createdAt?: Date | string
    lastUpdateAt?: Date | string
    publishedAt?: Date | string
    content: string
    totalComments?: number
    totalRootComments?: number
    likes?: number
    views?: number
    categoryId?: number | null
    tags?: ThreadTagRelUncheckedCreateNestedManyWithoutThreadInput
    userLikes?: UserLikeThreadUncheckedCreateNestedManyWithoutThreadInput
  }

  export type ThreadCreateOrConnectWithoutCommentsInput = {
    where: ThreadWhereUniqueInput
    create: XOR<ThreadCreateWithoutCommentsInput, ThreadUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemCreateNestedManyWithoutUserInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    threadLiked?: UserLikeThreadCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelCreateNestedManyWithoutUserInput
    posts?: GroupPostCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemUncheckedCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemUncheckedCreateNestedManyWithoutUserInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    threadLiked?: UserLikeThreadUncheckedCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteUncheckedCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionUncheckedCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetUncheckedCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelUncheckedCreateNestedManyWithoutUserInput
    posts?: GroupPostUncheckedCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserUncheckedCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type UserLikeCommentCreateWithoutCommentInput = {
    disable?: boolean
    user: UserCreateNestedOneWithoutCommentLikedInput
  }

  export type UserLikeCommentUncheckedCreateWithoutCommentInput = {
    username: string
    disable?: boolean
  }

  export type UserLikeCommentCreateOrConnectWithoutCommentInput = {
    where: UserLikeCommentWhereUniqueInput
    create: XOR<UserLikeCommentCreateWithoutCommentInput, UserLikeCommentUncheckedCreateWithoutCommentInput>
  }

  export type UserLikeCommentCreateManyCommentInputEnvelope = {
    data: Enumerable<UserLikeCommentCreateManyCommentInput>
    skipDuplicates?: boolean
  }

  export type ThreadUpsertWithoutCommentsInput = {
    update: XOR<ThreadUpdateWithoutCommentsInput, ThreadUncheckedUpdateWithoutCommentsInput>
    create: XOR<ThreadCreateWithoutCommentsInput, ThreadUncheckedCreateWithoutCommentsInput>
  }

  export type ThreadUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    totalComments?: IntFieldUpdateOperationsInput | number
    totalRootComments?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    author?: UserUpdateOneRequiredWithoutThreadsNestedInput
    category?: ThreadCategoryUpdateOneWithoutThreadsNestedInput
    tags?: ThreadTagRelUpdateManyWithoutThreadNestedInput
    userLikes?: UserLikeThreadUpdateManyWithoutThreadNestedInput
  }

  export type ThreadUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    totalComments?: IntFieldUpdateOperationsInput | number
    totalRootComments?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: ThreadTagRelUncheckedUpdateManyWithoutThreadNestedInput
    userLikes?: UserLikeThreadUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUpdateManyWithoutUserNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    threadLiked?: UserLikeThreadUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUpdateManyWithoutUserNestedInput
    posts?: GroupPostUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUncheckedUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUncheckedUpdateManyWithoutUserNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    threadLiked?: UserLikeThreadUncheckedUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUncheckedUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUncheckedUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUncheckedUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUncheckedUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUncheckedUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUncheckedUpdateManyWithoutUserNestedInput
    posts?: GroupPostUncheckedUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUncheckedUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserLikeCommentUpsertWithWhereUniqueWithoutCommentInput = {
    where: UserLikeCommentWhereUniqueInput
    update: XOR<UserLikeCommentUpdateWithoutCommentInput, UserLikeCommentUncheckedUpdateWithoutCommentInput>
    create: XOR<UserLikeCommentCreateWithoutCommentInput, UserLikeCommentUncheckedCreateWithoutCommentInput>
  }

  export type UserLikeCommentUpdateWithWhereUniqueWithoutCommentInput = {
    where: UserLikeCommentWhereUniqueInput
    data: XOR<UserLikeCommentUpdateWithoutCommentInput, UserLikeCommentUncheckedUpdateWithoutCommentInput>
  }

  export type UserLikeCommentUpdateManyWithWhereWithoutCommentInput = {
    where: UserLikeCommentScalarWhereInput
    data: XOR<UserLikeCommentUpdateManyMutationInput, UserLikeCommentUncheckedUpdateManyWithoutUsersLikedInput>
  }

  export type MathProblemCreateWithoutCategoryInput = {
    id: string
    title: string
    link?: string | null
    description?: string | null
    hint?: string | null
    difficulty?: number
    practicePoint?: number | null
    totalPoint?: number | null
    prevProblems?: string | null
    nextProblems?: string | null
    numSolution?: number
    numCheckedSolution?: number
    authors?: AuthorMathProblemCreateNestedManyWithoutMathProblemInput
    tags?: TagMathProblemCreateNestedManyWithoutMathProblemInput
    mathNotes?: MathNoteCreateNestedManyWithoutMathProblemInput
    mathSolutions?: MathSolutionCreateNestedManyWithoutMathProblemInput
    problemSet?: MathSetProbRelCreateNestedManyWithoutProblemInput
  }

  export type MathProblemUncheckedCreateWithoutCategoryInput = {
    id: string
    title: string
    link?: string | null
    description?: string | null
    hint?: string | null
    difficulty?: number
    practicePoint?: number | null
    totalPoint?: number | null
    prevProblems?: string | null
    nextProblems?: string | null
    numSolution?: number
    numCheckedSolution?: number
    authors?: AuthorMathProblemUncheckedCreateNestedManyWithoutMathProblemInput
    tags?: TagMathProblemUncheckedCreateNestedManyWithoutMathProblemInput
    mathNotes?: MathNoteUncheckedCreateNestedManyWithoutMathProblemInput
    mathSolutions?: MathSolutionUncheckedCreateNestedManyWithoutMathProblemInput
    problemSet?: MathSetProbRelUncheckedCreateNestedManyWithoutProblemInput
  }

  export type MathProblemCreateOrConnectWithoutCategoryInput = {
    where: MathProblemWhereUniqueInput
    create: XOR<MathProblemCreateWithoutCategoryInput, MathProblemUncheckedCreateWithoutCategoryInput>
  }

  export type MathProblemCreateManyCategoryInputEnvelope = {
    data: Enumerable<MathProblemCreateManyCategoryInput>
    skipDuplicates?: boolean
  }

  export type MathProblemUpsertWithWhereUniqueWithoutCategoryInput = {
    where: MathProblemWhereUniqueInput
    update: XOR<MathProblemUpdateWithoutCategoryInput, MathProblemUncheckedUpdateWithoutCategoryInput>
    create: XOR<MathProblemCreateWithoutCategoryInput, MathProblemUncheckedCreateWithoutCategoryInput>
  }

  export type MathProblemUpdateWithWhereUniqueWithoutCategoryInput = {
    where: MathProblemWhereUniqueInput
    data: XOR<MathProblemUpdateWithoutCategoryInput, MathProblemUncheckedUpdateWithoutCategoryInput>
  }

  export type MathProblemUpdateManyWithWhereWithoutCategoryInput = {
    where: MathProblemScalarWhereInput
    data: XOR<MathProblemUpdateManyMutationInput, MathProblemUncheckedUpdateManyWithoutMathProblemsInput>
  }

  export type MathProblemScalarWhereInput = {
    AND?: Enumerable<MathProblemScalarWhereInput>
    OR?: Enumerable<MathProblemScalarWhereInput>
    NOT?: Enumerable<MathProblemScalarWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    categoryId?: IntFilter | number
    link?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    hint?: StringNullableFilter | string | null
    difficulty?: IntFilter | number
    practicePoint?: IntNullableFilter | number | null
    totalPoint?: IntNullableFilter | number | null
    prevProblems?: StringNullableFilter | string | null
    nextProblems?: StringNullableFilter | string | null
    numSolution?: IntFilter | number
    numCheckedSolution?: IntFilter | number
  }

  export type TagMathProblemCreateWithoutTagInput = {
    mathProblem: MathProblemCreateNestedOneWithoutTagsInput
  }

  export type TagMathProblemUncheckedCreateWithoutTagInput = {
    mathProblemId: string
  }

  export type TagMathProblemCreateOrConnectWithoutTagInput = {
    where: TagMathProblemWhereUniqueInput
    create: XOR<TagMathProblemCreateWithoutTagInput, TagMathProblemUncheckedCreateWithoutTagInput>
  }

  export type TagMathProblemCreateManyTagInputEnvelope = {
    data: Enumerable<TagMathProblemCreateManyTagInput>
    skipDuplicates?: boolean
  }

  export type TagMathProblemUpsertWithWhereUniqueWithoutTagInput = {
    where: TagMathProblemWhereUniqueInput
    update: XOR<TagMathProblemUpdateWithoutTagInput, TagMathProblemUncheckedUpdateWithoutTagInput>
    create: XOR<TagMathProblemCreateWithoutTagInput, TagMathProblemUncheckedCreateWithoutTagInput>
  }

  export type TagMathProblemUpdateWithWhereUniqueWithoutTagInput = {
    where: TagMathProblemWhereUniqueInput
    data: XOR<TagMathProblemUpdateWithoutTagInput, TagMathProblemUncheckedUpdateWithoutTagInput>
  }

  export type TagMathProblemUpdateManyWithWhereWithoutTagInput = {
    where: TagMathProblemScalarWhereInput
    data: XOR<TagMathProblemUpdateManyMutationInput, TagMathProblemUncheckedUpdateManyWithoutMathProblemsInput>
  }

  export type TagMathProblemScalarWhereInput = {
    AND?: Enumerable<TagMathProblemScalarWhereInput>
    OR?: Enumerable<TagMathProblemScalarWhereInput>
    NOT?: Enumerable<TagMathProblemScalarWhereInput>
    tagId?: IntFilter | number
    mathProblemId?: StringFilter | string
  }

  export type MathProblemCategoryCreateWithoutMathProblemsInput = {
    name: string
  }

  export type MathProblemCategoryUncheckedCreateWithoutMathProblemsInput = {
    id?: number
    name: string
  }

  export type MathProblemCategoryCreateOrConnectWithoutMathProblemsInput = {
    where: MathProblemCategoryWhereUniqueInput
    create: XOR<MathProblemCategoryCreateWithoutMathProblemsInput, MathProblemCategoryUncheckedCreateWithoutMathProblemsInput>
  }

  export type AuthorMathProblemCreateWithoutMathProblemInput = {
    user: UserCreateNestedOneWithoutAuthorMathProblemsInput
  }

  export type AuthorMathProblemUncheckedCreateWithoutMathProblemInput = {
    username: string
  }

  export type AuthorMathProblemCreateOrConnectWithoutMathProblemInput = {
    where: AuthorMathProblemWhereUniqueInput
    create: XOR<AuthorMathProblemCreateWithoutMathProblemInput, AuthorMathProblemUncheckedCreateWithoutMathProblemInput>
  }

  export type AuthorMathProblemCreateManyMathProblemInputEnvelope = {
    data: Enumerable<AuthorMathProblemCreateManyMathProblemInput>
    skipDuplicates?: boolean
  }

  export type TagMathProblemCreateWithoutMathProblemInput = {
    tag: MathProblemTagCreateNestedOneWithoutMathProblemsInput
  }

  export type TagMathProblemUncheckedCreateWithoutMathProblemInput = {
    tagId: number
  }

  export type TagMathProblemCreateOrConnectWithoutMathProblemInput = {
    where: TagMathProblemWhereUniqueInput
    create: XOR<TagMathProblemCreateWithoutMathProblemInput, TagMathProblemUncheckedCreateWithoutMathProblemInput>
  }

  export type TagMathProblemCreateManyMathProblemInputEnvelope = {
    data: Enumerable<TagMathProblemCreateManyMathProblemInput>
    skipDuplicates?: boolean
  }

  export type MathNoteCreateWithoutMathProblemInput = {
    content: string
    createdAt?: Date | string
    imageLink?: string | null
    creator: UserCreateNestedOneWithoutMathNotesInput
  }

  export type MathNoteUncheckedCreateWithoutMathProblemInput = {
    creatorId: string
    content: string
    createdAt?: Date | string
    imageLink?: string | null
  }

  export type MathNoteCreateOrConnectWithoutMathProblemInput = {
    where: MathNoteWhereUniqueInput
    create: XOR<MathNoteCreateWithoutMathProblemInput, MathNoteUncheckedCreateWithoutMathProblemInput>
  }

  export type MathNoteCreateManyMathProblemInputEnvelope = {
    data: Enumerable<MathNoteCreateManyMathProblemInput>
    skipDuplicates?: boolean
  }

  export type MathSolutionCreateWithoutMathProblemInput = {
    content: string
    createdAt?: Date | string
    checked?: boolean
    imageLink?: string | null
    creator: UserCreateNestedOneWithoutMathSolutionsInput
  }

  export type MathSolutionUncheckedCreateWithoutMathProblemInput = {
    creatorId: string
    content: string
    createdAt?: Date | string
    checked?: boolean
    imageLink?: string | null
  }

  export type MathSolutionCreateOrConnectWithoutMathProblemInput = {
    where: MathSolutionWhereUniqueInput
    create: XOR<MathSolutionCreateWithoutMathProblemInput, MathSolutionUncheckedCreateWithoutMathProblemInput>
  }

  export type MathSolutionCreateManyMathProblemInputEnvelope = {
    data: Enumerable<MathSolutionCreateManyMathProblemInput>
    skipDuplicates?: boolean
  }

  export type MathSetProbRelCreateWithoutProblemInput = {
    order: string
    mathProbSet: MathProblemSetCreateNestedOneWithoutProblemsInput
  }

  export type MathSetProbRelUncheckedCreateWithoutProblemInput = {
    setId: string
    order: string
  }

  export type MathSetProbRelCreateOrConnectWithoutProblemInput = {
    where: MathSetProbRelWhereUniqueInput
    create: XOR<MathSetProbRelCreateWithoutProblemInput, MathSetProbRelUncheckedCreateWithoutProblemInput>
  }

  export type MathSetProbRelCreateManyProblemInputEnvelope = {
    data: Enumerable<MathSetProbRelCreateManyProblemInput>
    skipDuplicates?: boolean
  }

  export type MathProblemCategoryUpsertWithoutMathProblemsInput = {
    update: XOR<MathProblemCategoryUpdateWithoutMathProblemsInput, MathProblemCategoryUncheckedUpdateWithoutMathProblemsInput>
    create: XOR<MathProblemCategoryCreateWithoutMathProblemsInput, MathProblemCategoryUncheckedCreateWithoutMathProblemsInput>
  }

  export type MathProblemCategoryUpdateWithoutMathProblemsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MathProblemCategoryUncheckedUpdateWithoutMathProblemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AuthorMathProblemUpsertWithWhereUniqueWithoutMathProblemInput = {
    where: AuthorMathProblemWhereUniqueInput
    update: XOR<AuthorMathProblemUpdateWithoutMathProblemInput, AuthorMathProblemUncheckedUpdateWithoutMathProblemInput>
    create: XOR<AuthorMathProblemCreateWithoutMathProblemInput, AuthorMathProblemUncheckedCreateWithoutMathProblemInput>
  }

  export type AuthorMathProblemUpdateWithWhereUniqueWithoutMathProblemInput = {
    where: AuthorMathProblemWhereUniqueInput
    data: XOR<AuthorMathProblemUpdateWithoutMathProblemInput, AuthorMathProblemUncheckedUpdateWithoutMathProblemInput>
  }

  export type AuthorMathProblemUpdateManyWithWhereWithoutMathProblemInput = {
    where: AuthorMathProblemScalarWhereInput
    data: XOR<AuthorMathProblemUpdateManyMutationInput, AuthorMathProblemUncheckedUpdateManyWithoutAuthorsInput>
  }

  export type TagMathProblemUpsertWithWhereUniqueWithoutMathProblemInput = {
    where: TagMathProblemWhereUniqueInput
    update: XOR<TagMathProblemUpdateWithoutMathProblemInput, TagMathProblemUncheckedUpdateWithoutMathProblemInput>
    create: XOR<TagMathProblemCreateWithoutMathProblemInput, TagMathProblemUncheckedCreateWithoutMathProblemInput>
  }

  export type TagMathProblemUpdateWithWhereUniqueWithoutMathProblemInput = {
    where: TagMathProblemWhereUniqueInput
    data: XOR<TagMathProblemUpdateWithoutMathProblemInput, TagMathProblemUncheckedUpdateWithoutMathProblemInput>
  }

  export type TagMathProblemUpdateManyWithWhereWithoutMathProblemInput = {
    where: TagMathProblemScalarWhereInput
    data: XOR<TagMathProblemUpdateManyMutationInput, TagMathProblemUncheckedUpdateManyWithoutTagsInput>
  }

  export type MathNoteUpsertWithWhereUniqueWithoutMathProblemInput = {
    where: MathNoteWhereUniqueInput
    update: XOR<MathNoteUpdateWithoutMathProblemInput, MathNoteUncheckedUpdateWithoutMathProblemInput>
    create: XOR<MathNoteCreateWithoutMathProblemInput, MathNoteUncheckedCreateWithoutMathProblemInput>
  }

  export type MathNoteUpdateWithWhereUniqueWithoutMathProblemInput = {
    where: MathNoteWhereUniqueInput
    data: XOR<MathNoteUpdateWithoutMathProblemInput, MathNoteUncheckedUpdateWithoutMathProblemInput>
  }

  export type MathNoteUpdateManyWithWhereWithoutMathProblemInput = {
    where: MathNoteScalarWhereInput
    data: XOR<MathNoteUpdateManyMutationInput, MathNoteUncheckedUpdateManyWithoutMathNotesInput>
  }

  export type MathSolutionUpsertWithWhereUniqueWithoutMathProblemInput = {
    where: MathSolutionWhereUniqueInput
    update: XOR<MathSolutionUpdateWithoutMathProblemInput, MathSolutionUncheckedUpdateWithoutMathProblemInput>
    create: XOR<MathSolutionCreateWithoutMathProblemInput, MathSolutionUncheckedCreateWithoutMathProblemInput>
  }

  export type MathSolutionUpdateWithWhereUniqueWithoutMathProblemInput = {
    where: MathSolutionWhereUniqueInput
    data: XOR<MathSolutionUpdateWithoutMathProblemInput, MathSolutionUncheckedUpdateWithoutMathProblemInput>
  }

  export type MathSolutionUpdateManyWithWhereWithoutMathProblemInput = {
    where: MathSolutionScalarWhereInput
    data: XOR<MathSolutionUpdateManyMutationInput, MathSolutionUncheckedUpdateManyWithoutMathSolutionsInput>
  }

  export type MathSetProbRelUpsertWithWhereUniqueWithoutProblemInput = {
    where: MathSetProbRelWhereUniqueInput
    update: XOR<MathSetProbRelUpdateWithoutProblemInput, MathSetProbRelUncheckedUpdateWithoutProblemInput>
    create: XOR<MathSetProbRelCreateWithoutProblemInput, MathSetProbRelUncheckedCreateWithoutProblemInput>
  }

  export type MathSetProbRelUpdateWithWhereUniqueWithoutProblemInput = {
    where: MathSetProbRelWhereUniqueInput
    data: XOR<MathSetProbRelUpdateWithoutProblemInput, MathSetProbRelUncheckedUpdateWithoutProblemInput>
  }

  export type MathSetProbRelUpdateManyWithWhereWithoutProblemInput = {
    where: MathSetProbRelScalarWhereInput
    data: XOR<MathSetProbRelUpdateManyMutationInput, MathSetProbRelUncheckedUpdateManyWithoutProblemSetInput>
  }

  export type MathSetProbRelScalarWhereInput = {
    AND?: Enumerable<MathSetProbRelScalarWhereInput>
    OR?: Enumerable<MathSetProbRelScalarWhereInput>
    NOT?: Enumerable<MathSetProbRelScalarWhereInput>
    problemId?: StringFilter | string
    setId?: StringFilter | string
    order?: StringFilter | string
  }

  export type UserCreateWithoutMathProbSetListInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemCreateNestedManyWithoutUserInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelCreateNestedManyWithoutUserInput
    posts?: GroupPostCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutMathProbSetListInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemUncheckedCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemUncheckedCreateNestedManyWithoutUserInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadUncheckedCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteUncheckedCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionUncheckedCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelUncheckedCreateNestedManyWithoutUserInput
    posts?: GroupPostUncheckedCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserUncheckedCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutMathProbSetListInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMathProbSetListInput, UserUncheckedCreateWithoutMathProbSetListInput>
  }

  export type MathSetProbRelCreateWithoutMathProbSetInput = {
    order: string
    problem: MathProblemCreateNestedOneWithoutProblemSetInput
  }

  export type MathSetProbRelUncheckedCreateWithoutMathProbSetInput = {
    problemId: string
    order: string
  }

  export type MathSetProbRelCreateOrConnectWithoutMathProbSetInput = {
    where: MathSetProbRelWhereUniqueInput
    create: XOR<MathSetProbRelCreateWithoutMathProbSetInput, MathSetProbRelUncheckedCreateWithoutMathProbSetInput>
  }

  export type MathSetProbRelCreateManyMathProbSetInputEnvelope = {
    data: Enumerable<MathSetProbRelCreateManyMathProbSetInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutMathProbSetListInput = {
    update: XOR<UserUpdateWithoutMathProbSetListInput, UserUncheckedUpdateWithoutMathProbSetListInput>
    create: XOR<UserCreateWithoutMathProbSetListInput, UserUncheckedCreateWithoutMathProbSetListInput>
  }

  export type UserUpdateWithoutMathProbSetListInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUpdateManyWithoutUserNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUpdateManyWithoutUserNestedInput
    posts?: GroupPostUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutMathProbSetListInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUncheckedUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUncheckedUpdateManyWithoutUserNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUncheckedUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUncheckedUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUncheckedUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUncheckedUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUncheckedUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUncheckedUpdateManyWithoutUserNestedInput
    posts?: GroupPostUncheckedUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUncheckedUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type MathSetProbRelUpsertWithWhereUniqueWithoutMathProbSetInput = {
    where: MathSetProbRelWhereUniqueInput
    update: XOR<MathSetProbRelUpdateWithoutMathProbSetInput, MathSetProbRelUncheckedUpdateWithoutMathProbSetInput>
    create: XOR<MathSetProbRelCreateWithoutMathProbSetInput, MathSetProbRelUncheckedCreateWithoutMathProbSetInput>
  }

  export type MathSetProbRelUpdateWithWhereUniqueWithoutMathProbSetInput = {
    where: MathSetProbRelWhereUniqueInput
    data: XOR<MathSetProbRelUpdateWithoutMathProbSetInput, MathSetProbRelUncheckedUpdateWithoutMathProbSetInput>
  }

  export type MathSetProbRelUpdateManyWithWhereWithoutMathProbSetInput = {
    where: MathSetProbRelScalarWhereInput
    data: XOR<MathSetProbRelUpdateManyMutationInput, MathSetProbRelUncheckedUpdateManyWithoutProblemsInput>
  }

  export type MathProblemCreateWithoutProblemSetInput = {
    id: string
    title: string
    link?: string | null
    description?: string | null
    hint?: string | null
    difficulty?: number
    practicePoint?: number | null
    totalPoint?: number | null
    prevProblems?: string | null
    nextProblems?: string | null
    numSolution?: number
    numCheckedSolution?: number
    category: MathProblemCategoryCreateNestedOneWithoutMathProblemsInput
    authors?: AuthorMathProblemCreateNestedManyWithoutMathProblemInput
    tags?: TagMathProblemCreateNestedManyWithoutMathProblemInput
    mathNotes?: MathNoteCreateNestedManyWithoutMathProblemInput
    mathSolutions?: MathSolutionCreateNestedManyWithoutMathProblemInput
  }

  export type MathProblemUncheckedCreateWithoutProblemSetInput = {
    id: string
    title: string
    categoryId: number
    link?: string | null
    description?: string | null
    hint?: string | null
    difficulty?: number
    practicePoint?: number | null
    totalPoint?: number | null
    prevProblems?: string | null
    nextProblems?: string | null
    numSolution?: number
    numCheckedSolution?: number
    authors?: AuthorMathProblemUncheckedCreateNestedManyWithoutMathProblemInput
    tags?: TagMathProblemUncheckedCreateNestedManyWithoutMathProblemInput
    mathNotes?: MathNoteUncheckedCreateNestedManyWithoutMathProblemInput
    mathSolutions?: MathSolutionUncheckedCreateNestedManyWithoutMathProblemInput
  }

  export type MathProblemCreateOrConnectWithoutProblemSetInput = {
    where: MathProblemWhereUniqueInput
    create: XOR<MathProblemCreateWithoutProblemSetInput, MathProblemUncheckedCreateWithoutProblemSetInput>
  }

  export type MathProblemSetCreateWithoutProblemsInput = {
    id: string
    title: string
    numberProb: number
    creator: UserCreateNestedOneWithoutMathProbSetListInput
  }

  export type MathProblemSetUncheckedCreateWithoutProblemsInput = {
    id: string
    title: string
    creatorId: string
    numberProb: number
  }

  export type MathProblemSetCreateOrConnectWithoutProblemsInput = {
    where: MathProblemSetWhereUniqueInput
    create: XOR<MathProblemSetCreateWithoutProblemsInput, MathProblemSetUncheckedCreateWithoutProblemsInput>
  }

  export type MathProblemUpsertWithoutProblemSetInput = {
    update: XOR<MathProblemUpdateWithoutProblemSetInput, MathProblemUncheckedUpdateWithoutProblemSetInput>
    create: XOR<MathProblemCreateWithoutProblemSetInput, MathProblemUncheckedCreateWithoutProblemSetInput>
  }

  export type MathProblemUpdateWithoutProblemSetInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: NullableIntFieldUpdateOperationsInput | number | null
    totalPoint?: NullableIntFieldUpdateOperationsInput | number | null
    prevProblems?: NullableStringFieldUpdateOperationsInput | string | null
    nextProblems?: NullableStringFieldUpdateOperationsInput | string | null
    numSolution?: IntFieldUpdateOperationsInput | number
    numCheckedSolution?: IntFieldUpdateOperationsInput | number
    category?: MathProblemCategoryUpdateOneRequiredWithoutMathProblemsNestedInput
    authors?: AuthorMathProblemUpdateManyWithoutMathProblemNestedInput
    tags?: TagMathProblemUpdateManyWithoutMathProblemNestedInput
    mathNotes?: MathNoteUpdateManyWithoutMathProblemNestedInput
    mathSolutions?: MathSolutionUpdateManyWithoutMathProblemNestedInput
  }

  export type MathProblemUncheckedUpdateWithoutProblemSetInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: NullableIntFieldUpdateOperationsInput | number | null
    totalPoint?: NullableIntFieldUpdateOperationsInput | number | null
    prevProblems?: NullableStringFieldUpdateOperationsInput | string | null
    nextProblems?: NullableStringFieldUpdateOperationsInput | string | null
    numSolution?: IntFieldUpdateOperationsInput | number
    numCheckedSolution?: IntFieldUpdateOperationsInput | number
    authors?: AuthorMathProblemUncheckedUpdateManyWithoutMathProblemNestedInput
    tags?: TagMathProblemUncheckedUpdateManyWithoutMathProblemNestedInput
    mathNotes?: MathNoteUncheckedUpdateManyWithoutMathProblemNestedInput
    mathSolutions?: MathSolutionUncheckedUpdateManyWithoutMathProblemNestedInput
  }

  export type MathProblemSetUpsertWithoutProblemsInput = {
    update: XOR<MathProblemSetUpdateWithoutProblemsInput, MathProblemSetUncheckedUpdateWithoutProblemsInput>
    create: XOR<MathProblemSetCreateWithoutProblemsInput, MathProblemSetUncheckedCreateWithoutProblemsInput>
  }

  export type MathProblemSetUpdateWithoutProblemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    numberProb?: IntFieldUpdateOperationsInput | number
    creator?: UserUpdateOneRequiredWithoutMathProbSetListNestedInput
  }

  export type MathProblemSetUncheckedUpdateWithoutProblemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    numberProb?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateWithoutAuthorMathProblemsInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemCreateNestedManyWithoutUserInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelCreateNestedManyWithoutUserInput
    posts?: GroupPostCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutAuthorMathProblemsInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemUncheckedCreateNestedManyWithoutUserInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadUncheckedCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteUncheckedCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionUncheckedCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetUncheckedCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelUncheckedCreateNestedManyWithoutUserInput
    posts?: GroupPostUncheckedCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserUncheckedCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutAuthorMathProblemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuthorMathProblemsInput, UserUncheckedCreateWithoutAuthorMathProblemsInput>
  }

  export type MathProblemCreateWithoutAuthorsInput = {
    id: string
    title: string
    link?: string | null
    description?: string | null
    hint?: string | null
    difficulty?: number
    practicePoint?: number | null
    totalPoint?: number | null
    prevProblems?: string | null
    nextProblems?: string | null
    numSolution?: number
    numCheckedSolution?: number
    category: MathProblemCategoryCreateNestedOneWithoutMathProblemsInput
    tags?: TagMathProblemCreateNestedManyWithoutMathProblemInput
    mathNotes?: MathNoteCreateNestedManyWithoutMathProblemInput
    mathSolutions?: MathSolutionCreateNestedManyWithoutMathProblemInput
    problemSet?: MathSetProbRelCreateNestedManyWithoutProblemInput
  }

  export type MathProblemUncheckedCreateWithoutAuthorsInput = {
    id: string
    title: string
    categoryId: number
    link?: string | null
    description?: string | null
    hint?: string | null
    difficulty?: number
    practicePoint?: number | null
    totalPoint?: number | null
    prevProblems?: string | null
    nextProblems?: string | null
    numSolution?: number
    numCheckedSolution?: number
    tags?: TagMathProblemUncheckedCreateNestedManyWithoutMathProblemInput
    mathNotes?: MathNoteUncheckedCreateNestedManyWithoutMathProblemInput
    mathSolutions?: MathSolutionUncheckedCreateNestedManyWithoutMathProblemInput
    problemSet?: MathSetProbRelUncheckedCreateNestedManyWithoutProblemInput
  }

  export type MathProblemCreateOrConnectWithoutAuthorsInput = {
    where: MathProblemWhereUniqueInput
    create: XOR<MathProblemCreateWithoutAuthorsInput, MathProblemUncheckedCreateWithoutAuthorsInput>
  }

  export type UserUpsertWithoutAuthorMathProblemsInput = {
    update: XOR<UserUpdateWithoutAuthorMathProblemsInput, UserUncheckedUpdateWithoutAuthorMathProblemsInput>
    create: XOR<UserCreateWithoutAuthorMathProblemsInput, UserUncheckedCreateWithoutAuthorMathProblemsInput>
  }

  export type UserUpdateWithoutAuthorMathProblemsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUpdateManyWithoutUserNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUpdateManyWithoutUserNestedInput
    posts?: GroupPostUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutAuthorMathProblemsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUncheckedUpdateManyWithoutUserNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUncheckedUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUncheckedUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUncheckedUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUncheckedUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUncheckedUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUncheckedUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUncheckedUpdateManyWithoutUserNestedInput
    posts?: GroupPostUncheckedUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUncheckedUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type MathProblemUpsertWithoutAuthorsInput = {
    update: XOR<MathProblemUpdateWithoutAuthorsInput, MathProblemUncheckedUpdateWithoutAuthorsInput>
    create: XOR<MathProblemCreateWithoutAuthorsInput, MathProblemUncheckedCreateWithoutAuthorsInput>
  }

  export type MathProblemUpdateWithoutAuthorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: NullableIntFieldUpdateOperationsInput | number | null
    totalPoint?: NullableIntFieldUpdateOperationsInput | number | null
    prevProblems?: NullableStringFieldUpdateOperationsInput | string | null
    nextProblems?: NullableStringFieldUpdateOperationsInput | string | null
    numSolution?: IntFieldUpdateOperationsInput | number
    numCheckedSolution?: IntFieldUpdateOperationsInput | number
    category?: MathProblemCategoryUpdateOneRequiredWithoutMathProblemsNestedInput
    tags?: TagMathProblemUpdateManyWithoutMathProblemNestedInput
    mathNotes?: MathNoteUpdateManyWithoutMathProblemNestedInput
    mathSolutions?: MathSolutionUpdateManyWithoutMathProblemNestedInput
    problemSet?: MathSetProbRelUpdateManyWithoutProblemNestedInput
  }

  export type MathProblemUncheckedUpdateWithoutAuthorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: NullableIntFieldUpdateOperationsInput | number | null
    totalPoint?: NullableIntFieldUpdateOperationsInput | number | null
    prevProblems?: NullableStringFieldUpdateOperationsInput | string | null
    nextProblems?: NullableStringFieldUpdateOperationsInput | string | null
    numSolution?: IntFieldUpdateOperationsInput | number
    numCheckedSolution?: IntFieldUpdateOperationsInput | number
    tags?: TagMathProblemUncheckedUpdateManyWithoutMathProblemNestedInput
    mathNotes?: MathNoteUncheckedUpdateManyWithoutMathProblemNestedInput
    mathSolutions?: MathSolutionUncheckedUpdateManyWithoutMathProblemNestedInput
    problemSet?: MathSetProbRelUncheckedUpdateManyWithoutProblemNestedInput
  }

  export type MathProblemTagCreateWithoutMathProblemsInput = {
    name: string
    parentId?: number | null
    nextSibling?: number | null
    prevSibling?: number | null
  }

  export type MathProblemTagUncheckedCreateWithoutMathProblemsInput = {
    id?: number
    name: string
    parentId?: number | null
    nextSibling?: number | null
    prevSibling?: number | null
  }

  export type MathProblemTagCreateOrConnectWithoutMathProblemsInput = {
    where: MathProblemTagWhereUniqueInput
    create: XOR<MathProblemTagCreateWithoutMathProblemsInput, MathProblemTagUncheckedCreateWithoutMathProblemsInput>
  }

  export type MathProblemCreateWithoutTagsInput = {
    id: string
    title: string
    link?: string | null
    description?: string | null
    hint?: string | null
    difficulty?: number
    practicePoint?: number | null
    totalPoint?: number | null
    prevProblems?: string | null
    nextProblems?: string | null
    numSolution?: number
    numCheckedSolution?: number
    category: MathProblemCategoryCreateNestedOneWithoutMathProblemsInput
    authors?: AuthorMathProblemCreateNestedManyWithoutMathProblemInput
    mathNotes?: MathNoteCreateNestedManyWithoutMathProblemInput
    mathSolutions?: MathSolutionCreateNestedManyWithoutMathProblemInput
    problemSet?: MathSetProbRelCreateNestedManyWithoutProblemInput
  }

  export type MathProblemUncheckedCreateWithoutTagsInput = {
    id: string
    title: string
    categoryId: number
    link?: string | null
    description?: string | null
    hint?: string | null
    difficulty?: number
    practicePoint?: number | null
    totalPoint?: number | null
    prevProblems?: string | null
    nextProblems?: string | null
    numSolution?: number
    numCheckedSolution?: number
    authors?: AuthorMathProblemUncheckedCreateNestedManyWithoutMathProblemInput
    mathNotes?: MathNoteUncheckedCreateNestedManyWithoutMathProblemInput
    mathSolutions?: MathSolutionUncheckedCreateNestedManyWithoutMathProblemInput
    problemSet?: MathSetProbRelUncheckedCreateNestedManyWithoutProblemInput
  }

  export type MathProblemCreateOrConnectWithoutTagsInput = {
    where: MathProblemWhereUniqueInput
    create: XOR<MathProblemCreateWithoutTagsInput, MathProblemUncheckedCreateWithoutTagsInput>
  }

  export type MathProblemTagUpsertWithoutMathProblemsInput = {
    update: XOR<MathProblemTagUpdateWithoutMathProblemsInput, MathProblemTagUncheckedUpdateWithoutMathProblemsInput>
    create: XOR<MathProblemTagCreateWithoutMathProblemsInput, MathProblemTagUncheckedCreateWithoutMathProblemsInput>
  }

  export type MathProblemTagUpdateWithoutMathProblemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    nextSibling?: NullableIntFieldUpdateOperationsInput | number | null
    prevSibling?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MathProblemTagUncheckedUpdateWithoutMathProblemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    nextSibling?: NullableIntFieldUpdateOperationsInput | number | null
    prevSibling?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MathProblemUpsertWithoutTagsInput = {
    update: XOR<MathProblemUpdateWithoutTagsInput, MathProblemUncheckedUpdateWithoutTagsInput>
    create: XOR<MathProblemCreateWithoutTagsInput, MathProblemUncheckedCreateWithoutTagsInput>
  }

  export type MathProblemUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: NullableIntFieldUpdateOperationsInput | number | null
    totalPoint?: NullableIntFieldUpdateOperationsInput | number | null
    prevProblems?: NullableStringFieldUpdateOperationsInput | string | null
    nextProblems?: NullableStringFieldUpdateOperationsInput | string | null
    numSolution?: IntFieldUpdateOperationsInput | number
    numCheckedSolution?: IntFieldUpdateOperationsInput | number
    category?: MathProblemCategoryUpdateOneRequiredWithoutMathProblemsNestedInput
    authors?: AuthorMathProblemUpdateManyWithoutMathProblemNestedInput
    mathNotes?: MathNoteUpdateManyWithoutMathProblemNestedInput
    mathSolutions?: MathSolutionUpdateManyWithoutMathProblemNestedInput
    problemSet?: MathSetProbRelUpdateManyWithoutProblemNestedInput
  }

  export type MathProblemUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: NullableIntFieldUpdateOperationsInput | number | null
    totalPoint?: NullableIntFieldUpdateOperationsInput | number | null
    prevProblems?: NullableStringFieldUpdateOperationsInput | string | null
    nextProblems?: NullableStringFieldUpdateOperationsInput | string | null
    numSolution?: IntFieldUpdateOperationsInput | number
    numCheckedSolution?: IntFieldUpdateOperationsInput | number
    authors?: AuthorMathProblemUncheckedUpdateManyWithoutMathProblemNestedInput
    mathNotes?: MathNoteUncheckedUpdateManyWithoutMathProblemNestedInput
    mathSolutions?: MathSolutionUncheckedUpdateManyWithoutMathProblemNestedInput
    problemSet?: MathSetProbRelUncheckedUpdateManyWithoutProblemNestedInput
  }

  export type UserCreateWithoutPostsInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemCreateNestedManyWithoutUserInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutPostsInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemUncheckedCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemUncheckedCreateNestedManyWithoutUserInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadUncheckedCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteUncheckedCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionUncheckedCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetUncheckedCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserUncheckedCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type GroupCreateWithoutPostsInput = {
    id?: string
    name: string
    generalChatSessionId?: string | null
    createdAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedGroupInput
    users?: UserGroupRelCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    creatorId: string
    generalChatSessionId?: string | null
    createdAt?: Date | string
    users?: UserGroupRelUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutPostsInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutPostsInput, GroupUncheckedCreateWithoutPostsInput>
  }

  export type GroupPostMessageCreateWithoutPostInput = {
    id: string
    content: string
    createdAt?: Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
    author: UserCreateNestedOneWithoutGroupPostMessagesInput
  }

  export type GroupPostMessageUncheckedCreateWithoutPostInput = {
    id: string
    content: string
    authorId: string
    createdAt?: Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GroupPostMessageCreateOrConnectWithoutPostInput = {
    where: GroupPostMessageWhereUniqueInput
    create: XOR<GroupPostMessageCreateWithoutPostInput, GroupPostMessageUncheckedCreateWithoutPostInput>
  }

  export type GroupPostMessageCreateManyPostInputEnvelope = {
    data: Enumerable<GroupPostMessageCreateManyPostInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPostsInput = {
    update: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type UserUpdateWithoutPostsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUpdateManyWithoutUserNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutPostsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUncheckedUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUncheckedUpdateManyWithoutUserNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUncheckedUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUncheckedUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUncheckedUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUncheckedUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUncheckedUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUncheckedUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUncheckedUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type GroupUpsertWithoutPostsInput = {
    update: XOR<GroupUpdateWithoutPostsInput, GroupUncheckedUpdateWithoutPostsInput>
    create: XOR<GroupCreateWithoutPostsInput, GroupUncheckedCreateWithoutPostsInput>
  }

  export type GroupUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generalChatSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedGroupNestedInput
    users?: UserGroupRelUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    generalChatSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserGroupRelUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupPostMessageUpsertWithWhereUniqueWithoutPostInput = {
    where: GroupPostMessageWhereUniqueInput
    update: XOR<GroupPostMessageUpdateWithoutPostInput, GroupPostMessageUncheckedUpdateWithoutPostInput>
    create: XOR<GroupPostMessageCreateWithoutPostInput, GroupPostMessageUncheckedCreateWithoutPostInput>
  }

  export type GroupPostMessageUpdateWithWhereUniqueWithoutPostInput = {
    where: GroupPostMessageWhereUniqueInput
    data: XOR<GroupPostMessageUpdateWithoutPostInput, GroupPostMessageUncheckedUpdateWithoutPostInput>
  }

  export type GroupPostMessageUpdateManyWithWhereWithoutPostInput = {
    where: GroupPostMessageScalarWhereInput
    data: XOR<GroupPostMessageUpdateManyMutationInput, GroupPostMessageUncheckedUpdateManyWithoutMessagesInput>
  }

  export type UserCreateWithoutChatMessagesInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemCreateNestedManyWithoutUserInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelCreateNestedManyWithoutUserInput
    posts?: GroupPostCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutChatMessagesInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemUncheckedCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemUncheckedCreateNestedManyWithoutUserInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadUncheckedCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteUncheckedCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionUncheckedCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetUncheckedCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelUncheckedCreateNestedManyWithoutUserInput
    posts?: GroupPostUncheckedCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserUncheckedCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutChatMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatMessagesInput, UserUncheckedCreateWithoutChatMessagesInput>
  }

  export type ChatSessionCreateWithoutChatMessagesInput = {
    id: string
    lastMessage: JsonNullValueInput | InputJsonValue
    lastUpdate: Date | string
    groupId?: string | null
    type: ChatSessionType
    usersInfo?: NullableJsonNullValueInput | InputJsonValue
    users?: ChatSessionUserCreateNestedManyWithoutChatSessionInput
  }

  export type ChatSessionUncheckedCreateWithoutChatMessagesInput = {
    id: string
    lastMessage: JsonNullValueInput | InputJsonValue
    lastUpdate: Date | string
    groupId?: string | null
    type: ChatSessionType
    usersInfo?: NullableJsonNullValueInput | InputJsonValue
    users?: ChatSessionUserUncheckedCreateNestedManyWithoutChatSessionInput
  }

  export type ChatSessionCreateOrConnectWithoutChatMessagesInput = {
    where: ChatSessionWhereUniqueInput
    create: XOR<ChatSessionCreateWithoutChatMessagesInput, ChatSessionUncheckedCreateWithoutChatMessagesInput>
  }

  export type UserUpsertWithoutChatMessagesInput = {
    update: XOR<UserUpdateWithoutChatMessagesInput, UserUncheckedUpdateWithoutChatMessagesInput>
    create: XOR<UserCreateWithoutChatMessagesInput, UserUncheckedCreateWithoutChatMessagesInput>
  }

  export type UserUpdateWithoutChatMessagesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUpdateManyWithoutUserNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUpdateManyWithoutUserNestedInput
    posts?: GroupPostUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutChatMessagesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUncheckedUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUncheckedUpdateManyWithoutUserNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUncheckedUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUncheckedUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUncheckedUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUncheckedUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUncheckedUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUncheckedUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUncheckedUpdateManyWithoutUserNestedInput
    posts?: GroupPostUncheckedUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUncheckedUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type ChatSessionUpsertWithoutChatMessagesInput = {
    update: XOR<ChatSessionUpdateWithoutChatMessagesInput, ChatSessionUncheckedUpdateWithoutChatMessagesInput>
    create: XOR<ChatSessionCreateWithoutChatMessagesInput, ChatSessionUncheckedCreateWithoutChatMessagesInput>
  }

  export type ChatSessionUpdateWithoutChatMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessage?: JsonNullValueInput | InputJsonValue
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChatSessionTypeFieldUpdateOperationsInput | ChatSessionType
    usersInfo?: NullableJsonNullValueInput | InputJsonValue
    users?: ChatSessionUserUpdateManyWithoutChatSessionNestedInput
  }

  export type ChatSessionUncheckedUpdateWithoutChatMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessage?: JsonNullValueInput | InputJsonValue
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChatSessionTypeFieldUpdateOperationsInput | ChatSessionType
    usersInfo?: NullableJsonNullValueInput | InputJsonValue
    users?: ChatSessionUserUncheckedUpdateManyWithoutChatSessionNestedInput
  }

  export type UserCreateWithoutGroupPostMessagesInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemCreateNestedManyWithoutUserInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelCreateNestedManyWithoutUserInput
    posts?: GroupPostCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGroupPostMessagesInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemUncheckedCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemUncheckedCreateNestedManyWithoutUserInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadUncheckedCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteUncheckedCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionUncheckedCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetUncheckedCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelUncheckedCreateNestedManyWithoutUserInput
    posts?: GroupPostUncheckedCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGroupPostMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGroupPostMessagesInput, UserUncheckedCreateWithoutGroupPostMessagesInput>
  }

  export type GroupPostCreateWithoutMessagesInput = {
    id: string
    content: string
    createdAt?: Date | string
    title: string
    author: UserCreateNestedOneWithoutPostsInput
    group: GroupCreateNestedOneWithoutPostsInput
  }

  export type GroupPostUncheckedCreateWithoutMessagesInput = {
    id: string
    content: string
    authorId: string
    createdAt?: Date | string
    groupId: string
    title: string
  }

  export type GroupPostCreateOrConnectWithoutMessagesInput = {
    where: GroupPostWhereUniqueInput
    create: XOR<GroupPostCreateWithoutMessagesInput, GroupPostUncheckedCreateWithoutMessagesInput>
  }

  export type UserUpsertWithoutGroupPostMessagesInput = {
    update: XOR<UserUpdateWithoutGroupPostMessagesInput, UserUncheckedUpdateWithoutGroupPostMessagesInput>
    create: XOR<UserCreateWithoutGroupPostMessagesInput, UserUncheckedCreateWithoutGroupPostMessagesInput>
  }

  export type UserUpdateWithoutGroupPostMessagesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUpdateManyWithoutUserNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUpdateManyWithoutUserNestedInput
    posts?: GroupPostUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGroupPostMessagesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUncheckedUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUncheckedUpdateManyWithoutUserNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUncheckedUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUncheckedUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUncheckedUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUncheckedUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUncheckedUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUncheckedUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUncheckedUpdateManyWithoutUserNestedInput
    posts?: GroupPostUncheckedUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GroupPostUpsertWithoutMessagesInput = {
    update: XOR<GroupPostUpdateWithoutMessagesInput, GroupPostUncheckedUpdateWithoutMessagesInput>
    create: XOR<GroupPostCreateWithoutMessagesInput, GroupPostUncheckedCreateWithoutMessagesInput>
  }

  export type GroupPostUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
    group?: GroupUpdateOneRequiredWithoutPostsNestedInput
  }

  export type GroupPostUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type ChatMessageCreateWithoutChatSessionInput = {
    id: string
    content: string
    createdAt?: Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
    author: UserCreateNestedOneWithoutChatMessagesInput
  }

  export type ChatMessageUncheckedCreateWithoutChatSessionInput = {
    id: string
    content: string
    authorId: string
    createdAt?: Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ChatMessageCreateOrConnectWithoutChatSessionInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutChatSessionInput, ChatMessageUncheckedCreateWithoutChatSessionInput>
  }

  export type ChatMessageCreateManyChatSessionInputEnvelope = {
    data: Enumerable<ChatMessageCreateManyChatSessionInput>
    skipDuplicates?: boolean
  }

  export type ChatSessionUserCreateWithoutChatSessionInput = {
    unseenCnt?: number
    joinedAt: Date | string
    user: UserCreateNestedOneWithoutChatSessionsInput
  }

  export type ChatSessionUserUncheckedCreateWithoutChatSessionInput = {
    username: string
    unseenCnt?: number
    joinedAt: Date | string
  }

  export type ChatSessionUserCreateOrConnectWithoutChatSessionInput = {
    where: ChatSessionUserWhereUniqueInput
    create: XOR<ChatSessionUserCreateWithoutChatSessionInput, ChatSessionUserUncheckedCreateWithoutChatSessionInput>
  }

  export type ChatSessionUserCreateManyChatSessionInputEnvelope = {
    data: Enumerable<ChatSessionUserCreateManyChatSessionInput>
    skipDuplicates?: boolean
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutChatSessionInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutChatSessionInput, ChatMessageUncheckedUpdateWithoutChatSessionInput>
    create: XOR<ChatMessageCreateWithoutChatSessionInput, ChatMessageUncheckedCreateWithoutChatSessionInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutChatSessionInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutChatSessionInput, ChatMessageUncheckedUpdateWithoutChatSessionInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutChatSessionInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutChatMessagesInput>
  }

  export type ChatSessionUserUpsertWithWhereUniqueWithoutChatSessionInput = {
    where: ChatSessionUserWhereUniqueInput
    update: XOR<ChatSessionUserUpdateWithoutChatSessionInput, ChatSessionUserUncheckedUpdateWithoutChatSessionInput>
    create: XOR<ChatSessionUserCreateWithoutChatSessionInput, ChatSessionUserUncheckedCreateWithoutChatSessionInput>
  }

  export type ChatSessionUserUpdateWithWhereUniqueWithoutChatSessionInput = {
    where: ChatSessionUserWhereUniqueInput
    data: XOR<ChatSessionUserUpdateWithoutChatSessionInput, ChatSessionUserUncheckedUpdateWithoutChatSessionInput>
  }

  export type ChatSessionUserUpdateManyWithWhereWithoutChatSessionInput = {
    where: ChatSessionUserScalarWhereInput
    data: XOR<ChatSessionUserUpdateManyMutationInput, ChatSessionUserUncheckedUpdateManyWithoutUsersInput>
  }

  export type ChatSessionCreateWithoutUsersInput = {
    id: string
    lastMessage: JsonNullValueInput | InputJsonValue
    lastUpdate: Date | string
    groupId?: string | null
    type: ChatSessionType
    usersInfo?: NullableJsonNullValueInput | InputJsonValue
    chatMessages?: ChatMessageCreateNestedManyWithoutChatSessionInput
  }

  export type ChatSessionUncheckedCreateWithoutUsersInput = {
    id: string
    lastMessage: JsonNullValueInput | InputJsonValue
    lastUpdate: Date | string
    groupId?: string | null
    type: ChatSessionType
    usersInfo?: NullableJsonNullValueInput | InputJsonValue
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutChatSessionInput
  }

  export type ChatSessionCreateOrConnectWithoutUsersInput = {
    where: ChatSessionWhereUniqueInput
    create: XOR<ChatSessionCreateWithoutUsersInput, ChatSessionUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutChatSessionsInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemCreateNestedManyWithoutUserInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelCreateNestedManyWithoutUserInput
    posts?: GroupPostCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageCreateNestedManyWithoutAuthorInput
    groupPostMessages?: GroupPostMessageCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutChatSessionsInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemUncheckedCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemUncheckedCreateNestedManyWithoutUserInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadUncheckedCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteUncheckedCreateNestedManyWithoutCreatorInput
    mathSolutions?: MathSolutionUncheckedCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetUncheckedCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelUncheckedCreateNestedManyWithoutUserInput
    posts?: GroupPostUncheckedCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutAuthorInput
    groupPostMessages?: GroupPostMessageUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutChatSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatSessionsInput, UserUncheckedCreateWithoutChatSessionsInput>
  }

  export type ChatSessionUpsertWithoutUsersInput = {
    update: XOR<ChatSessionUpdateWithoutUsersInput, ChatSessionUncheckedUpdateWithoutUsersInput>
    create: XOR<ChatSessionCreateWithoutUsersInput, ChatSessionUncheckedCreateWithoutUsersInput>
  }

  export type ChatSessionUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessage?: JsonNullValueInput | InputJsonValue
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChatSessionTypeFieldUpdateOperationsInput | ChatSessionType
    usersInfo?: NullableJsonNullValueInput | InputJsonValue
    chatMessages?: ChatMessageUpdateManyWithoutChatSessionNestedInput
  }

  export type ChatSessionUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessage?: JsonNullValueInput | InputJsonValue
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChatSessionTypeFieldUpdateOperationsInput | ChatSessionType
    usersInfo?: NullableJsonNullValueInput | InputJsonValue
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutChatSessionNestedInput
  }

  export type UserUpsertWithoutChatSessionsInput = {
    update: XOR<UserUpdateWithoutChatSessionsInput, UserUncheckedUpdateWithoutChatSessionsInput>
    create: XOR<UserCreateWithoutChatSessionsInput, UserUncheckedCreateWithoutChatSessionsInput>
  }

  export type UserUpdateWithoutChatSessionsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUpdateManyWithoutUserNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUpdateManyWithoutUserNestedInput
    posts?: GroupPostUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutAuthorNestedInput
    groupPostMessages?: GroupPostMessageUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutChatSessionsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUncheckedUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUncheckedUpdateManyWithoutUserNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUncheckedUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUncheckedUpdateManyWithoutCreatorNestedInput
    mathSolutions?: MathSolutionUncheckedUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUncheckedUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUncheckedUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUncheckedUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUncheckedUpdateManyWithoutUserNestedInput
    posts?: GroupPostUncheckedUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutAuthorNestedInput
    groupPostMessages?: GroupPostMessageUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateWithoutMathNotesInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemCreateNestedManyWithoutUserInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedOneWithoutUserInput
    mathSolutions?: MathSolutionCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelCreateNestedManyWithoutUserInput
    posts?: GroupPostCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutMathNotesInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemUncheckedCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemUncheckedCreateNestedManyWithoutUserInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadUncheckedCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    mathSolutions?: MathSolutionUncheckedCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetUncheckedCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelUncheckedCreateNestedManyWithoutUserInput
    posts?: GroupPostUncheckedCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserUncheckedCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutMathNotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMathNotesInput, UserUncheckedCreateWithoutMathNotesInput>
  }

  export type MathProblemCreateWithoutMathNotesInput = {
    id: string
    title: string
    link?: string | null
    description?: string | null
    hint?: string | null
    difficulty?: number
    practicePoint?: number | null
    totalPoint?: number | null
    prevProblems?: string | null
    nextProblems?: string | null
    numSolution?: number
    numCheckedSolution?: number
    category: MathProblemCategoryCreateNestedOneWithoutMathProblemsInput
    authors?: AuthorMathProblemCreateNestedManyWithoutMathProblemInput
    tags?: TagMathProblemCreateNestedManyWithoutMathProblemInput
    mathSolutions?: MathSolutionCreateNestedManyWithoutMathProblemInput
    problemSet?: MathSetProbRelCreateNestedManyWithoutProblemInput
  }

  export type MathProblemUncheckedCreateWithoutMathNotesInput = {
    id: string
    title: string
    categoryId: number
    link?: string | null
    description?: string | null
    hint?: string | null
    difficulty?: number
    practicePoint?: number | null
    totalPoint?: number | null
    prevProblems?: string | null
    nextProblems?: string | null
    numSolution?: number
    numCheckedSolution?: number
    authors?: AuthorMathProblemUncheckedCreateNestedManyWithoutMathProblemInput
    tags?: TagMathProblemUncheckedCreateNestedManyWithoutMathProblemInput
    mathSolutions?: MathSolutionUncheckedCreateNestedManyWithoutMathProblemInput
    problemSet?: MathSetProbRelUncheckedCreateNestedManyWithoutProblemInput
  }

  export type MathProblemCreateOrConnectWithoutMathNotesInput = {
    where: MathProblemWhereUniqueInput
    create: XOR<MathProblemCreateWithoutMathNotesInput, MathProblemUncheckedCreateWithoutMathNotesInput>
  }

  export type UserUpsertWithoutMathNotesInput = {
    update: XOR<UserUpdateWithoutMathNotesInput, UserUncheckedUpdateWithoutMathNotesInput>
    create: XOR<UserCreateWithoutMathNotesInput, UserUncheckedCreateWithoutMathNotesInput>
  }

  export type UserUpdateWithoutMathNotesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUpdateManyWithoutUserNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUpdateOneWithoutUserNestedInput
    mathSolutions?: MathSolutionUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUpdateManyWithoutUserNestedInput
    posts?: GroupPostUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutMathNotesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUncheckedUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUncheckedUpdateManyWithoutUserNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUncheckedUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    mathSolutions?: MathSolutionUncheckedUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUncheckedUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUncheckedUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUncheckedUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUncheckedUpdateManyWithoutUserNestedInput
    posts?: GroupPostUncheckedUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUncheckedUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type MathProblemUpsertWithoutMathNotesInput = {
    update: XOR<MathProblemUpdateWithoutMathNotesInput, MathProblemUncheckedUpdateWithoutMathNotesInput>
    create: XOR<MathProblemCreateWithoutMathNotesInput, MathProblemUncheckedCreateWithoutMathNotesInput>
  }

  export type MathProblemUpdateWithoutMathNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: NullableIntFieldUpdateOperationsInput | number | null
    totalPoint?: NullableIntFieldUpdateOperationsInput | number | null
    prevProblems?: NullableStringFieldUpdateOperationsInput | string | null
    nextProblems?: NullableStringFieldUpdateOperationsInput | string | null
    numSolution?: IntFieldUpdateOperationsInput | number
    numCheckedSolution?: IntFieldUpdateOperationsInput | number
    category?: MathProblemCategoryUpdateOneRequiredWithoutMathProblemsNestedInput
    authors?: AuthorMathProblemUpdateManyWithoutMathProblemNestedInput
    tags?: TagMathProblemUpdateManyWithoutMathProblemNestedInput
    mathSolutions?: MathSolutionUpdateManyWithoutMathProblemNestedInput
    problemSet?: MathSetProbRelUpdateManyWithoutProblemNestedInput
  }

  export type MathProblemUncheckedUpdateWithoutMathNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: NullableIntFieldUpdateOperationsInput | number | null
    totalPoint?: NullableIntFieldUpdateOperationsInput | number | null
    prevProblems?: NullableStringFieldUpdateOperationsInput | string | null
    nextProblems?: NullableStringFieldUpdateOperationsInput | string | null
    numSolution?: IntFieldUpdateOperationsInput | number
    numCheckedSolution?: IntFieldUpdateOperationsInput | number
    authors?: AuthorMathProblemUncheckedUpdateManyWithoutMathProblemNestedInput
    tags?: TagMathProblemUncheckedUpdateManyWithoutMathProblemNestedInput
    mathSolutions?: MathSolutionUncheckedUpdateManyWithoutMathProblemNestedInput
    problemSet?: MathSetProbRelUncheckedUpdateManyWithoutProblemNestedInput
  }

  export type UserCreateWithoutMathSolutionsInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemCreateNestedManyWithoutUserInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelCreateNestedManyWithoutUserInput
    posts?: GroupPostCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutMathSolutionsInput = {
    username: string
    email: string
    create_time?: Date | string
    admin_type?: admin_type
    is_disabled?: boolean
    auth0_id?: string | null
    codingProblems?: AuthorCodingProblemUncheckedCreateNestedManyWithoutUserInput
    authorMathProblems?: AuthorMathProblemUncheckedCreateNestedManyWithoutUserInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutCreatorInput
    threadLiked?: UserLikeThreadUncheckedCreateNestedManyWithoutUserInput
    commentLiked?: UserLikeCommentUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    mathNotes?: MathNoteUncheckedCreateNestedManyWithoutCreatorInput
    mathProbSetList?: MathProblemSetUncheckedCreateNestedManyWithoutCreatorInput
    myFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutSenderInput
    otherFriendReqs?: FriendRequestUncheckedCreateNestedManyWithoutRecieverInput
    createdGroup?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    joinedGroups?: UserGroupRelUncheckedCreateNestedManyWithoutUserInput
    posts?: GroupPostUncheckedCreateNestedManyWithoutAuthorInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutAuthorInput
    chatSessions?: ChatSessionUserUncheckedCreateNestedManyWithoutUserInput
    groupPostMessages?: GroupPostMessageUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutMathSolutionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMathSolutionsInput, UserUncheckedCreateWithoutMathSolutionsInput>
  }

  export type MathProblemCreateWithoutMathSolutionsInput = {
    id: string
    title: string
    link?: string | null
    description?: string | null
    hint?: string | null
    difficulty?: number
    practicePoint?: number | null
    totalPoint?: number | null
    prevProblems?: string | null
    nextProblems?: string | null
    numSolution?: number
    numCheckedSolution?: number
    category: MathProblemCategoryCreateNestedOneWithoutMathProblemsInput
    authors?: AuthorMathProblemCreateNestedManyWithoutMathProblemInput
    tags?: TagMathProblemCreateNestedManyWithoutMathProblemInput
    mathNotes?: MathNoteCreateNestedManyWithoutMathProblemInput
    problemSet?: MathSetProbRelCreateNestedManyWithoutProblemInput
  }

  export type MathProblemUncheckedCreateWithoutMathSolutionsInput = {
    id: string
    title: string
    categoryId: number
    link?: string | null
    description?: string | null
    hint?: string | null
    difficulty?: number
    practicePoint?: number | null
    totalPoint?: number | null
    prevProblems?: string | null
    nextProblems?: string | null
    numSolution?: number
    numCheckedSolution?: number
    authors?: AuthorMathProblemUncheckedCreateNestedManyWithoutMathProblemInput
    tags?: TagMathProblemUncheckedCreateNestedManyWithoutMathProblemInput
    mathNotes?: MathNoteUncheckedCreateNestedManyWithoutMathProblemInput
    problemSet?: MathSetProbRelUncheckedCreateNestedManyWithoutProblemInput
  }

  export type MathProblemCreateOrConnectWithoutMathSolutionsInput = {
    where: MathProblemWhereUniqueInput
    create: XOR<MathProblemCreateWithoutMathSolutionsInput, MathProblemUncheckedCreateWithoutMathSolutionsInput>
  }

  export type UserUpsertWithoutMathSolutionsInput = {
    update: XOR<UserUpdateWithoutMathSolutionsInput, UserUncheckedUpdateWithoutMathSolutionsInput>
    create: XOR<UserCreateWithoutMathSolutionsInput, UserUncheckedCreateWithoutMathSolutionsInput>
  }

  export type UserUpdateWithoutMathSolutionsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUpdateManyWithoutUserNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUpdateManyWithoutUserNestedInput
    posts?: GroupPostUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutMathSolutionsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    create_time?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_type?: Enumadmin_typeFieldUpdateOperationsInput | admin_type
    is_disabled?: BoolFieldUpdateOperationsInput | boolean
    auth0_id?: NullableStringFieldUpdateOperationsInput | string | null
    codingProblems?: AuthorCodingProblemUncheckedUpdateManyWithoutUserNestedInput
    authorMathProblems?: AuthorMathProblemUncheckedUpdateManyWithoutUserNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCreatorNestedInput
    threadLiked?: UserLikeThreadUncheckedUpdateManyWithoutUserNestedInput
    commentLiked?: UserLikeCommentUncheckedUpdateManyWithoutUserNestedInput
    UserProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    mathNotes?: MathNoteUncheckedUpdateManyWithoutCreatorNestedInput
    mathProbSetList?: MathProblemSetUncheckedUpdateManyWithoutCreatorNestedInput
    myFriendReqs?: FriendRequestUncheckedUpdateManyWithoutSenderNestedInput
    otherFriendReqs?: FriendRequestUncheckedUpdateManyWithoutRecieverNestedInput
    createdGroup?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    joinedGroups?: UserGroupRelUncheckedUpdateManyWithoutUserNestedInput
    posts?: GroupPostUncheckedUpdateManyWithoutAuthorNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutAuthorNestedInput
    chatSessions?: ChatSessionUserUncheckedUpdateManyWithoutUserNestedInput
    groupPostMessages?: GroupPostMessageUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type MathProblemUpsertWithoutMathSolutionsInput = {
    update: XOR<MathProblemUpdateWithoutMathSolutionsInput, MathProblemUncheckedUpdateWithoutMathSolutionsInput>
    create: XOR<MathProblemCreateWithoutMathSolutionsInput, MathProblemUncheckedCreateWithoutMathSolutionsInput>
  }

  export type MathProblemUpdateWithoutMathSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: NullableIntFieldUpdateOperationsInput | number | null
    totalPoint?: NullableIntFieldUpdateOperationsInput | number | null
    prevProblems?: NullableStringFieldUpdateOperationsInput | string | null
    nextProblems?: NullableStringFieldUpdateOperationsInput | string | null
    numSolution?: IntFieldUpdateOperationsInput | number
    numCheckedSolution?: IntFieldUpdateOperationsInput | number
    category?: MathProblemCategoryUpdateOneRequiredWithoutMathProblemsNestedInput
    authors?: AuthorMathProblemUpdateManyWithoutMathProblemNestedInput
    tags?: TagMathProblemUpdateManyWithoutMathProblemNestedInput
    mathNotes?: MathNoteUpdateManyWithoutMathProblemNestedInput
    problemSet?: MathSetProbRelUpdateManyWithoutProblemNestedInput
  }

  export type MathProblemUncheckedUpdateWithoutMathSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: NullableIntFieldUpdateOperationsInput | number | null
    totalPoint?: NullableIntFieldUpdateOperationsInput | number | null
    prevProblems?: NullableStringFieldUpdateOperationsInput | string | null
    nextProblems?: NullableStringFieldUpdateOperationsInput | string | null
    numSolution?: IntFieldUpdateOperationsInput | number
    numCheckedSolution?: IntFieldUpdateOperationsInput | number
    authors?: AuthorMathProblemUncheckedUpdateManyWithoutMathProblemNestedInput
    tags?: TagMathProblemUncheckedUpdateManyWithoutMathProblemNestedInput
    mathNotes?: MathNoteUncheckedUpdateManyWithoutMathProblemNestedInput
    problemSet?: MathSetProbRelUncheckedUpdateManyWithoutProblemNestedInput
  }

  export type CodingProblemCreateWithoutContestInput = {
    id: string
    code: string
    title: string
    link?: string | null
    description?: string | null
    timeLimit?: number
    memoryLimit?: number
    difficulty?: number
    practicePoint?: number
    totalPoint?: number
    submissionNumber?: number
    acceptedNumber?: number
    visibleFrom?: Date | string | null
    category: CodingProblemCategoryCreateNestedOneWithoutCodingProblemsInput
    authors?: AuthorCodingProblemCreateNestedManyWithoutCodingProblemInput
    tags?: TagCodingProblemCreateNestedManyWithoutCodingProblemInput
    codeforcesTag?: CodefocesTagProblemCreateNestedManyWithoutProblemInput
    testCases?: TestcaseCreateNestedManyWithoutProblemInput
  }

  export type CodingProblemUncheckedCreateWithoutContestInput = {
    id: string
    code: string
    title: string
    categoryId: number
    link?: string | null
    description?: string | null
    timeLimit?: number
    memoryLimit?: number
    difficulty?: number
    practicePoint?: number
    totalPoint?: number
    submissionNumber?: number
    acceptedNumber?: number
    visibleFrom?: Date | string | null
    authors?: AuthorCodingProblemUncheckedCreateNestedManyWithoutCodingProblemInput
    tags?: TagCodingProblemUncheckedCreateNestedManyWithoutCodingProblemInput
    codeforcesTag?: CodefocesTagProblemUncheckedCreateNestedManyWithoutProblemInput
    testCases?: TestcaseUncheckedCreateNestedManyWithoutProblemInput
  }

  export type CodingProblemCreateOrConnectWithoutContestInput = {
    where: CodingProblemWhereUniqueInput
    create: XOR<CodingProblemCreateWithoutContestInput, CodingProblemUncheckedCreateWithoutContestInput>
  }

  export type CodingProblemCreateManyContestInputEnvelope = {
    data: Enumerable<CodingProblemCreateManyContestInput>
    skipDuplicates?: boolean
  }

  export type CodingProblemUpsertWithWhereUniqueWithoutContestInput = {
    where: CodingProblemWhereUniqueInput
    update: XOR<CodingProblemUpdateWithoutContestInput, CodingProblemUncheckedUpdateWithoutContestInput>
    create: XOR<CodingProblemCreateWithoutContestInput, CodingProblemUncheckedCreateWithoutContestInput>
  }

  export type CodingProblemUpdateWithWhereUniqueWithoutContestInput = {
    where: CodingProblemWhereUniqueInput
    data: XOR<CodingProblemUpdateWithoutContestInput, CodingProblemUncheckedUpdateWithoutContestInput>
  }

  export type CodingProblemUpdateManyWithWhereWithoutContestInput = {
    where: CodingProblemScalarWhereInput
    data: XOR<CodingProblemUpdateManyMutationInput, CodingProblemUncheckedUpdateManyWithoutCodingProblemsInput>
  }

  export type CodingProblemCreateWithoutTestCasesInput = {
    id: string
    code: string
    title: string
    link?: string | null
    description?: string | null
    timeLimit?: number
    memoryLimit?: number
    difficulty?: number
    practicePoint?: number
    totalPoint?: number
    submissionNumber?: number
    acceptedNumber?: number
    visibleFrom?: Date | string | null
    category: CodingProblemCategoryCreateNestedOneWithoutCodingProblemsInput
    authors?: AuthorCodingProblemCreateNestedManyWithoutCodingProblemInput
    tags?: TagCodingProblemCreateNestedManyWithoutCodingProblemInput
    codeforcesTag?: CodefocesTagProblemCreateNestedManyWithoutProblemInput
    contest?: ContestCreateNestedOneWithoutCodingProblemsInput
  }

  export type CodingProblemUncheckedCreateWithoutTestCasesInput = {
    id: string
    code: string
    title: string
    categoryId: number
    link?: string | null
    description?: string | null
    timeLimit?: number
    memoryLimit?: number
    difficulty?: number
    practicePoint?: number
    totalPoint?: number
    submissionNumber?: number
    acceptedNumber?: number
    contestId?: string | null
    visibleFrom?: Date | string | null
    authors?: AuthorCodingProblemUncheckedCreateNestedManyWithoutCodingProblemInput
    tags?: TagCodingProblemUncheckedCreateNestedManyWithoutCodingProblemInput
    codeforcesTag?: CodefocesTagProblemUncheckedCreateNestedManyWithoutProblemInput
  }

  export type CodingProblemCreateOrConnectWithoutTestCasesInput = {
    where: CodingProblemWhereUniqueInput
    create: XOR<CodingProblemCreateWithoutTestCasesInput, CodingProblemUncheckedCreateWithoutTestCasesInput>
  }

  export type CodingProblemUpsertWithoutTestCasesInput = {
    update: XOR<CodingProblemUpdateWithoutTestCasesInput, CodingProblemUncheckedUpdateWithoutTestCasesInput>
    create: XOR<CodingProblemCreateWithoutTestCasesInput, CodingProblemUncheckedCreateWithoutTestCasesInput>
  }

  export type CodingProblemUpdateWithoutTestCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: IntFieldUpdateOperationsInput | number
    memoryLimit?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: IntFieldUpdateOperationsInput | number
    totalPoint?: IntFieldUpdateOperationsInput | number
    submissionNumber?: IntFieldUpdateOperationsInput | number
    acceptedNumber?: IntFieldUpdateOperationsInput | number
    visibleFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CodingProblemCategoryUpdateOneRequiredWithoutCodingProblemsNestedInput
    authors?: AuthorCodingProblemUpdateManyWithoutCodingProblemNestedInput
    tags?: TagCodingProblemUpdateManyWithoutCodingProblemNestedInput
    codeforcesTag?: CodefocesTagProblemUpdateManyWithoutProblemNestedInput
    contest?: ContestUpdateOneWithoutCodingProblemsNestedInput
  }

  export type CodingProblemUncheckedUpdateWithoutTestCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: IntFieldUpdateOperationsInput | number
    memoryLimit?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: IntFieldUpdateOperationsInput | number
    totalPoint?: IntFieldUpdateOperationsInput | number
    submissionNumber?: IntFieldUpdateOperationsInput | number
    acceptedNumber?: IntFieldUpdateOperationsInput | number
    contestId?: NullableStringFieldUpdateOperationsInput | string | null
    visibleFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authors?: AuthorCodingProblemUncheckedUpdateManyWithoutCodingProblemNestedInput
    tags?: TagCodingProblemUncheckedUpdateManyWithoutCodingProblemNestedInput
    codeforcesTag?: CodefocesTagProblemUncheckedUpdateManyWithoutProblemNestedInput
  }

  export type AuthorCodingProblemCreateManyUserInput = {
    codingProblemId: string
  }

  export type AuthorMathProblemCreateManyUserInput = {
    mathProblemId: string
  }

  export type ThreadCreateManyAuthorInput = {
    id: string
    parentId?: string | null
    title: string
    summary: string
    published: boolean
    createdAt?: Date | string
    lastUpdateAt?: Date | string
    publishedAt?: Date | string
    content: string
    totalComments?: number
    totalRootComments?: number
    likes?: number
    views?: number
    categoryId?: number | null
  }

  export type CommentCreateManyCreatorInput = {
    id: string
    threadId: string
    parentId?: string | null
    rootId: string
    totalChildren?: number
    depth?: number
    likes?: number
    parentUsername?: string | null
    published?: boolean
    createdAt?: Date | string
    content: string
  }

  export type UserLikeThreadCreateManyUserInput = {
    threadId: string
    disable?: boolean
  }

  export type UserLikeCommentCreateManyUserInput = {
    commentId: string
    disable?: boolean
  }

  export type MathNoteCreateManyCreatorInput = {
    content: string
    mathProblemId: string
    createdAt?: Date | string
    imageLink?: string | null
  }

  export type MathSolutionCreateManyCreatorInput = {
    content: string
    mathProblemId: string
    createdAt?: Date | string
    checked?: boolean
    imageLink?: string | null
  }

  export type MathProblemSetCreateManyCreatorInput = {
    id: string
    title: string
    numberProb: number
  }

  export type FriendRequestCreateManySenderInput = {
    id?: string
    recieverId: string
    disable?: boolean
  }

  export type FriendRequestCreateManyRecieverInput = {
    id?: string
    senderId: string
    disable?: boolean
  }

  export type GroupCreateManyCreatorInput = {
    id?: string
    name: string
    generalChatSessionId?: string | null
    createdAt?: Date | string
  }

  export type UserGroupRelCreateManyUserInput = {
    groupId: string
    joinedAt: Date | string
  }

  export type GroupPostCreateManyAuthorInput = {
    id: string
    content: string
    createdAt?: Date | string
    groupId: string
    title: string
  }

  export type ChatMessageCreateManyAuthorInput = {
    id: string
    content: string
    createdAt?: Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
    sessionId: string
  }

  export type ChatSessionUserCreateManyUserInput = {
    sessionId: string
    unseenCnt?: number
    joinedAt: Date | string
  }

  export type GroupPostMessageCreateManyAuthorInput = {
    id: string
    content: string
    createdAt?: Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
    postId: string
  }

  export type AuthorCodingProblemUpdateWithoutUserInput = {
    codingProblem?: CodingProblemUpdateOneRequiredWithoutAuthorsNestedInput
  }

  export type AuthorCodingProblemUncheckedUpdateWithoutUserInput = {
    codingProblemId?: StringFieldUpdateOperationsInput | string
  }

  export type AuthorCodingProblemUncheckedUpdateManyWithoutCodingProblemsInput = {
    codingProblemId?: StringFieldUpdateOperationsInput | string
  }

  export type AuthorMathProblemUpdateWithoutUserInput = {
    mathProblem?: MathProblemUpdateOneRequiredWithoutAuthorsNestedInput
  }

  export type AuthorMathProblemUncheckedUpdateWithoutUserInput = {
    mathProblemId?: StringFieldUpdateOperationsInput | string
  }

  export type AuthorMathProblemUncheckedUpdateManyWithoutAuthorMathProblemsInput = {
    mathProblemId?: StringFieldUpdateOperationsInput | string
  }

  export type ThreadUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    totalComments?: IntFieldUpdateOperationsInput | number
    totalRootComments?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    comments?: CommentUpdateManyWithoutThreadNestedInput
    category?: ThreadCategoryUpdateOneWithoutThreadsNestedInput
    tags?: ThreadTagRelUpdateManyWithoutThreadNestedInput
    userLikes?: UserLikeThreadUpdateManyWithoutThreadNestedInput
  }

  export type ThreadUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    totalComments?: IntFieldUpdateOperationsInput | number
    totalRootComments?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: CommentUncheckedUpdateManyWithoutThreadNestedInput
    tags?: ThreadTagRelUncheckedUpdateManyWithoutThreadNestedInput
    userLikes?: UserLikeThreadUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type ThreadUncheckedUpdateManyWithoutThreadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    totalComments?: IntFieldUpdateOperationsInput | number
    totalRootComments?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CommentUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: StringFieldUpdateOperationsInput | string
    totalChildren?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    parentUsername?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    thread?: ThreadUpdateOneRequiredWithoutCommentsNestedInput
    usersLiked?: UserLikeCommentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: StringFieldUpdateOperationsInput | string
    totalChildren?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    parentUsername?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    usersLiked?: UserLikeCommentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: StringFieldUpdateOperationsInput | string
    totalChildren?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    parentUsername?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type UserLikeThreadUpdateWithoutUserInput = {
    disable?: BoolFieldUpdateOperationsInput | boolean
    thread?: ThreadUpdateOneRequiredWithoutUserLikesNestedInput
  }

  export type UserLikeThreadUncheckedUpdateWithoutUserInput = {
    threadId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserLikeThreadUncheckedUpdateManyWithoutThreadLikedInput = {
    threadId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserLikeCommentUpdateWithoutUserInput = {
    disable?: BoolFieldUpdateOperationsInput | boolean
    comment?: CommentUpdateOneRequiredWithoutUsersLikedNestedInput
  }

  export type UserLikeCommentUncheckedUpdateWithoutUserInput = {
    commentId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserLikeCommentUncheckedUpdateManyWithoutCommentLikedInput = {
    commentId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MathNoteUpdateWithoutCreatorInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageLink?: NullableStringFieldUpdateOperationsInput | string | null
    mathProblem?: MathProblemUpdateOneRequiredWithoutMathNotesNestedInput
  }

  export type MathNoteUncheckedUpdateWithoutCreatorInput = {
    content?: StringFieldUpdateOperationsInput | string
    mathProblemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MathNoteUncheckedUpdateManyWithoutMathNotesInput = {
    content?: StringFieldUpdateOperationsInput | string
    mathProblemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MathSolutionUpdateWithoutCreatorInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checked?: BoolFieldUpdateOperationsInput | boolean
    imageLink?: NullableStringFieldUpdateOperationsInput | string | null
    mathProblem?: MathProblemUpdateOneRequiredWithoutMathSolutionsNestedInput
  }

  export type MathSolutionUncheckedUpdateWithoutCreatorInput = {
    content?: StringFieldUpdateOperationsInput | string
    mathProblemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checked?: BoolFieldUpdateOperationsInput | boolean
    imageLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MathSolutionUncheckedUpdateManyWithoutMathSolutionsInput = {
    content?: StringFieldUpdateOperationsInput | string
    mathProblemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checked?: BoolFieldUpdateOperationsInput | boolean
    imageLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MathProblemSetUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    numberProb?: IntFieldUpdateOperationsInput | number
    problems?: MathSetProbRelUpdateManyWithoutMathProbSetNestedInput
  }

  export type MathProblemSetUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    numberProb?: IntFieldUpdateOperationsInput | number
    problems?: MathSetProbRelUncheckedUpdateManyWithoutMathProbSetNestedInput
  }

  export type MathProblemSetUncheckedUpdateManyWithoutMathProbSetListInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    numberProb?: IntFieldUpdateOperationsInput | number
  }

  export type FriendRequestUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    reciever?: UserUpdateOneRequiredWithoutOtherFriendReqsNestedInput
  }

  export type FriendRequestUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    recieverId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FriendRequestUncheckedUpdateManyWithoutMyFriendReqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    recieverId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FriendRequestUpdateWithoutRecieverInput = {
    id?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    sender?: UserUpdateOneRequiredWithoutMyFriendReqsNestedInput
  }

  export type FriendRequestUncheckedUpdateWithoutRecieverInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FriendRequestUncheckedUpdateManyWithoutOtherFriendReqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GroupUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generalChatSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserGroupRelUpdateManyWithoutGroupNestedInput
    posts?: GroupPostUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generalChatSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserGroupRelUncheckedUpdateManyWithoutGroupNestedInput
    posts?: GroupPostUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateManyWithoutCreatedGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    generalChatSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGroupRelUpdateWithoutUserInput = {
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserGroupRelUncheckedUpdateWithoutUserInput = {
    groupId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGroupRelUncheckedUpdateManyWithoutJoinedGroupsInput = {
    groupId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupPostUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    group?: GroupUpdateOneRequiredWithoutPostsNestedInput
    messages?: GroupPostMessageUpdateManyWithoutPostNestedInput
  }

  export type GroupPostUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    messages?: GroupPostMessageUncheckedUpdateManyWithoutPostNestedInput
  }

  export type GroupPostUncheckedUpdateManyWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type ChatMessageUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
    chatSession?: ChatSessionUpdateOneRequiredWithoutChatMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: StringFieldUpdateOperationsInput | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutChatMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: StringFieldUpdateOperationsInput | string
  }

  export type ChatSessionUserUpdateWithoutUserInput = {
    unseenCnt?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatSession?: ChatSessionUpdateOneRequiredWithoutUsersNestedInput
  }

  export type ChatSessionUserUncheckedUpdateWithoutUserInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    unseenCnt?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatSessionUserUncheckedUpdateManyWithoutChatSessionsInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    unseenCnt?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupPostMessageUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
    post?: GroupPostUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type GroupPostMessageUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type GroupPostMessageUncheckedUpdateManyWithoutGroupPostMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type UserGroupRelCreateManyGroupInput = {
    username: string
    joinedAt: Date | string
  }

  export type GroupPostCreateManyGroupInput = {
    id: string
    content: string
    authorId: string
    createdAt?: Date | string
    title: string
  }

  export type UserGroupRelUpdateWithoutGroupInput = {
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutJoinedGroupsNestedInput
  }

  export type UserGroupRelUncheckedUpdateWithoutGroupInput = {
    username?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGroupRelUncheckedUpdateManyWithoutUsersInput = {
    username?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupPostUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
    messages?: GroupPostMessageUpdateManyWithoutPostNestedInput
  }

  export type GroupPostUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    messages?: GroupPostMessageUncheckedUpdateManyWithoutPostNestedInput
  }

  export type CodingProblemCreateManyCategoryInput = {
    id: string
    code: string
    title: string
    link?: string | null
    description?: string | null
    timeLimit?: number
    memoryLimit?: number
    difficulty?: number
    practicePoint?: number
    totalPoint?: number
    submissionNumber?: number
    acceptedNumber?: number
    contestId?: string | null
    visibleFrom?: Date | string | null
  }

  export type CodingProblemUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: IntFieldUpdateOperationsInput | number
    memoryLimit?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: IntFieldUpdateOperationsInput | number
    totalPoint?: IntFieldUpdateOperationsInput | number
    submissionNumber?: IntFieldUpdateOperationsInput | number
    acceptedNumber?: IntFieldUpdateOperationsInput | number
    visibleFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authors?: AuthorCodingProblemUpdateManyWithoutCodingProblemNestedInput
    tags?: TagCodingProblemUpdateManyWithoutCodingProblemNestedInput
    codeforcesTag?: CodefocesTagProblemUpdateManyWithoutProblemNestedInput
    testCases?: TestcaseUpdateManyWithoutProblemNestedInput
    contest?: ContestUpdateOneWithoutCodingProblemsNestedInput
  }

  export type CodingProblemUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: IntFieldUpdateOperationsInput | number
    memoryLimit?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: IntFieldUpdateOperationsInput | number
    totalPoint?: IntFieldUpdateOperationsInput | number
    submissionNumber?: IntFieldUpdateOperationsInput | number
    acceptedNumber?: IntFieldUpdateOperationsInput | number
    contestId?: NullableStringFieldUpdateOperationsInput | string | null
    visibleFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authors?: AuthorCodingProblemUncheckedUpdateManyWithoutCodingProblemNestedInput
    tags?: TagCodingProblemUncheckedUpdateManyWithoutCodingProblemNestedInput
    codeforcesTag?: CodefocesTagProblemUncheckedUpdateManyWithoutProblemNestedInput
    testCases?: TestcaseUncheckedUpdateManyWithoutProblemNestedInput
  }

  export type CodingProblemUncheckedUpdateManyWithoutCodingProblemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: IntFieldUpdateOperationsInput | number
    memoryLimit?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: IntFieldUpdateOperationsInput | number
    totalPoint?: IntFieldUpdateOperationsInput | number
    submissionNumber?: IntFieldUpdateOperationsInput | number
    acceptedNumber?: IntFieldUpdateOperationsInput | number
    contestId?: NullableStringFieldUpdateOperationsInput | string | null
    visibleFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TagCodingProblemCreateManyTagInput = {
    codingProblemId: string
  }

  export type TagCodingProblemUpdateWithoutTagInput = {
    codingProblem?: CodingProblemUpdateOneRequiredWithoutTagsNestedInput
  }

  export type TagCodingProblemUncheckedUpdateWithoutTagInput = {
    codingProblemId?: StringFieldUpdateOperationsInput | string
  }

  export type TagCodingProblemUncheckedUpdateManyWithoutCodingProblemsInput = {
    codingProblemId?: StringFieldUpdateOperationsInput | string
  }

  export type CodefocesTagProblemCreateManyCodeforcesTagInput = {
    problemId: string
  }

  export type CodefocesTagProblemUpdateWithoutCodeforcesTagInput = {
    problem?: CodingProblemUpdateOneRequiredWithoutCodeforcesTagNestedInput
  }

  export type CodefocesTagProblemUncheckedUpdateWithoutCodeforcesTagInput = {
    problemId?: StringFieldUpdateOperationsInput | string
  }

  export type CodefocesTagProblemUncheckedUpdateManyWithoutProblemsInput = {
    problemId?: StringFieldUpdateOperationsInput | string
  }

  export type AuthorCodingProblemCreateManyCodingProblemInput = {
    username: string
  }

  export type TagCodingProblemCreateManyCodingProblemInput = {
    tagId: number
  }

  export type CodefocesTagProblemCreateManyProblemInput = {
    codeforcesTagId: string
  }

  export type TestcaseCreateManyProblemInput = {
    id: string
    subTestNumber: number
    description: JsonNullValueInput | InputJsonValue
  }

  export type AuthorCodingProblemUpdateWithoutCodingProblemInput = {
    user?: UserUpdateOneRequiredWithoutCodingProblemsNestedInput
  }

  export type AuthorCodingProblemUncheckedUpdateWithoutCodingProblemInput = {
    username?: StringFieldUpdateOperationsInput | string
  }

  export type AuthorCodingProblemUncheckedUpdateManyWithoutAuthorsInput = {
    username?: StringFieldUpdateOperationsInput | string
  }

  export type TagCodingProblemUpdateWithoutCodingProblemInput = {
    tag?: CodingProblemTagUpdateOneRequiredWithoutCodingProblemsNestedInput
  }

  export type TagCodingProblemUncheckedUpdateWithoutCodingProblemInput = {
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type TagCodingProblemUncheckedUpdateManyWithoutTagsInput = {
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type CodefocesTagProblemUpdateWithoutProblemInput = {
    codeforcesTag?: CodeforcesTagUpdateOneRequiredWithoutProblemsNestedInput
  }

  export type CodefocesTagProblemUncheckedUpdateWithoutProblemInput = {
    codeforcesTagId?: StringFieldUpdateOperationsInput | string
  }

  export type CodefocesTagProblemUncheckedUpdateManyWithoutCodeforcesTagInput = {
    codeforcesTagId?: StringFieldUpdateOperationsInput | string
  }

  export type TestcaseUpdateWithoutProblemInput = {
    id?: StringFieldUpdateOperationsInput | string
    subTestNumber?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
  }

  export type TestcaseUncheckedUpdateWithoutProblemInput = {
    id?: StringFieldUpdateOperationsInput | string
    subTestNumber?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
  }

  export type TestcaseUncheckedUpdateManyWithoutTestCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subTestNumber?: IntFieldUpdateOperationsInput | number
    description?: JsonNullValueInput | InputJsonValue
  }

  export type CommentCreateManyThreadInput = {
    id: string
    parentId?: string | null
    rootId: string
    totalChildren?: number
    depth?: number
    likes?: number
    parentUsername?: string | null
    creatorId: string
    published?: boolean
    createdAt?: Date | string
    content: string
  }

  export type ThreadTagRelCreateManyThreadInput = {
    tagId: string
  }

  export type UserLikeThreadCreateManyThreadInput = {
    username: string
    disable?: boolean
  }

  export type CommentUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: StringFieldUpdateOperationsInput | string
    totalChildren?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    parentUsername?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    creator?: UserUpdateOneRequiredWithoutCommentsNestedInput
    usersLiked?: UserLikeCommentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    rootId?: StringFieldUpdateOperationsInput | string
    totalChildren?: IntFieldUpdateOperationsInput | number
    depth?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    parentUsername?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    usersLiked?: UserLikeCommentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type ThreadTagRelUpdateWithoutThreadInput = {
    tag?: ThreadTagUpdateOneRequiredWithoutThreadsNestedInput
  }

  export type ThreadTagRelUncheckedUpdateWithoutThreadInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ThreadTagRelUncheckedUpdateManyWithoutTagsInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type UserLikeThreadUpdateWithoutThreadInput = {
    disable?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutThreadLikedNestedInput
  }

  export type UserLikeThreadUncheckedUpdateWithoutThreadInput = {
    username?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserLikeThreadUncheckedUpdateManyWithoutUserLikesInput = {
    username?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ThreadCreateManyCategoryInput = {
    id: string
    authorId: string
    parentId?: string | null
    title: string
    summary: string
    published: boolean
    createdAt?: Date | string
    lastUpdateAt?: Date | string
    publishedAt?: Date | string
    content: string
    totalComments?: number
    totalRootComments?: number
    likes?: number
    views?: number
  }

  export type ThreadUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    totalComments?: IntFieldUpdateOperationsInput | number
    totalRootComments?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    author?: UserUpdateOneRequiredWithoutThreadsNestedInput
    comments?: CommentUpdateManyWithoutThreadNestedInput
    tags?: ThreadTagRelUpdateManyWithoutThreadNestedInput
    userLikes?: UserLikeThreadUpdateManyWithoutThreadNestedInput
  }

  export type ThreadUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    totalComments?: IntFieldUpdateOperationsInput | number
    totalRootComments?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutThreadNestedInput
    tags?: ThreadTagRelUncheckedUpdateManyWithoutThreadNestedInput
    userLikes?: UserLikeThreadUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type ThreadTagRelCreateManyTagInput = {
    threadId: string
  }

  export type ThreadTagRelUpdateWithoutTagInput = {
    thread?: ThreadUpdateOneRequiredWithoutTagsNestedInput
  }

  export type ThreadTagRelUncheckedUpdateWithoutTagInput = {
    threadId?: StringFieldUpdateOperationsInput | string
  }

  export type ThreadTagRelUncheckedUpdateManyWithoutThreadsInput = {
    threadId?: StringFieldUpdateOperationsInput | string
  }

  export type UserLikeCommentCreateManyCommentInput = {
    username: string
    disable?: boolean
  }

  export type UserLikeCommentUpdateWithoutCommentInput = {
    disable?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutCommentLikedNestedInput
  }

  export type UserLikeCommentUncheckedUpdateWithoutCommentInput = {
    username?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserLikeCommentUncheckedUpdateManyWithoutUsersLikedInput = {
    username?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MathProblemCreateManyCategoryInput = {
    id: string
    title: string
    link?: string | null
    description?: string | null
    hint?: string | null
    difficulty?: number
    practicePoint?: number | null
    totalPoint?: number | null
    prevProblems?: string | null
    nextProblems?: string | null
    numSolution?: number
    numCheckedSolution?: number
  }

  export type MathProblemUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: NullableIntFieldUpdateOperationsInput | number | null
    totalPoint?: NullableIntFieldUpdateOperationsInput | number | null
    prevProblems?: NullableStringFieldUpdateOperationsInput | string | null
    nextProblems?: NullableStringFieldUpdateOperationsInput | string | null
    numSolution?: IntFieldUpdateOperationsInput | number
    numCheckedSolution?: IntFieldUpdateOperationsInput | number
    authors?: AuthorMathProblemUpdateManyWithoutMathProblemNestedInput
    tags?: TagMathProblemUpdateManyWithoutMathProblemNestedInput
    mathNotes?: MathNoteUpdateManyWithoutMathProblemNestedInput
    mathSolutions?: MathSolutionUpdateManyWithoutMathProblemNestedInput
    problemSet?: MathSetProbRelUpdateManyWithoutProblemNestedInput
  }

  export type MathProblemUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: NullableIntFieldUpdateOperationsInput | number | null
    totalPoint?: NullableIntFieldUpdateOperationsInput | number | null
    prevProblems?: NullableStringFieldUpdateOperationsInput | string | null
    nextProblems?: NullableStringFieldUpdateOperationsInput | string | null
    numSolution?: IntFieldUpdateOperationsInput | number
    numCheckedSolution?: IntFieldUpdateOperationsInput | number
    authors?: AuthorMathProblemUncheckedUpdateManyWithoutMathProblemNestedInput
    tags?: TagMathProblemUncheckedUpdateManyWithoutMathProblemNestedInput
    mathNotes?: MathNoteUncheckedUpdateManyWithoutMathProblemNestedInput
    mathSolutions?: MathSolutionUncheckedUpdateManyWithoutMathProblemNestedInput
    problemSet?: MathSetProbRelUncheckedUpdateManyWithoutProblemNestedInput
  }

  export type MathProblemUncheckedUpdateManyWithoutMathProblemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: NullableIntFieldUpdateOperationsInput | number | null
    totalPoint?: NullableIntFieldUpdateOperationsInput | number | null
    prevProblems?: NullableStringFieldUpdateOperationsInput | string | null
    nextProblems?: NullableStringFieldUpdateOperationsInput | string | null
    numSolution?: IntFieldUpdateOperationsInput | number
    numCheckedSolution?: IntFieldUpdateOperationsInput | number
  }

  export type TagMathProblemCreateManyTagInput = {
    mathProblemId: string
  }

  export type TagMathProblemUpdateWithoutTagInput = {
    mathProblem?: MathProblemUpdateOneRequiredWithoutTagsNestedInput
  }

  export type TagMathProblemUncheckedUpdateWithoutTagInput = {
    mathProblemId?: StringFieldUpdateOperationsInput | string
  }

  export type TagMathProblemUncheckedUpdateManyWithoutMathProblemsInput = {
    mathProblemId?: StringFieldUpdateOperationsInput | string
  }

  export type AuthorMathProblemCreateManyMathProblemInput = {
    username: string
  }

  export type TagMathProblemCreateManyMathProblemInput = {
    tagId: number
  }

  export type MathNoteCreateManyMathProblemInput = {
    creatorId: string
    content: string
    createdAt?: Date | string
    imageLink?: string | null
  }

  export type MathSolutionCreateManyMathProblemInput = {
    creatorId: string
    content: string
    createdAt?: Date | string
    checked?: boolean
    imageLink?: string | null
  }

  export type MathSetProbRelCreateManyProblemInput = {
    setId: string
    order: string
  }

  export type AuthorMathProblemUpdateWithoutMathProblemInput = {
    user?: UserUpdateOneRequiredWithoutAuthorMathProblemsNestedInput
  }

  export type AuthorMathProblemUncheckedUpdateWithoutMathProblemInput = {
    username?: StringFieldUpdateOperationsInput | string
  }

  export type AuthorMathProblemUncheckedUpdateManyWithoutAuthorsInput = {
    username?: StringFieldUpdateOperationsInput | string
  }

  export type TagMathProblemUpdateWithoutMathProblemInput = {
    tag?: MathProblemTagUpdateOneRequiredWithoutMathProblemsNestedInput
  }

  export type TagMathProblemUncheckedUpdateWithoutMathProblemInput = {
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type TagMathProblemUncheckedUpdateManyWithoutTagsInput = {
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type MathNoteUpdateWithoutMathProblemInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageLink?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: UserUpdateOneRequiredWithoutMathNotesNestedInput
  }

  export type MathNoteUncheckedUpdateWithoutMathProblemInput = {
    creatorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imageLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MathSolutionUpdateWithoutMathProblemInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checked?: BoolFieldUpdateOperationsInput | boolean
    imageLink?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: UserUpdateOneRequiredWithoutMathSolutionsNestedInput
  }

  export type MathSolutionUncheckedUpdateWithoutMathProblemInput = {
    creatorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checked?: BoolFieldUpdateOperationsInput | boolean
    imageLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MathSetProbRelUpdateWithoutProblemInput = {
    order?: StringFieldUpdateOperationsInput | string
    mathProbSet?: MathProblemSetUpdateOneRequiredWithoutProblemsNestedInput
  }

  export type MathSetProbRelUncheckedUpdateWithoutProblemInput = {
    setId?: StringFieldUpdateOperationsInput | string
    order?: StringFieldUpdateOperationsInput | string
  }

  export type MathSetProbRelUncheckedUpdateManyWithoutProblemSetInput = {
    setId?: StringFieldUpdateOperationsInput | string
    order?: StringFieldUpdateOperationsInput | string
  }

  export type MathSetProbRelCreateManyMathProbSetInput = {
    problemId: string
    order: string
  }

  export type MathSetProbRelUpdateWithoutMathProbSetInput = {
    order?: StringFieldUpdateOperationsInput | string
    problem?: MathProblemUpdateOneRequiredWithoutProblemSetNestedInput
  }

  export type MathSetProbRelUncheckedUpdateWithoutMathProbSetInput = {
    problemId?: StringFieldUpdateOperationsInput | string
    order?: StringFieldUpdateOperationsInput | string
  }

  export type MathSetProbRelUncheckedUpdateManyWithoutProblemsInput = {
    problemId?: StringFieldUpdateOperationsInput | string
    order?: StringFieldUpdateOperationsInput | string
  }

  export type GroupPostMessageCreateManyPostInput = {
    id: string
    content: string
    authorId: string
    createdAt?: Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GroupPostMessageUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
    author?: UserUpdateOneRequiredWithoutGroupPostMessagesNestedInput
  }

  export type GroupPostMessageUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GroupPostMessageUncheckedUpdateManyWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ChatMessageCreateManyChatSessionInput = {
    id: string
    content: string
    authorId: string
    createdAt?: Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ChatSessionUserCreateManyChatSessionInput = {
    username: string
    unseenCnt?: number
    joinedAt: Date | string
  }

  export type ChatMessageUpdateWithoutChatSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
    author?: UserUpdateOneRequiredWithoutChatMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateWithoutChatSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceMessage?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ChatSessionUserUpdateWithoutChatSessionInput = {
    unseenCnt?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutChatSessionsNestedInput
  }

  export type ChatSessionUserUncheckedUpdateWithoutChatSessionInput = {
    username?: StringFieldUpdateOperationsInput | string
    unseenCnt?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatSessionUserUncheckedUpdateManyWithoutUsersInput = {
    username?: StringFieldUpdateOperationsInput | string
    unseenCnt?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodingProblemCreateManyContestInput = {
    id: string
    code: string
    title: string
    categoryId: number
    link?: string | null
    description?: string | null
    timeLimit?: number
    memoryLimit?: number
    difficulty?: number
    practicePoint?: number
    totalPoint?: number
    submissionNumber?: number
    acceptedNumber?: number
    visibleFrom?: Date | string | null
  }

  export type CodingProblemUpdateWithoutContestInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: IntFieldUpdateOperationsInput | number
    memoryLimit?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: IntFieldUpdateOperationsInput | number
    totalPoint?: IntFieldUpdateOperationsInput | number
    submissionNumber?: IntFieldUpdateOperationsInput | number
    acceptedNumber?: IntFieldUpdateOperationsInput | number
    visibleFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CodingProblemCategoryUpdateOneRequiredWithoutCodingProblemsNestedInput
    authors?: AuthorCodingProblemUpdateManyWithoutCodingProblemNestedInput
    tags?: TagCodingProblemUpdateManyWithoutCodingProblemNestedInput
    codeforcesTag?: CodefocesTagProblemUpdateManyWithoutProblemNestedInput
    testCases?: TestcaseUpdateManyWithoutProblemNestedInput
  }

  export type CodingProblemUncheckedUpdateWithoutContestInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: IntFieldUpdateOperationsInput | number
    memoryLimit?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    practicePoint?: IntFieldUpdateOperationsInput | number
    totalPoint?: IntFieldUpdateOperationsInput | number
    submissionNumber?: IntFieldUpdateOperationsInput | number
    acceptedNumber?: IntFieldUpdateOperationsInput | number
    visibleFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authors?: AuthorCodingProblemUncheckedUpdateManyWithoutCodingProblemNestedInput
    tags?: TagCodingProblemUncheckedUpdateManyWithoutCodingProblemNestedInput
    codeforcesTag?: CodefocesTagProblemUncheckedUpdateManyWithoutProblemNestedInput
    testCases?: TestcaseUncheckedUpdateManyWithoutProblemNestedInput
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}